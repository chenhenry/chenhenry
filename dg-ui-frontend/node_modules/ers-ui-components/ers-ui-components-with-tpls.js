/**
 * ers-ui-components - 
 * @version v0.5.0-DEV.20160527193114
 * @link http://ersgit.analytics.moodys.net/projects/ERSUI
 * @authors ERS UI Component Team
 * @license private
 */

'use strict';/**
 * Created by serpoletg on 16/07/2015.
 */

var ers;
(function (ers) {
    var components;
    (function (components) {
        var utility;
        (function (utility) {
            var checks;
            (function (checks) {
                                /**
                 * Test if a value is truly a number, NaN not considered as a valid number.
                 * @param pValue Object to test.
                 * @return {boolean} True if parameter is a number.
                 */
                function isNumber(pValue) {
                    return typeof pValue === "number" && !isNaN(pValue);
                }
                checks.isNumber = isNumber;
                /**
                 * Test if a string value is different from undefined, null and empty string.
                 * @param pValue Value to test.
                 * @return {boolean} Boolean.
                 */
                function isEmpty(pValue) {
                    return typeof pValue === "undefined" || pValue === null || pValue === "";
                }
                checks.isEmpty = isEmpty;
            })(checks = utility.checks || (utility.checks = {}));
        })(utility = components.utility || (components.utility = {}));
    })(components = ers.components || (ers.components = {}));
})(ers || (ers = {}));/*
 * Created by zhangfa on 5/26/2015.
 */
/*
 * Created by ZhangFa on 5/13/2015.
 */
/*
 * Created by zhangfa on 5/26/2015.
 */
/*
 * Created by ZhangFa on 6/16/2015.
 */
/*
 * Created by zhangfa on 6/23/2015.
 *//**
 * The Core Services Module
 *
 * Created by zhangfa on 3/18/2015.
 */







var ers;
(function (ers) {
    var components;
    (function (components) {
        var core;
        (function (core) {
            var service;
            (function (service) {
                service._module = angular.module("ers.components.core.services", []);
            })(service = core.service || (core.service = {}));
        })(core = components.core || (components.core = {}));
    })(components = ers.components || (ers.components = {}));
})(ers || (ers = {}));/**
 * Created by zhangfa on 5/28/2015.
 */


var ers;
(function (ers) {
    var components;
    (function (components) {
        var utility;
        (function (utility) {
            var Checks = ers.components.utility.checks;
            utility.DEFAULT_VALIDATION_RULES = Object.freeze({
                REQUIRED: function () {
                    return {
                        key: "required",
                        errorMessage: "This is a required input field."
                    };
                },
                PATTERN: function (pattern) {
                    return {
                        key: "pattern",
                        errorMessage: "Bad entry. You must match the following pattern: " + pattern + "."
                    };
                },
                MIN_LENGTH: function (minLength) {
                    return {
                        key: "minlength",
                        errorMessage: "The value entered is too short. Should contain more than " + minLength + " characters."
                    };
                },
                MAX_LENGTH: function (maxlength) {
                    return {
                        key: "maxlength",
                        errorMessage: "The value entered is too long. Should contain less than " + maxlength + " characters."
                    };
                },
                NUMBER: function () {
                    return {
                        key: "number",
                        errorMessage: "Please enter a number."
                    };
                },
                NUMBER_RANGE: function (min, max, excMin, excMax, minError, maxError) {
                    var errorMsg = "";
                    if (Checks.isNumber(min) && Checks.isNumber(max)) {
                        if (excMin && excMax) {
                            errorMsg = "The number is out of range. The number should be greater than " + min + " and less than " + max + ".";
                        }
                        else if (excMin) {
                            errorMsg = "The number is out of range. The number should be greater than " + min + " and less than or equal to " + max + ".";
                        }
                        else if (excMax) {
                            errorMsg = "The number is out of range. The number should be greater than or equal to " + min + " and less than " + max + ".";
                        }
                        else {
                            errorMsg = "The number is out of range." +
                                "The number should be greater than or equal to " + min + " and less than or equal to " + max + ".";
                        }
                    }
                    else if (Checks.isNumber(min)) {
                        if (excMin) {
                            errorMsg = "The number should be greater than the min range constraint: " + min + ".";
                        }
                        else {
                            errorMsg = "The number should be greater than or equal to the min range constraint: " + min + ".";
                        }
                    }
                    else if (Checks.isNumber(max)) {
                        if (excMax) {
                            errorMsg = "The number should be less than the max range constraint:" + max + ".";
                        }
                        else {
                            errorMsg = "The number should be less than or equal to the max range constraint:" + max + ".";
                        }
                    }
                    if (minError && maxError) {
                        errorMsg = minError + " " + maxError;
                    }
                    else if (minError) {
                        errorMsg = minError;
                    }
                    else if (maxError) {
                        errorMsg = maxError;
                    }
                    return {
                        key: "range",
                        errorMessage: errorMsg
                    };
                },
                MODEL: function () {
                    return {
                        key: "model",
                        errorMessage: "Unexpected value."
                    };
                },
                DATE: function () {
                    return {
                        key: "date",
                        errorMessage: "Please enter a date.",
                        validator: function (value) {
                            if (value) {
                                if (!value.getDate) {
                                    return false;
                                }
                            }
                            return true;
                        }
                    };
                },
                PARSE_DATE: function () {
                    return {
                        key: "parse",
                        errorMessage: "Please enter a date."
                    };
                },
                MIN_DATE: function (minDate, formatMinDate) {
                    return {
                        key: "min-date",
                        errorMessage: "Entered date should not be earlier than the specified minimum date: " + formatMinDate(),
                        validator: function (value) {
                            if (!angular.isDate(minDate())) {
                                return true;
                            }
                            if (value && minDate) {
                                if (value.getTime) {
                                    if (value.getFullYear() < minDate().getFullYear()) {
                                        return false;
                                    }
                                    else if (value.getFullYear() === minDate().getFullYear()) {
                                        if (value.getMonth() < minDate().getMonth()) {
                                            return false;
                                        }
                                        else if (value.getMonth() === minDate().getMonth()) {
                                            if (value.getDate() < minDate().getDate()) {
                                                return false;
                                            }
                                        }
                                    }
                                }
                            }
                            return true;
                        }
                    };
                },
                MAX_DATE: function (maxDate, formatMaxDate) {
                    return {
                        key: "max-date",
                        errorMessage: "Entered date should not be later than the specified maximum date: " + formatMaxDate(),
                        validator: function (value) {
                            if (!angular.isDate(maxDate())) {
                                return true;
                            }
                            if (value && maxDate()) {
                                if (value.getTime) {
                                    if (value.getFullYear() > maxDate().getFullYear()) {
                                        return false;
                                    }
                                    else if (value.getFullYear() === maxDate().getFullYear()) {
                                        if (value.getMonth() > maxDate().getMonth()) {
                                            return false;
                                        }
                                        else if (value.getMonth() === maxDate().getMonth()) {
                                            if (value.getDate() > maxDate().getDate()) {
                                                return false;
                                            }
                                        }
                                    }
                                }
                            }
                            return true;
                        }
                    };
                }
            });
        })(utility = components.utility || (components.utility = {}));
    })(components = ers.components || (ers.components = {}));
})(ers || (ers = {}));
/**
 * ERS Angular utility : KEY constants.
 */
var ers;
(function (ers) {
    var components;
    (function (components) {
        var utility;
        (function (utility) {
            /**
             * Utility which contains the keyboard event constants.
             */
            utility.KEY = {
                LEFT_ARROW: 37,
                UP_ARROW: 38,
                RIGHT_ARROW: 39,
                DOWN_ARROW: 40,
                SPACE_BAR: 32,
                ENTER: 13,
                ESCAPE: 27,
                TAB: 9,
                BACKSPACE: 8
            };
        })(utility = components.utility || (components.utility = {}));
    })(components = ers.components || (ers.components = {}));
})(ers || (ers = {}));/**
 * Created by zhangfa on 6/25/2015.
 */

var ers;
(function (ers) {
    var components;
    (function (components) {
        var utility;
        (function (utility) {
            var TriggerBindUtil = (function () {
                function TriggerBindUtil() {
                }
                TriggerBindUtil.bind = function ($host, triggers, handler) {
                    if (!triggers) {
                        return;
                    }
                    triggers.split(" ").forEach(function (trigger) {
                        switch (trigger) {
                            case "mousedown":
                                $host.mousedown(handler.toggle);
                                break;
                            case "click":
                                $host.click(handler.toggle);
                                break;
                            case "hover":
                                if (handler.onTrigger) {
                                    $host.mouseenter(handler.onTrigger);
                                }
                                if (handler.onUntrigger) {
                                    $host.mouseleave(handler.onUntrigger);
                                }
                                break;
                            case "focus":
                                if (handler.onTrigger) {
                                    $host.focus(handler.onTrigger);
                                }
                                if (handler.onUntrigger) {
                                    $host.blur(handler.onUntrigger);
                                }
                                break;
                            default:
                                $host.on(trigger, handler.onTrigger);
                                break;
                        }
                    });
                };
                TriggerBindUtil.unBind = function ($host, triggers, handler) {
                    if (!triggers) {
                        return;
                    }
                    triggers.split(" ").forEach(function (trigger) {
                        switch (trigger) {
                            case "mousedown":
                                $host.off("mousedown", handler.toggle);
                                break;
                            case "click":
                                $host.off("click", handler.toggle);
                                break;
                            case "hover":
                                $host.off("mouseenter", handler.onTrigger).off("mouseleave", handler.onUntrigger);
                                break;
                            case "focus":
                                $host.off("focus", handler.onTrigger).off("blur", handler.onUntrigger);
                                break;
                            default:
                                $host.off(trigger, handler.onTrigger);
                                break;
                        }
                    });
                };
                return TriggerBindUtil;
            })();
            utility.TriggerBindUtil = TriggerBindUtil;
            ;
        })(utility = components.utility || (components.utility = {}));
    })(components = ers.components || (ers.components = {}));
})(ers || (ers = {}));/**
 * Created by BERTHETO on 11/28/2014.
 *
 * The component Module.
 */

var ers;
(function (ers) {
    var components;
    (function (components) {
        var core;
        (function (core) {
                        // Declaring the Component module.
            angular.module("ers.components.core", ["ers.components.templates",
                "ers.components.utility",
                "ers.components.core.services"]);
            core.coreModule = angular.module("ers.components.core");
            // stores the animation provider, so that we can disable animation for some components (e.g for selenium api).
            core.coreModule.config(["$animateProvider", function ($animateProvider) {
                    // ignore animations for `ers-textbox` element
                    core.coreModule["animateProvider"] = $animateProvider;
                }]);
            // Declare a module to quickly group all components for easy inclusion
            angular.module("ers.components.all", ["ers.components.accordion",
                "ers.components.passwordManagement",
                "ers.components.chart",
                "ers.components.checkbox",
                "ers.components.contextmenu",
                "ers.components.dropdown",
                "ers.components.dropdownSelect",
                "ers.components.icon",
                "ers.components.label",
                "ers.components.login",
                "ers.components.modal",
                "ers.components.navigation",
                "ers.components.numberbox",
                "ers.components.shell",
                "ers.components.tabs",
                "ers.components.textbox",
                "ers.components.radio-buttons",
                "ers.components.templates",
                "ers.components.button",
                "ers.components.calendar",
                "ers.components.combobox",
                "ers.components.layout",
                "ers.components.tooltip",
                "ers.components.popover",
                "ers.components.panel",
                "ers.components.grid",
                "ers.components.file",
                "ers.components.tree",
                "ers.components.drawer",
                "ers.components.form",
                "ers.components.toolbar"]);
        })(core = components.core || (components.core = {}));
    })(components = ers.components || (ers.components = {}));
})(ers || (ers = {}));

// only declare angular module
angular.module("ers.components.utility.checks", []);
angular.module("ers.components.utility", ["ers.components.utility.checks"]);


var ers;
(function (ers) {
    var components;
    (function (components) {
        var utility;
        (function (utility) {
                        angular.module("ers.components.utility").directive("ersEnter", enterDirective);
            /**
             * ###Enter Key directive
             * Use to catch `click ` and `key down` events on a selected element where this component is used.
             *
             * ### Examples
             *
             * #### Basic usage
             *
             * ```xml
             *
             * <form name="modalForm" ers-enter="myCtrl.onEnter()"/>
             * ```
             */
            function enterDirective() {
                return {
                    restrict: "A",
                    link: function ($scope, el, attributes) {
                        el.bind("keypress keydown", function (event) {
                            if (event.which === utility.KEY.ENTER) {
                                //$scope.$apply(function () {
                                $scope.$eval(attributes["ersEnter"])(event);
                                //  });
                                event.preventDefault();
                            }
                        });
                    }
                };
            }
        })(utility = components.utility || (components.utility = {}));
    })(components = ers.components || (ers.components = {}));
})(ers || (ers = {}));

var ers;
(function (ers) {
    var components;
    (function (components) {
        var utility;
        (function (utility) {
                        angular.module("ers.components.utility").directive("ersFocusMe", ["$timeout", focusMeDirective]);
            /**
             * ###Focus Me directive
             * Use the component to set the focus on an element where this component is used.
             *
             * ### Examples
             *
             * #### Basic usage
             *
             * ```xml
             *
             * <input  ers-focus-me="true"/>
             * ```
             */
            function focusMeDirective($timeout) {
                return {
                    restrict: "A", link: function (scope, element, attributes) {
                        if (attributes["ersFocusMe"] === "true") {
                            $timeout(function () {
                                element[0].focus();
                            });
                        }
                    }
                };
            }
        })(utility = components.utility || (components.utility = {}));
    })(components = ers.components || (ers.components = {}));
})(ers || (ers = {}));/**
 * Created by germonneauf on 10/8/2015.
 */
/**
 * Created by germonneauf on 10/7/2015.
 */


/**
 * Created by germonneauf on 10/7/2015.
 */

/**
 * Created by fangiot on 12/12/2014.
 */


var ers;
(function (ers) {
    var components;
    (function (components) {
        var core;
        (function (core) {
                        /**
             * Base controller for all component controllers. Stores a reference to the scope and element and adds the
             * 'ers-component' class to the element.
             */
            var BaseController = (function () {
                /**
                 * This method is to be called by classes that extend BaseController. You should never create an instance of this
                 * class directly.
                 *
                 * @constructor
                 *
                 * @param $scope The scope to which this directive is bound.
                 * @param $element The jQuery element to which this directive is bound.
                 */
                function BaseController($scope, $element, $attrs, $document) {
                    this.$scope = $scope;
                    this.$element = $element;
                    this.$attrs = $attrs;
                    this.$document = $document;
                }
                /**
                 * Links this directive to the specified element and adds the `ers-component` class as well.
                 *
                 * @param $scope The scope to which this directive is bound.
                 * @param element The element to which this directive should be linked.
                 * @param attributes The array of attributes on the HTML element.
                 */
                BaseController.prototype.link = function ($scope, element, attributes) {
                    element.addClass("ers-component");
                };
                return BaseController;
            })();
            core.BaseController = BaseController;
            BaseController.$inject = ["$scope", "$document", "$element"];
        })(core = components.core || (components.core = {}));
    })(components = ers.components || (ers.components = {}));
})(ers || (ers = {}));
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};





var ers;
(function (ers) {
    var components;
    (function (components) {
        var core;
        (function (core) {
            /**
             * Base component for all components.
             */
            var BaseComponent = (function (_super) {
                __extends(BaseComponent, _super);
                /**
                 * This method is to be called by classes that extend BaseComponent. You should never create an instance of this
                 * class directly.
                 *
                 * @param $element The component element.
                 * @param $timeout Angular timeout service. Currently used to execute a function when the model controller is fully loaded.
                 */
                function BaseComponent($scope, $element, $attrs, $timeout) {
                    var _this = this;
                    if ($timeout === void 0) { $timeout = undefined; }
                    _super.call(this, $scope, $element, $attrs);
                    if ($element && angular.isDefined($element)) {
                        this.$element[0].getErsComponent = function () { return _this; };
                        if ($scope) {
                            this.$scope.$on("destroy", function () {
                                delete _this.$element[0].getErsComponent;
                            });
                        }
                    }
                    this.$timeout = $timeout;
                    this.configureERSFocusDetection();
                }
                /**
                 * This function configure the ERS focus detection in order to set the "ers-focus" CSS class on the current directive
                 * when the component gets the focus, and then to remove this CSS class when the component loses the focus.
                 * I made this trick because is not easy to play with the focus state in CSS when the focus in/out is not applied directly
                 * on the directive component but in a wrapped input.
                 */
                BaseComponent.prototype.configureERSFocusDetection = function () {
                    var _this = this;
                    // Element could be undefined (not mandatory parameter in constructor)
                    if (this.$element) {
                        this.$element.on("focusin", function () {
                            _this.$element.addClass("ers-focus");
                        });
                        this.$element.on("focusout", function () {
                            _this.$element.removeClass("ers-focus");
                        });
                    }
                };
                /**
                 * Provide the appropriate delegate element for tooltip event binding.
                 * Should be overridden by child class to retrieve the appropriate DOM element on which tooltip binding is dedicated.
                 * Default behavior: return the root directive element.
                 */
                BaseComponent.prototype.getTooltipDelegate = function (type) {
                    if (type === void 0) { type = ""; }
                    return this.$element;
                };
                Object.defineProperty(BaseComponent.prototype, "ngDisabled", {
                    /**
                     * @returns {boolean} Returns true if the component is disabled, false otherwise.
                     */
                    get: function () {
                        return this._disabled;
                    },
                    /**
                     * Set the disabled state for this current component.
                     * @param value The new disabled state for this component.
                     */
                    set: function (value) {
                        this._disabled = value;
                    },
                    enumerable: true,
                    configurable: true
                });
                return BaseComponent;
            })(core.BaseController);
            core.BaseComponent = BaseComponent;
        })(core = components.core || (components.core = {}));
    })(components = ers.components || (ers.components = {}));
})(ers || (ers = {}));

// only declare angular module
angular.module("ers.components.accordion", ["ers.components.core", "ui.bootstrap.collapse"]);




var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var ers;
(function (ers) {
    var components;
    (function (components) {
        var accordion;
        (function (accordion) {
                        var BaseController = ers.components.core.BaseController;
            // Define the module
            angular.module("ers.components.accordion")
                .directive("ersAccordionGroup", AccordionGroupDirective)
                .directive("ersAccordionHeading", AccordionHeadingDirective)
                .directive("ersAccordionHeadingTransclude", AccordionGroupTranscludeHeadingDirective);
            // Define the directives
            /**
             * @-ngdoc directive
             * @name ersAccordionGroup
             * @restrict E
             * @module ers.components.accordion
             * @scope
             * @transclude
             *
             * @description
             * Use the `ers-accordion-group` to create individual accordion items within the accordion group.
             * <a ui-sref='components.ersAccordion.documentation'>Accordion</a> directive.
             *
             *
             * Multiple `ers-accordion-group` components can reside within a single `ers-accordion` directive.
             *
             * There are two ways to add a heading to the `ers-accordion-group`:
             *
             *  - Add plain text within the heading attribute of the `ers-accordion-group`.
             *  - Use the `ers-accordion-heading` directive to add any HTML content to the heading.
             *
             * Both methods place the heading text (or HTML) in the accordion groups heading section which can be styled with CSS.
             *
             * #### Visual Design Guidelines
             *
             * For more information, see the <a ui-sref='components.ersAccordion.documentation'>Accordion</a>.
             *
             * #### Example
             *
             * The following sample must be wrapped in `ers-accordion`.
             *
             * ```xml
             *  <ers-accordion-group heading="Group 3">
             *      Group 3 Content
             *  </ers-accordion-group>
             * ```
             *
             *   See the [Accordion Component](#/components/ersAccordion/documentation) component for additional information.
             *
             * @param {string} [heading] {@}
             * Add the title displayed within the accordion's heading area and activation, that is, clickable, element.
             *
             * @param {string} [sub-heading] {@?}
             * Adds a subheading, or small snippet of text next to the accordion heading.
             *
             * @param {boolean} [is-open=false] {=?}
             * Determines whether or not this group is open when the page loads. You can use this to initialize the group's
             * starting
             * state by providing `is-open="true"`, or you can use a more complex expression and control it programmatically.
             *
             * ```xml
             * <ers-checkbox ng-model="firstIsOpen">First is Open: {{firstIsOpen}}</ers-checkbox>
             *
             * <ers-accordion>
             *   <ers-accordion-group heading="Open" is-open="firstIsOpen">
             *     I should start out open
             *   </ers-accordion-group>
             * </ers-accordion>
             * ```
             *
             * @param {boolean} [ng-disabled=false] {=?}
             * Sets the individual accordion to disabled or not. As a group component, `false`
             * overrides the parent accordion's directive setting of `true`, allowing you to disable a single group while
             * the remaining accordion groups are still enabled.
             *
             */
            function AccordionGroupDirective() {
                return {
                    restrict: "E",
                    transclude: true,
                    templateUrl: "accordion/template/accordion-group-template.html",
                    // The element containing the directive will be replaced with the template
                    replace: true,
                    // Grab the parent accordion controller and our controller
                    require: ["^ersAccordion", "ersAccordionGroup"],
                    scope: {
                        heading: "@",
                        subheading: "@?",
                        isOpen: "=?",
                        ngDisabled: "=?"
                    },
                    bindToController: true,
                    controller: AccordionGroupComponent,
                    controllerAs: "vm",
                    link: function (scope, element, attrs, ctrls) {
                        var accordionCtrl = ctrls[0];
                        var groupCtrl = ctrls[1];
                        // Add the child to the parent
                        accordionCtrl.addGroup(groupCtrl);
                        // Set the parent on the child
                        groupCtrl.parent = accordionCtrl;
                    }
                };
            }
            function AccordionHeadingDirective() {
                return {
                    restrict: "E",
                    // Grab the contents to be used as the heading
                    transclude: true,
                    template: "",
                    replace: true,
                    // Require the parent group
                    require: "^ersAccordionGroup",
                    link: function (scope, element, attr, accordionGroupCtrl, transclude) {
                        /*
                         * Pass the heading to the accordion-group controller so that it can be transcluded into the right place in the
                         * template.
                         *
                         * The second parameter to transclude causes the elements to be cloned so that they work in ng-repeat.
                         */
                        accordionGroupCtrl.setHeadingTransclude(transclude(scope, angular.noop));
                    }
                };
            }
            /**
             * Use the accordion-heading  attribute inside of an accordion-group to allow HTML tags in a heading.
             *
             * <accordion-group>
             *   <accordion-heading>Heading containing HTML - <h4>"html tag"</h4> </accordion-heading>
             * </accordion-group>
             */
            function AccordionGroupTranscludeHeadingDirective() {
                return {
                    require: "^ersAccordionGroup",
                    transclude: true,
                    link: function (scope, element, attr, controller) {
                        // Watch for changes to the transcluded headed
                        scope.$watch("vm.headingTransclude", function (transcludedElement) {
                            // If we have a transcluded heading, use it
                            if (transcludedElement) {
                                element.empty();
                                element.append(transcludedElement);
                            }
                        });
                    }
                };
            }
            var AccordionGroupComponent = (function (_super) {
                __extends(AccordionGroupComponent, _super);
                function AccordionGroupComponent($scope) {
                    var _this = this;
                    // Call the super class
                    _super.call(this, $scope);
                    // Watch for changes to isOpen to see if we should close the other accordion groups
                    $scope.$watch("vm.isOpen", function (value) {
                        if (value) {
                            _this.parent.closeOtherAccordions(_this);
                        }
                    });
                    // Watch for the $destroy event and notify the parent
                    $scope.$on("$destroy", function (event) {
                        _this.parent.removeGroup(_this);
                    });
                }
                AccordionGroupComponent.prototype.setHeadingTransclude = function (element) {
                    this.headingTransclude = element;
                };
                AccordionGroupComponent.prototype.toggleOpen = function () {
                    if (!this.ngDisabled && !this.parent.ngDisabled) {
                        this.isOpen = !this.isOpen;
                    }
                };
                Object.defineProperty(AccordionGroupComponent.prototype, "isOpen", {
                    /**
                     * @returns {boolean} Returns true when the group component is open, false when the group component is closed.
                     */
                    get: function () {
                        return this._isOpen;
                    },
                    /**
                     * Sets the _isOpen value.
                     * @param value The new value for the _isOpen property.
                     */
                    set: function (value) {
                        this._isOpen = value;
                    },
                    enumerable: true,
                    configurable: true
                });
                return AccordionGroupComponent;
            })(BaseController);
            accordion.AccordionGroupComponent = AccordionGroupComponent;
        })(accordion = components.accordion || (components.accordion = {}));
    })(components = ers.components || (ers.components = {}));
})(ers || (ers = {}));




var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var ers;
(function (ers) {
    var components;
    (function (components) {
        var accordion;
        (function (accordion) {
                        var BaseComponent = ers.components.core.BaseComponent;
            // Define the module
            angular.module("ers.components.accordion").directive("ersAccordion", AccordionDirective);
            // Define the directive
            /**
             * @ngdoc directive
             * @name ersAccordion
             * @restrict E
             * @module ers.components.accordion
             * @scope
             * @transclude
             *
             *
             *
             * @description
             *
             * An accordion allows you to organize large amounts of content that can be grouped together logically.
             *
             * - Accordions should only contain one or more accordion groups.
             * - Accordion groups contain any html content.
             * - Accordion groups are collapsible.
             * - Accordion groups should not contain accordions, to avoid confusing the users.
             * - Accordions should not contain more than 8 accordion groups to avoid overwhelming your users with a
             * large amount of content.
             *
             * ### Usage
             *
             * - Use the heading attribute when you have a plain text heading.
             * - Use an accordion heading when you have HTML content in the heading.
             *
             * ### Examples
             *
             * #### Standard Accordion
             *
             * A basic accordion with three accordion groups.
             *
             * <code-editor identifier="example1" data-title="Basic Usage" html-content-url="demos/ersAccordion/basicUsage/index.html"
             * js-content-url="demos/ersAccordion/basicUsage/script.js" css-content-url="demos/ersAccordion/basicUsage/styles.css"
             * content-mode="html"></code-editor>
             *
             * #### HTML Headings
             *
             * A basic accordion with html in the accordion groups heading.
             *
             * <code-editor identifier="example4" data-title="HTML Headings" html-content-url="demos/ersAccordion/accordionHeading/index.html"
             * js-content-url="demos/ersAccordion/accordionHeading/script.js" css-content-url="demos/ersAccordion/accordionHeading/styles.css"
             * content-mode="html"></code-editor>
             *
             * #### Opening Single Accordion Group
             *
             * Close other accordion groups when opening one.
             *
             * <code-editor identifier="example2" data-title="Close Others" html-content-url="demos/ersAccordion/closeOthers/index.html"
             * js-content-url="demos/ersAccordion/closeOthers/script.js" css-content-url="demos/ersAccordion/closeOthers/styles.css"
             * content-mode="html"></code-editor>
             *
             * ####  Default Open State
             *
             * Define which accordion group is open by default.
             *
             * <code-editor identifier="example3" data-title="Is Open" html-content-url="demos/ersAccordion/groupIsOpen/index.html"
             * js-content-url="demos/ersAccordion/groupIsOpen/script.js" css-content-url="demos/ersAccordion/groupIsOpen/styles.css"
             * content-mode="html"></code-editor>
             *
             * ### Design Guidelines
             *
             * No design guidelines.
             *
             * ### Accessibility Guidelines
             *
             * No accessibility guidelines.
             *
             * @param {boolean} [ng-disabled=false] {=?}
             * (ers-accordion) Specifies whether or not the whole accordion is disabled.
             *
             * @param {boolean} [close-others=false] {=?}
             * (ers-accordion) Defines whether to close the opened accordion group when opening another.
             *
             * @param {string} [heading] {@?}
             * (ers-accordion-group) Sets the title displayed within the accordion's heading area.
             *
             * @param {string} [sub-heading] {@?}
             * (ers-accordion-group) Adds a subheading next to the accordion heading.
             *
             * @param {boolean} [is-open=false] {=?}
             * (ers-accordion-group) Sets the open state of the accordion group.
             *
             * @param {boolean} [ng-disabled=false] {=?}
             * (ers-accordion-group) Specifies whether or not the accordion group is disabled. This setting overrides the parent accordion setting,
             *  allowing you to disable a single accordion group while the others remain enabled.
             *
             */
            function AccordionDirective() {
                return {
                    restrict: "E",
                    templateUrl: "accordion/template/accordion-template.html",
                    transclude: true,
                    replace: false,
                    bindToController: true,
                    controller: AccordionComponent,
                    controllerAs: "vm",
                    scope: {
                        ngDisabled: "=?",
                        closeOthers: "=?"
                    }
                };
            }
            /**
             * AccordionComponent class
             * @class
             */
            var AccordionComponent = (function (_super) {
                __extends(AccordionComponent, _super);
                /**
                 * @constructor
                 * @param $scope The isolated scope.
                 */
                function AccordionComponent($scope) {
                    _super.call(this, $scope);
                    // This array tracks the status of the accordion groups.
                    this.groups = new Array();
                }
                /**
                 * @function Ensures that all of the groups in this accordion are closed unless the close-others attribute
                 * explicitly prevents them from closing.
                 *
                 *
                 * @param openGroup specifies the group or groups to remain open.
                 */
                AccordionComponent.prototype.closeOtherAccordions = function (openGroup) {
                    if (this.closeOthers) {
                        angular.forEach(this.groups, function (group) {
                            if (group !== openGroup) {
                                group.isOpen = false;
                            }
                        });
                    }
                };
                /**
                 * @function This is called from the accordion-group directive and adds itself to the accordion.
                 * @param The group directive.
                 */
                AccordionComponent.prototype.addGroup = function (group) {
                    // Sets the parent property
                    group.parent = this;
                    // These are added to the list of groups.
                    this.groups.push(group);
                };
                /**
                 * @function This is called from the accordion-group directive when it is time to remove the Accordion
                 * group.
                 * @param The group.
                 */
                AccordionComponent.prototype.removeGroup = function (group) {
                    var index = this.groups.indexOf(group);
                    if (index !== -1) {
                        this.groups.splice(index, 1);
                    }
                };
                return AccordionComponent;
            })(BaseComponent);
            accordion.AccordionComponent = AccordionComponent;
        })(accordion = components.accordion || (components.accordion = {}));
    })(components = ers.components || (ers.components = {}));
})(ers || (ers = {}));


var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var ers;
(function (ers) {
    var components;
    (function (components) {
        var button;
        (function (button) {
                        var BaseComponent = ers.components.core.BaseComponent;
            angular.module("ers.components.button", ["ers.components.core"]).directive("ersButton", function () {
                return {
                    restrict: "E", templateUrl: "button/template/button-template.html",
                    scope: {
                        "name": "@",
                        "class": "@",
                        "label": "@",
                        "type": "@",
                        "form": "@",
                        "ngDisabled": "=?",
                        "ngClass": "=?"
                    }, controllerAs: "ctrl", bindToController: true, controller: ButtonComponent, transclude: true
                };
            });
            /**
             * @ngdoc directive
             * @module ers.components.button
             * @scope
             * @transclude
             * @data
             * @binding
             * @name ersButton
             * @restrict E
             * @constructor
             *
             * @description
             *
             * A button performs the defined action when the user clicks it.
             *
             * - Buttons can only consist of text and/or an icon.
             * - Buttons must contain either a click event, an href, an ui-sref, or a type (for form actions).
             * - Buttons labels should be clear. Limit the button text (less is more).
             *
             * ### Usage
             *
             * - Use <b>Primary Buttons</b> for primary actions (for example, "Submit", "Login", or "Save").
             * Avoid having multiple primary buttons on the same screen.
             * - Use <b>Secondary Buttons</b> for secondary actions that accompany the primary call-to-action (for example, "Reset" or "Cancel").
             * - Use <b>Icon Buttons</b> only for special use cases where standard label buttons are too large to use (for example, Tool Bars).
             *
             * ### Examples
             *
             * #### Standard Buttons
             *
             * Primary and secondary buttons.
             *
             * <code-editor identifier="example1" data-title="Basic Buttons" html-content-url="demos/ersButton/basic/index.html"
             * js-content-url="demos/ersButton/basic/script.js" css-content-url="demos/ersButton/basic/styles.css"
             * content-mode="html"></code-editor>
             *
             * #### Disabled State
             *
             * Buttons in disabled state.
             *
             * <code-editor identifier="example2" data-title="Disabled Buttons" html-content-url="demos/ersButton/disabled/index.html"
             * js-content-url="demos/ersButton/disabled/script.js" css-content-url="demos/ersButton/disabled/styles.css"
             * content-mode="html"></code-editor>
             *
             * #### Form Buttons
             *
             * Submit and reset button in a form.
             *
             * <code-editor identifier="example4" data-title="Form Buttons" html-content-url="demos/ersButton/form/index.html"
             * js-content-url="demos/ersButton/form/script.js" css-content-url="demos/ersButton/form/styles.css"
             * content-mode="html"></code-editor>
             *
             * ### Design Guidelines
             *
             * No design guidelines.
             *
             * ### Accessibility Guidelines
             *
             * No accessibility guidelines.
             *
             * @param {string} [class=primary] {=?}
             * Specifies a static button class. Supported values are: primary and secondary.
             *
             * @param {string} [ng-class] {@?}
             * Specifies a dynamic button class.
             *
             *  @param {string} [type=button] {@?}
             * Specifies the type of button. When using a button in a form, set to either submit or reset. Supported values are: button, submit, and
             *  reset.
             *
             * @param {string} [ng-disabled=false] {=?}
             * Specifies whether or not the button is disabled. When the button is disabled, no action is possible and
             *  the button appears in the disabled style.
             *
             * @param {string} [form] {@}
             * Specifies the button form ID if the button is an auto commit.
             *
             */
            var ButtonComponent = (function (_super) {
                __extends(ButtonComponent, _super);
                /**
                 * Constructor:
                 * @param element DOM element of the injected directive.
                 */
                function ButtonComponent($scope, $element) {
                    _super.call(this, $scope, $element);
                    /**
                     * The button type, which corresponds to the tag `type` attribute.
                     *```xml
                     * <ers-button type="submit"></ers-button>
                     * ```
                     */
                    this.type = "button";
                    // store the dom element of the directive
                    this.rootElement = $element[0];
                    // add the master css class on the directive
                    this.rootElement.classList.add("ers-button");
                    this.type = this.type || "button"; // Default value if needed
                    this.$element.find("button").attr("type", this.type);
                    // default class
                    this.updateClass();
                }
                /**
                 * Manages the default CSS class directive.
                 * If no directive class is defined, a default CSS class named 'primary' is added.
                 */
                ButtonComponent.prototype.updateClass = function () {
                    if (!this.rootElement) {
                        return;
                    }
                    var btn = this.rootElement.querySelector("button");
                    if ((!this.class && !this.ngClass) || (this.class === "primary" || this.ngClass === "primary")) {
                        btn.classList.remove("btn-default");
                        btn.classList.add("btn-primary");
                    }
                    else {
                        btn.classList.remove("btn-primary");
                        btn.classList.add("btn-default");
                    }
                    this.rootElement.removeAttribute("type");
                    this.rootElement.removeAttribute("form");
                    this.rootElement.removeAttribute("name");
                };
                /**
                 * For MSIE 11 only. When the event handler detects a button click, it checks to see if the component is
                 * disabled. Events for disabled buttons are stopped.
                 * @param e mouse event.
                 */
                ButtonComponent.prototype.onClick = function (e) {
                    // hack for IE11 => event if the button is disabled the click event on the parent is triggered
                    // so the ng-click will be triggered if there is one defined on <ers-button>...
                    // => we stop the event to avoid this behaviour
                    if (this.disabled) {
                        e.stopPropagation();
                    }
                };
                Object.defineProperty(ButtonComponent.prototype, "ngClass", {
                    /*
                     * Getter => returns the computed class
                     */
                    get: function () {
                        return this._ngClass;
                    },
                    /*
                     * Setter ngClass: replaces the $scope.$watch
                     * => when value is updated => manage default css class
                     */
                    set: function (value) {
                        this._ngClass = value;
                        this.updateClass();
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ButtonComponent.prototype, "form", {
                    /*
                     * Getter => returns the form id
                     */
                    get: function () {
                        return this._form;
                    },
                    /*
                     * Setter form: the form id
                     *
                     */
                    set: function (value) {
                        this._form = value;
                        if (this.rootElement) {
                            var btn = this.rootElement.querySelector("button");
                            btn.setAttribute("form", value);
                        }
                    },
                    enumerable: true,
                    configurable: true
                });
                /* Inject the DOM element into the component. */
                ButtonComponent.$inject = ["$scope", "$element"];
                return ButtonComponent;
            })(BaseComponent);
            button.ButtonComponent = ButtonComponent;
        })(button = components.button || (components.button = {}));
    })(components = ers.components || (ers.components = {}));
})(ers || (ers = {}));
var ers;
(function (ers) {
    var components;
    (function (components) {
        var form;
        (function (form) {
            form._formModule = angular.module("ers.components.form", ["ers.components.core"]);
        })(form = components.form || (components.form = {}));
    })(components = ers.components || (ers.components = {}));
})(ers || (ers = {}));



var ers;
(function (ers) {
    var components;
    (function (components) {
        var form;
        (function (form) {
                        form._formModule.factory("ersFormService", [function () {
                    return new FormService();
                }]);
            /**
             * This service is used to interact with an HTML form.
             */
            var FormService = (function () {
                function FormService() {
                }
                /**
                 * This function highlights the invalid components in the form via a specific CSS (ers-submitted) placed at
                 * the components level.
                 *
                 * @param formElement The form element on which we display the component validation.
                 * @returns {boolean} True if the HTML form is valid, otherwise false.
                 */
                FormService.prototype.showValidation = function (formElement) {
                    return this.forEachModel(formElement, function (el) {
                        /*
                         * If the form is invalid, we must enable the enforcement of the CSS error by adding the "ers-submitted" class.
                         * This implies that the component has already integrated the "ers-submitted" class in their CSS to activate
                         * the CSS error.
                         *
                         */
                        el.addClass(FormService.CSSCLASSNAME);
                        // if the element is an ers component, this ers component should be informed that error tooltip should be displayed
                        var domEl = el.get(0);
                        if (domEl["getErsComponent"]) {
                            var c = domEl.getErsComponent();
                            if (c.manageErrorMessage) {
                                c.manageErrorMessage();
                            }
                        }
                    });
                };
                /**
                 * Removes the CSS class "ers-submitted" on all of the ng model elements.
                 *
                 * @param formElement The form element on which we will show the component validation.
                 * @param resetModelStyle If true (default), the style of ng model controller (dirty, touched).
                 * @returns {boolean} If the HTML form is valid, true, otherwise, false.
                 *
                 */
                FormService.prototype.hideValidation = function (formElement, resetModelStyle) {
                    if (resetModelStyle === void 0) { resetModelStyle = true; }
                    return this.forEachModel(formElement, function (el) {
                        el.removeClass(FormService.CSSCLASSNAME);
                        if (resetModelStyle) {
                            var ctrl = angular.element(el).controller("ngModel");
                            if (ctrl) {
                                ctrl.$setPristine();
                                ctrl.$setUntouched();
                            }
                        }
                        // if the element is an ers component, this ers component should be informed that error tooltip should be hidden
                        var domEl = el.get(0);
                        if (domEl["getErsComponent"]) {
                            var c = domEl.getErsComponent();
                            if (c.manageErrorMessage) {
                                c.manageErrorMessage();
                            }
                        }
                    });
                };
                /**
                 * Loops on all ng model elements and iterates the function for each element.
                 * @param formElement The form element.
                 * @param iterator The function to execute for each element.
                 * @returns {boolean} True if the HTML form is valid, otherwise, false.
                 */
                FormService.prototype.forEachModel = function (formElement, iterator) {
                    if (formElement) {
                        var formController = formElement.scope()[formElement.attr("name")];
                        var eltsFound = formElement.find("*[name][ng-model]"); // Variable created for debug purpose.
                        angular.forEach(eltsFound, function (value) {
                            var el = $(value);
                            if (angular.isDefined(formController[el.attr("name")])) {
                                iterator(el);
                            }
                        });
                        return formController.$valid;
                    }
                    else {
                        return false;
                    }
                };
                /**
                 * The CSS Class that is set when the form is submitted.
                 */
                FormService.CSSCLASSNAME = "ers-submitted";
                return FormService;
            })();
            form.FormService = FormService;
        })(form = components.form || (components.form = {}));
    })(components = ers.components || (ers.components = {}));
})(ers || (ers = {}));




var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var ers;
(function (ers) {
    var components;
    (function (components) {
        var core;
        (function (core) {
            var FormService = ers.components.form.FormService;
            /**
             * Class which will be extended by all the editable components which can be used in an HTML form.
             */
            var EditComponent = (function (_super) {
                __extends(EditComponent, _super);
                /**
                 * Constructor of the edit component.
                 *
                 * @param $element The component element.
                 * @param $timeout Angular timeout service. Currently used to execute a function when the model controller is fully loaded.
                 */
                function EditComponent($scope, $element, $attrs, $timeout, vm) {
                    _super.call(this, $scope, $element, $attrs, $timeout);
                    this._vm = vm;
                }
                Object.defineProperty(EditComponent.prototype, "vm", {
                    /**
                     * @returns {IValidationManager} Returns the validation manager service.
                     */
                    get: function () {
                        return this._vm;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(EditComponent.prototype, "ngModelController", {
                    // IValidationTarget implementation begins
                    get: function () {
                        return this._ngModelCtrl;
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * @returns {string} Returns the ID attribute of the current component.
                 */
                EditComponent.prototype.id = function () {
                    return this.$attrs["id"];
                };
                /**
                 * Error message is created only if the control is not "pristine" or if the a form was triggered!
                 * @returns {boolean} true if the errorMessage should be created
                 */
                EditComponent.prototype.showError = function () {
                    return !this.ngModelController.$pristine || this.$element.hasClass(FormService.CSSCLASSNAME);
                };
                EditComponent.prototype.focusedElement = function () {
                    // Can be override by the subclass.
                    // By default, this method return this.$element. But for more complex component it can be necessary to override this function
                    // to take the expected element.
                    return this.$element;
                };
                EditComponent.prototype.validationRules = function () {
                    // Can be override by the subclass
                    return [];
                };
                /**
                 * Method used to configure how to do when the model controller is fully loaded. Can be override by sub components.
                 */
                EditComponent.prototype.onNgModelCtrlLoaded = function () {
                    // Sub component can override this function to implements all it need when the model controller is fully loaded
                    // ($modelValue and $viewValue).
                };
                // IValidationTarget implementation ends
                /**
                 * This function can be override BUT you must make a call of this base function from the sub function.
                 * Set the model controller.
                 * @param value The model controller.
                 */
                EditComponent.prototype.setNgModelController = function (value) {
                    var _this = this;
                    this._ngModelCtrl = value;
                    if (this.vm) {
                        this.vm.registerTarget(this);
                    }
                    if (angular.isDefined(this.$timeout)) {
                        this.$timeout(function () {
                            _this.onNgModelCtrlLoaded();
                            // The $destroy event will be configured into the $timeout because we have to wait until the end of the current digest
                            // cycle in order to access to the scope.
                            _this.$element.scope().$on("$destroy", function () {
                                if (_this.vm) {
                                    _this.vm.unregisterTarget(_this);
                                }
                            });
                        }, 0, false);
                    }
                };
                /**
                 * Called when a submit is submitted / reset => controls have to manage the validation error messages
                 */
                EditComponent.prototype.manageErrorMessage = function () {
                    this.vm.manageMessage(this);
                };
                return EditComponent;
            })(core.BaseComponent);
            core.EditComponent = EditComponent;
        })(core = components.core || (components.core = {}));
    })(components = ers.components || (ers.components = {}));
})(ers || (ers = {}));

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};



/**
 * @ngdoc directive
 *
 * @name ersCalendar
 *
 * @restrict E
 * @module ers.components.calendar
 *
 * @description
 *
 * A calendar can display a date picker and/or validate entered dates.
 *
 * ### Usage
 *
 * - Use a calendar when you need a user to provide a date.
 *
 * ### Examples
 *
 * #### Basic Usage
 *
 * A basic calendar and the associated date picker.
 *
 * <code-editor identifier="example1" data-title="Basic Calendar" html-content-url="demos/ersCalendar/basicUsage/index.html"
 * js-content-url="demos/ersCalendar/basicUsage/script.js" css-content-url="demos/ersCalendar/basicUsage/styles.css"
 * content-mode="html"></code-editor>
 *
 * #### Custom Date Format
 *
 * Define the format of the displayed date.
 *
 * <code-editor identifier="example2" data-title="Custom Date Format" html-content-url="demos/ersCalendar/customDateFormat/index.html"
 * js-content-url="demos/ersCalendar/customDateFormat/script.js" css-content-url="demos/ersCalendar/customDateFormat/styles.css"
 * content-mode="html"></code-editor>
 *
 * #### Date Range
 *
 * Define the min and max dates.
 *
 * <code-editor identifier="example3" data-title="Other Usage" html-content-url="demos/ersCalendar/otherUsage/index.html"
 * js-content-url="demos/ersCalendar/otherUsage/script.js" css-content-url="demos/ersCalendar/otherUsage/styles.css"
 * content-mode="html"></code-editor>
 *
 * #### Non Editable Calendars
 *
 * Disabled and Read Only.
 *
 * <code-editor identifier="example3" data-title="Other Usage" html-content-url="demos/ersCalendar/disabledReadonly/index.html"
 * js-content-url="demos/ersCalendar/disabledReadonly/script.js" css-content-url="demos/ersCalendar/disabledReadonly/styles.css"
 * content-mode="html"></code-editor>
 *
 * ### Design Guidelines
 *
 * No design guidelines.
 *
 * ### Accessibility Guidelines
 *
 * No accessibility guidelines.
 *
 * @param {expression} ng-model {=}
 *
 * Binds a model to the scope.
 *
 * @param {expression} ng-change {&?}
 *
 * Evaluates the given expression when the user changes the input. The expression is evaluated immediately, unlike the
 * JavaScript onchange event which only triggers at the end of a change.
 *
 * @param {expression} [ng-readonly=false] {=?}
 *
 * Specifies whether or not the calendar is editable.
 *
 * @param {expression} [ng-disabled=false] {=?}
 *
 * Specifies whether or not the calendar is disabled. When disabled, the calendar is not editable and appears in the disabled style.
 *
 * @param {string} [date-format=yyyy-MM-dd] {@?}
 * Sets the displayed date format. For example, yyyy/MM/dd, where 'yyyy' is the fully qualified year, 'MM' is the two digit month, and 'dd'
 *  is the two digit day. For more information about the date format pattern, see the Angular date filter documentation.
 *
 * @param {string} [min-date] {=?}
 *
 * Sets the minimum date that the user can choose.
 *
 *
 * @param {string} [max-date] {=?}
 *
 * Sets the maximum date that the user can choose.
 *
 *
 *
 * @param {string} [current-text=Today] {@?}
 *
 * Sets the text on the button that selects the current date.
 *
 *
 * @param {string} [close-text=Done] {@?}
 *
 * Sets the text on the button that closes the date picker.
 *
 *
 *
 * @param {string} [clear-text=Clear] {@?}
 *
 * Sets the text on the button that resets the calendar.
 *
 *
 * @param {boolean} [show-button-bar=false] {=?}
 *
 * Sets whether or not to display the button bar.
 *
 *
 *
 *
 *
 *
 */
var ers;
(function (ers) {
    var components;
    (function (components) {
        var calendar;
        (function (calendar) {
                        var DEFAULT_VALIDATION_RULES = ers.components.utility.DEFAULT_VALIDATION_RULES;
            var EditComponent = ers.components.core.EditComponent;
            angular.module("ers.components.calendar", [
                "ers.components.core", "ui.bootstrap"
            ]).directive("ersCalendar", function () {
                return {
                    restrict: "E",
                    templateUrl: "calendar/template/calendar-template.html",
                    scope: {
                        onClose: "=?",
                        appendToBody: "=?",
                        showButtonBar: "=?",
                        ngModel: "=",
                        ngReadonly: "=?",
                        ngRequired: "=?",
                        ngDisabled: "=?",
                        ngChange: "&?",
                        dateFormat: "@?",
                        minDate: "=?",
                        maxDate: "=?",
                        currentText: "@?",
                        clearText: "@?",
                        closeText: "@?"
                    },
                    bindToController: true,
                    controller: CalendarComponent,
                    controllerAs: "calendarCtrl",
                    require: ["ersCalendar", "ngModel"],
                    link: function ($scope, $element, $attrs, controllers) {
                        controllers[0]["link"]();
                    }
                };
            });
            angular.module("ers.components.calendar").directive("uibDatepickerPopupWrap", function () {
                return {
                    link: function (scope, element, attrs) {
                        // ID to capture DOM element and store it into controller for future access.
                        // element.uniqueId();
                        var controller = scope.$parent["calendarCtrl"];
                        element.attr("id", controller.calendarId + "-datepicker");
                        // Override directive
                        attrs["ngStyle"] = "{display: (isOpen && 'block') || 'none'}";
                    }
                };
            });
            var CalendarComponent = (function (_super) {
                __extends(CalendarComponent, _super);
                function CalendarComponent($scope, $document, $attrs, $element, vm, $timeout, $filter, $exceptionHandler) {
                    _super.call(this, $scope, $element, $attrs, $timeout, vm);
                    this.hasBeenOpened = false; //this is to work within the grid component
                    if (angular.isUndefined(this.appendToBody)) {
                        this.appendToBody = true;
                    }
                    if (angular.isUndefined(this.ngModel)) {
                        void 0;
                    }
                    this.$scope = $scope;
                    this.$document = $document;
                    this.$attrs = $attrs;
                    this.$element = $element;
                    this.$timeout = $timeout;
                    this._filter = $filter;
                    this.showButtonBar = this.showButtonBar || false;
                    this.dateOptions = {
                        minDate: this.minDate,
                        maxDate: this.maxDate,
                        startingDay: 1,
                        showWeeks: false
                    };
                    this.setWatchers();
                }
                CalendarComponent.prototype.link = function () {
                    var _this = this;
                    //creates unique hash if no ID is provided
                    this.calendarId = this.$element.attr("id") || (((1 + Math.random()) * 0x10000) | 0).toString(16).substring(1).toUpperCase();
                    this.$element.attr("id", this.calendarId);
                    // this.EditComponent = this.$element.find("input");
                    _super.prototype.setNgModelController.call(this, this.$element.controller("ngModel"));
                    setTimeout(function () {
                        _this.popup = angular.element($("#" + _this.calendarId + "-datepicker")); // Datepicker pop-up
                        _this.popup.addClass("ers-calendar");
                    }, 0);
                    if (this.onClose) {
                        this.open();
                    }
                };
                CalendarComponent.prototype.open = function () {
                    var _this = this;
                    if (!this.ngReadonly && !this.ngDisabled) {
                        this.isOpen = true;
                    }
                    if (!this.hasBeenOpened) {
                        this.$scope.$watch(function () { return _this.isOpen; }, function () {
                            setTimeout(function () {
                                if (!_this.isOpen) {
                                    if (_this.onClose) {
                                        _this.onClose();
                                    }
                                }
                            }, 0);
                        });
                    }
                    this.hasBeenOpened = true;
                };
                ;
                CalendarComponent.prototype.dateChanged = function () {
                    this.ngModelController.$setDirty();
                    if (this.ngModel.getDate && this.ngModelController.$valid) {
                        this.ngModelController.$setViewValue(this.ngModel);
                    }
                    if (this.ngChange) {
                        this.ngChange();
                    }
                };
                CalendarComponent.prototype.validationRules = function () {
                    var _this = this;
                    var minDateRule = DEFAULT_VALIDATION_RULES.MIN_DATE(function () { return _this.minDate; }, function () {
                        return _this._filter("date")(_this.minDate, _this.dateFormat);
                    });
                    var maxDateRule = DEFAULT_VALIDATION_RULES.MAX_DATE(function () { return _this.maxDate; }, function () {
                        return _this._filter("date")(_this.maxDate, _this.dateFormat);
                    });
                    var dateRule = DEFAULT_VALIDATION_RULES.DATE();
                    var requiredRule = DEFAULT_VALIDATION_RULES.REQUIRED();
                    this.ngModelController.$validators["required"] = function (modelValue, viewValue) {
                        if (_this.ngRequired && _this.ngModelController.$dirty) {
                            if (modelValue === null || modelValue === undefined || modelValue === "") {
                                return false;
                            }
                        }
                        return true;
                    };
                    return [requiredRule, minDateRule, maxDateRule, dateRule];
                };
                CalendarComponent.prototype.setWatchers = function () {
                    var _this = this;
                    this.$scope.$watch(function () {
                        return _this.minDate;
                    }, function () {
                        _this.dateOptions["minDate"] = _this.minDate;
                        _this.ngModelController.$validate();
                        if (!_this.ngModelController.$valid) {
                            _this.ngModelController.$setDirty();
                        }
                        setTimeout(function () {
                            _this.ngModel = _this.ngModelController.$viewValue;
                        }, 0);
                    });
                    this.$scope.$watch(function () {
                        return _this.maxDate;
                    }, function () {
                        _this.dateOptions["maxDate"] = _this.maxDate;
                        _this.ngModelController.$validate();
                        if (!_this.ngModelController.$valid) {
                            _this.ngModelController.$setDirty();
                        }
                        setTimeout(function () {
                            _this.ngModel = _this.ngModelController.$viewValue;
                        }, 0);
                    });
                };
                CalendarComponent.DEFAULT_DATE_FORMAT = "yyyy/MM/dd";
                CalendarComponent.$inject = ["$scope", "$document", "$attrs", "$element", "validationManager", "$timeout", "$filter", "$exceptionHandler"];
                return CalendarComponent;
            })(EditComponent);
            calendar.CalendarComponent = CalendarComponent;
        })(calendar = components.calendar || (components.calendar = {}));
    })(components = ers.components || (ers.components = {}));
})(ers || (ers = {}));

/*
 * Created by serpoletg on 06/03/2015.
 */
var ers;
(function (ers) {
    var components;
    (function (components) {
        var chart;
        (function (chart) {
                    })(chart = components.chart || (components.chart = {}));
    })(components = ers.components || (ers.components = {}));
})(ers || (ers = {}));


var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
/*
 * Created by serpoletg on 23/03/2015.
 */
var ers;
(function (ers) {
    var components;
    (function (components) {
        var chart;
        (function (chart) {
                        var BaseComponent = ers.components.core.BaseComponent;
            /**
             * Chart Directive
             * Main class for the chart component directive.
             */
            var ChartComponent = (function (_super) {
                __extends(ChartComponent, _super);
                /**
                 * @constructor Default constructor.
                 */
                function ChartComponent($scope, $q) {
                    _super.call(this, $scope);
                    /** Stores definition of a fc chart : chart definition + data. */
                    this.dataSource = {};
                    /** True if chart is ready to be displayed, used by template to apply some specific class. */
                    this._ready = false;
                    this.$q = $q;
                }
                /**
                 * Cleans the fusion chart properly. Removes event listener if any. Dispose the object. Set the internal to null.
                 */
                ChartComponent.prototype.disposeChart = function () {
                    var _this = this;
                    var defer = this.$q.defer();
                    if (this.chartObj) {
                        if (this.events) {
                            for (var key in this.events) {
                                if (this.events.hasOwnProperty(key)) {
                                    this.chartObj.removeEventListener(key, this.events[key]);
                                }
                            }
                        }
                        this.chartObj.addEventListener("disposed", function () {
                            _this.chartObj = null;
                            defer.resolve(true);
                        });
                        this.chartObj.addEventListener("disposeCancelled", function () {
                            defer.reject(new Error("Chart failed to be disposed!"));
                        });
                        this.chartObj.dispose();
                    }
                    else {
                        defer.resolve(true);
                    }
                    return defer.promise;
                };
                /**
                 * Sets a value on a property of the fusion chart configuration store, if this property is not already set.
                 * @param pProperty Property to set.
                 * @param pValue Value to apply.
                 */
                ChartComponent.prototype.applyProperty = function (pProperty, pValue) {
                    if (!angular.isDefined(this.fcConfig[pProperty])) {
                        this.fcConfig[pProperty] = pValue;
                    }
                };
                /**
                 * Apply all default properties for the fusion chart configuration store.
                 */
                ChartComponent.prototype.applyDefaultProperties = function () {
                    this.applyProperty("width", "100%");
                    this.applyProperty("height", "100%");
                    // Data Format
                    this.applyProperty("dataFormat", "json");
                    // Message style
                    this.applyProperty("baseChartMessageColor", "#666666");
                    this.applyProperty("baseChartMessageFont", "Verdana");
                    this.applyProperty("baseChartMessageFontSize", 10);
                    // Background
                    this.applyProperty("containerBackgroundColor", "#ffffff");
                    this.applyProperty("containerBackgroundOpacity", 1);
                };
                /**
                 * Link function.
                 * @param $scope the checkbox controller scope
                 * @param element  Html element
                 * @param attributes Html attribute
                 */
                ChartComponent.prototype.link = function ($scope, element, attributes) {
                    var _this = this;
                    // Check for mandatory attributes : Type of chart.
                    if (!angular.isDefined(this.type)) {
                        throw new Error("Type attribute is mandatory on ChartDirective!");
                    }
                    _super.prototype.link.call(this, $scope, element, attributes);
                    // Link to DOM
                    this._containerId = this.computeContainerId();
                    this.fcConfig.id = this.computeFusionChartId();
                    //this.fcConfig.renderAt = this.getContainerId();
                    this.fcConfig.renderAt = element[0].children[0];
                    // Sets the default properties values.
                    this.applyDefaultProperties();
                    // Define the chart
                    if (this.definition && (typeof this.definition === "string" || Object.keys(this.definition).length)) {
                        this.buildChart();
                    }
                    // Add listener for destroy, avoid memory leak.
                    $scope.$on("$destroy", function () {
                        _this.disposeChart();
                    });
                    // Deep watch on some properties that are structure, normally only a definition or chart/data properties
                    // are dynamic. For now, we support dynamic changes for definition, data, chart and events of Fusionchart
                    // definition structure. Maybe to change in the future as it can becomes too resources consuming.
                    // We are using ready listener on fusion charts to be sure that we do not 2x initialize fusions chart
                    FusionCharts.ready(function () {
                        ["definition", "data", "chart", "events"].forEach(function (prop) {
                            _this.$scope.$watch("ctrl." + prop, function (newVal) {
                                _this[prop] = newVal;
                            }, true);
                        });
                    });
                };
                /**
                 * Builds Fusion chart object, wait for FC library to be loaded to create instance. If a chart already exists, destroy it.
                 */
                ChartComponent.prototype.buildChart = function () {
                    var _this = this;
                    var createChart = function (b) {
                        _this.chartObj = new FusionCharts(_this.fcConfig);
                        if (_this.linked) {
                            _this.chartObj.configureLink(_this.linked);
                        }
                        _this.chartObj.render();
                        _this.ready = true;
                        _this.$scope.$applyAsync();
                    };
                    if (this.chartObj) {
                        this.disposeChart().then(createChart).catch(function (error) { return error; });
                    }
                    else {
                        FusionCharts.ready(createChart);
                    }
                };
                Object.defineProperty(ChartComponent.prototype, "containerId", {
                    /**
                     * Gets the value for containerId property.
                     * @return string as value.
                     */
                    get: function () {
                        return this._containerId;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ChartComponent.prototype, "id", {
                    /**
                     * Gets the value for id property.
                     * @return string as value.
                     */
                    get: function () {
                        return this._id;
                    },
                    /**
                     * Sets the value on id property.
                     * @param pValue value to set as string.
                     */
                    set: function (pValue) {
                        this._id = pValue;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ChartComponent.prototype, "type", {
                    /**
                     * Gets the value for type property.
                     * @return string as value.
                     */
                    get: function () {
                        return this.fcConfig.type;
                    },
                    /**
                     * Sets the value on type property.
                     * @param pValue value to set as string.
                     */
                    set: function (pValue) {
                        this.fcConfig.type = pValue;
                        if (this.chartObj) {
                            this.chartObj.chartType(pValue);
                        }
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ChartComponent.prototype, "definition", {
                    /**
                     * Gets the value for definition property.
                     * @return Object as value.
                     */
                    get: function () {
                        return this.fcConfig.dataSource;
                    },
                    /**
                     * Sets the value on definition property.
                     * @param pValue value to set as Object.
                     */
                    set: function (pValue) {
                        if (pValue) {
                            this.fcConfig.dataSource = pValue;
                            if (this.chartObj) {
                                this.chartObj.setChartData(pValue, this.dataFormat);
                            }
                        }
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ChartComponent.prototype, "chartObj", {
                    /**
                     * Gets the value for chart property.
                     * @return any as value.
                     */
                    get: function () {
                        return this._chartObj;
                    },
                    /**
                     * Sets the value on chart property.
                     * @param pValue value to set as any.
                     */
                    set: function (pValue) {
                        this._chartObj = pValue;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ChartComponent.prototype, "fcConfig", {
                    /**
                     * Gets the value for fcConfig property.
                     * @return  as value.
                     */
                    get: function () {
                        if (!this._fcConfig) {
                            this._fcConfig = {
                                "dataSource": {}, "width": "100%", "height": "100%"
                            };
                        }
                        return this._fcConfig;
                    },
                    /**
                     * Sets the value on fcConfig property.
                     * @param pValue value to set as Object.
                     */
                    set: function (pValue) {
                        this._fcConfig = pValue;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ChartComponent.prototype, "ready", {
                    /**
                     * Gets the value for ready property.
                     * @return boolean as value.
                     */
                    get: function () {
                        return this._ready;
                    },
                    /**
                     * Sets the value on ready property.
                     * @param pValue value to set as boolean.
                     */
                    set: function (pValue) {
                        this._ready = pValue;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ChartComponent.prototype, "containerBackgroundColor", {
                    /**
                     * Gets the value for containerBackgroundColor property.
                     * @return  as value.
                     */
                    get: function () {
                        return this.fcConfig.containerBackgroundColor;
                    },
                    /**
                     * Sets the value on containerBackgroundColor property.
                     * @param pValue value to set as .
                     */
                    set: function (pValue) {
                        this.fcConfig.containerBackgroundColor = pValue;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ChartComponent.prototype, "containerBackgroundOpacity", {
                    /**
                     * Gets the value for containerBackgroundOpacity property.
                     * @return string as value.
                     */
                    get: function () {
                        return this.fcConfig.containerBackgroundOpacity;
                    },
                    /**
                     * Sets the value on containerBackgroundOpacity property.
                     * @param pValue value to set as string.
                     */
                    set: function (pValue) {
                        this.fcConfig.containerBackgroundOpacity = pValue;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ChartComponent.prototype, "baseChartMessageFont", {
                    /**
                     * Gets the value for baseChartMessageFont property.
                     * @return string as value.
                     */
                    get: function () {
                        return this.fcConfig.baseChartMessageFont;
                    },
                    /**
                     * Sets the value on baseChartMessageFont property.
                     * @param pValue value to set as string.
                     */
                    set: function (pValue) {
                        this.fcConfig.baseChartMessageFont = pValue;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ChartComponent.prototype, "baseChartMessageFontSize", {
                    /**
                     * Gets the value for baseChartMessageFontSize property.
                     * @return number as value.
                     */
                    get: function () {
                        return this.fcConfig.baseChartMessageFontSize;
                    },
                    /**
                     * Sets the value on baseChartMessageFontSize property.
                     * @param pValue value to set as number.
                     */
                    set: function (pValue) {
                        this.fcConfig.baseChartMessageFontSize = pValue;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ChartComponent.prototype, "baseChartMessageColor", {
                    /**
                     * Gets the value for baseChartMessageColor property.
                     * @return string as value.
                     */
                    get: function () {
                        return this.fcConfig.baseChartMessageColor;
                    },
                    /**
                     * Sets the value on baseChartMessageColor property.
                     * @param pValue value to set as string.
                     */
                    set: function (pValue) {
                        this.fcConfig.baseChartMessageColor = pValue;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ChartComponent.prototype, "renderErrorMessage", {
                    /**
                     * Gets the value for renderErrorMessage property.
                     * @return boolean as value.
                     */
                    get: function () {
                        return this.fcConfig.renderErrorMessage;
                    },
                    /**
                     * Sets the value on renderErrorMessage property.
                     * @param pValue value to set as boolean.
                     */
                    set: function (pValue) {
                        this.fcConfig.renderErrorMessage = String(pValue).toLowerCase() === "true";
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ChartComponent.prototype, "showChartLoadingMessage", {
                    /**
                     * Gets the value for showChartLoadingMessage property.
                     * @return boolean as value.
                     */
                    get: function () {
                        return this.fcConfig.showChartLoadingMessage;
                    },
                    /**
                     * Sets the value on showChartLoadingMessage property.
                     * @param pValue value to set as boolean.
                     */
                    set: function (pValue) {
                        this.fcConfig.showChartLoadingMessage = String(pValue).toLowerCase() === "true";
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ChartComponent.prototype, "showDataLoadingMessage", {
                    /**
                     * Gets the value for showDataLoadingMessage property.
                     * @return boolean as value.
                     */
                    get: function () {
                        return this.fcConfig.showDataLoadingMessage;
                    },
                    /**
                     * Sets the value on showDataLoadingMessage property.
                     * @param pValue value to set as boolean.
                     */
                    set: function (pValue) {
                        this.fcConfig.showDataLoadingMessage = String(pValue).toLowerCase() === "true";
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ChartComponent.prototype, "loadMessage", {
                    /**
                     * Gets the value for loadMessage property.
                     * @return string as value.
                     */
                    get: function () {
                        return this.fcConfig.loadMessage;
                    },
                    /**
                     * Sets the value on loadMessage property.
                     * @param pValue value to set as string.
                     */
                    set: function (pValue) {
                        this.fcConfig.loadMessage = pValue;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ChartComponent.prototype, "typeNotSupportedMessage", {
                    /**
                     * Gets the value for typeNotSupportedMessage property.
                     * @return string as value.
                     */
                    get: function () {
                        return this.fcConfig.typeNotSupportedMessage;
                    },
                    /**
                     * Sets the value on typeNotSupportedMessage property.
                     * @param pValue value to set as string.
                     */
                    set: function (pValue) {
                        this.fcConfig.typeNotSupportedMessage = pValue;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ChartComponent.prototype, "dataEmptyMessage", {
                    /**
                     * Gets the value for dataEmptyMessage property.
                     * @return string as value.
                     */
                    get: function () {
                        return this.fcConfig.dataEmptyMessage;
                    },
                    /**
                     * Sets the value on dataEmptyMessage property.
                     * @param pValue value to set as string.
                     */
                    set: function (pValue) {
                        this.fcConfig.dataEmptyMessage = pValue;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ChartComponent.prototype, "dataInvalidMessage", {
                    /**
                     * Gets the value for dataInvalidMessage property.
                     * @return string as value.
                     */
                    get: function () {
                        return this.fcConfig.dataInvalidMessage;
                    },
                    /**
                     * Sets the value on dataInvalidMessage property.
                     * @param pValue value to set as string.
                     */
                    set: function (pValue) {
                        this.fcConfig.dataInvalidMessage = pValue;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ChartComponent.prototype, "dataLoadErrorMessage", {
                    /**
                     * Gets the value for dataLoadErrorMessage property.
                     * @return string as value.
                     */
                    get: function () {
                        return this.fcConfig.dataLoadErrorMessage;
                    },
                    /**
                     * Sets the value on dataLoadErrorMessage property.
                     * @param pValue value to set as string.
                     */
                    set: function (pValue) {
                        this.fcConfig.dataLoadErrorMessage = pValue;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ChartComponent.prototype, "dataLoadStartMessage", {
                    /**
                     * Gets the value for dataLoadStartMessage property.
                     * @return string as value.
                     */
                    get: function () {
                        return this.fcConfig.dataLoadStartMessage;
                    },
                    /**
                     * Sets the value on dataLoadStartMessage property.
                     * @param pValue value to set as string.
                     */
                    set: function (pValue) {
                        this.fcConfig.dataLoadStartMessage = pValue;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ChartComponent.prototype, "dataFormat", {
                    /**
                     * Gets the value for dataFormat property.
                     * @return string as value.
                     */
                    get: function () {
                        return this.fcConfig.dataFormat;
                    },
                    /**
                     * Sets the value on dataFormat property.
                     * @param pValue value to set as string.
                     */
                    set: function (pValue) {
                        this.fcConfig.dataFormat = pValue;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ChartComponent.prototype, "events", {
                    /**
                     * Gets the value for events property.
                     * @return Object as value.
                     */
                    get: function () {
                        return this.fcConfig.events;
                    },
                    /**
                     * Sets the value on events property.
                     * @param pValue value to set as Object.
                     */
                    set: function (pValue) {
                        if (pValue) {
                            this.fcConfig.events = pValue;
                        }
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ChartComponent.prototype, "chart", {
                    /**
                     * Gets the value for chart property.
                     * @return Object as value.
                     */
                    get: function () {
                        return this.fcConfig.dataSource.chart;
                    },
                    /**
                     * Sets the value on chart property.
                     * @param pValue value to set as Object.
                     */
                    set: function (pValue) {
                        // Normally, as a watcher has been setup on this property with deep watch, the setter is called only when
                        // some property of pValue has changed, EXCEPT when registering the watcher the setters are called,
                        // so to avoid rebuild of chart (because 'link' method has already done the job before), we add a check here.
                        if (!angular.equals(this.fcConfig.dataSource.chart, pValue)) {
                            this.fcConfig.dataSource.chart = pValue;
                            this.buildChart();
                        }
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ChartComponent.prototype, "data", {
                    /**
                     * Gets the value for data property.
                     * @return Object as value.
                     */
                    get: function () {
                        return this.fcConfig.dataSource.data;
                    },
                    /**
                     * Sets the value on data property.
                     * @param pValue value to set as Object.
                     */
                    set: function (pValue) {
                        if (pValue != null && angular.isDefined(pValue)) {
                            this.fcConfig.dataSource.data = pValue;
                            this.applyChartProperties();
                        }
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * Generic method to apply changes in the chart definition if fc chart already instanciated.
                 */
                ChartComponent.prototype.applyChartProperties = function () {
                    if (this.chartObj) {
                        this.chartObj.setChartData(this.fcConfig.dataSource, this.dataFormat);
                    }
                };
                Object.defineProperty(ChartComponent.prototype, "dataset", {
                    /**
                     * Gets the value for dataset property.
                     * @return Object as value.
                     */
                    get: function () {
                        return this.fcConfig.dataSource.dataset;
                    },
                    /**
                     * Sets the value on dataset property.
                     * @param pValue value to set as Object.
                     */
                    set: function (pValue) {
                        this.fcConfig.dataSource.dataset = pValue;
                        this.applyChartProperties();
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ChartComponent.prototype, "linkdedata", {
                    /**
                     * Gets the value for linkdedata property.
                     * @return Object as value.
                     */
                    get: function () {
                        return this.fcConfig.dataSource.linkdedata;
                    },
                    /**
                     * Sets the value on linkdedata property.
                     * @param pValue value to set as Object.
                     */
                    set: function (pValue) {
                        this.fcConfig.dataSource.linkdedata = pValue;
                        this.applyChartProperties();
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ChartComponent.prototype, "trendlines", {
                    /**
                     * Gets the value for trendlines property.
                     * @return Object as value.
                     */
                    get: function () {
                        return this.fcConfig.dataSource.trendlines;
                    },
                    /**
                     * Sets the value on trendlines property.
                     * @param pValue value to set as Object.
                     */
                    set: function (pValue) {
                        this.fcConfig.dataSource.trendlines = pValue;
                        this.applyChartProperties();
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ChartComponent.prototype, "vtrendlines", {
                    /**
                     * Gets the value for vtrendlines property.
                     * @return Object as value.
                     */
                    get: function () {
                        return this.fcConfig.dataSource.vtrendlines;
                    },
                    /**
                     * Sets the value on vtrendlines property.
                     * @param pValue value to set as Object.
                     */
                    set: function (pValue) {
                        this.fcConfig.dataSource.vtrendlines = pValue;
                        this.applyChartProperties();
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ChartComponent.prototype, "annotations", {
                    /**
                     * Gets the value for annotations property.
                     * @return Object as value.
                     */
                    get: function () {
                        return this.fcConfig.dataSource.annotations;
                    },
                    /**
                     * Sets the value on annotations property.
                     * @param pValue value to set as Object.
                     */
                    set: function (pValue) {
                        this.fcConfig.dataSource.annotations = pValue;
                        this.applyChartProperties();
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ChartComponent.prototype, "colorrange", {
                    /**
                     * Gets the value for colorrange property.
                     * @return Object as value.
                     */
                    get: function () {
                        return this.fcConfig.dataSource.colorrange;
                    },
                    /**
                     * Sets the value on colorrange property.
                     * @param pValue value to set as Object.
                     */
                    set: function (pValue) {
                        this.fcConfig.dataSource.colorrange = pValue;
                        this.applyChartProperties();
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ChartComponent.prototype, "lineset", {
                    /**
                     * Gets the value for lineset property.
                     * @return Object as value.
                     */
                    get: function () {
                        return this.fcConfig.dataSource.lineset;
                    },
                    /**
                     * Sets the value on lineset property.
                     * @param pValue value to set as Object.
                     */
                    set: function (pValue) {
                        this.fcConfig.dataSource.lineset = pValue;
                        this.applyChartProperties();
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ChartComponent.prototype, "axis", {
                    /**
                     * Gets the value for axis property.
                     * @return Object as value.
                     */
                    get: function () {
                        return this.fcConfig.dataSource.axis;
                    },
                    /**
                     * Sets the value on axis property.
                     * @param pValue value to set as Object.
                     */
                    set: function (pValue) {
                        this.fcConfig.dataSource.axis = pValue;
                        this.applyChartProperties();
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ChartComponent.prototype, "connectors", {
                    /**
                     * Gets the value for connectors property.
                     * @return Object as value.
                     */
                    get: function () {
                        return this.fcConfig.dataSource.connectors;
                    },
                    /**
                     * Sets the value on connectors property.
                     * @param pValue value to set as Object.
                     */
                    set: function (pValue) {
                        this.fcConfig.dataSource.connectors = pValue;
                        this.applyChartProperties();
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ChartComponent.prototype, "pointers", {
                    /**
                     * Gets the value for pointers property.
                     * @return Object as value.
                     */
                    get: function () {
                        return this.fcConfig.dataSource.pointers;
                    },
                    /**
                     * Sets the value on pointers property.
                     * @param pValue value to set as Object.
                     */
                    set: function (pValue) {
                        this.fcConfig.dataSource.pointers = pValue;
                        this.applyChartProperties();
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ChartComponent.prototype, "value", {
                    /**
                     * Gets the value for value property.
                     * @return Object as value.
                     */
                    get: function () {
                        return this.fcConfig.dataSource.value;
                    },
                    /**
                     * Sets the value on value property.
                     * @param pValue value to set as Object.
                     */
                    set: function (pValue) {
                        this.fcConfig.dataSource.value = pValue;
                        this.applyChartProperties();
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ChartComponent.prototype, "processes", {
                    /**
                     * Gets the value for processes property.
                     * @return Object as value.
                     */
                    get: function () {
                        return this.fcConfig.dataSource.processes;
                    },
                    /**
                     * Sets the value on processes property.
                     * @param pValue value to set as Object.
                     */
                    set: function (pValue) {
                        this.fcConfig.dataSource.processes = pValue;
                        this.applyChartProperties();
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ChartComponent.prototype, "tasks", {
                    /**
                     * Gets the value for tasks property.
                     * @return Object as value.
                     */
                    get: function () {
                        return this.fcConfig.dataSource.tasks;
                    },
                    /**
                     * Sets the value on tasks property.
                     * @param pValue value to set as Object.
                     */
                    set: function (pValue) {
                        this.fcConfig.dataSource.tasks = pValue;
                        this.applyChartProperties();
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ChartComponent.prototype, "rows", {
                    /**
                     * Gets the value for rows property.
                     * @return Object as value.
                     */
                    get: function () {
                        return this.fcConfig.dataSource.rows;
                    },
                    /**
                     * Sets the value on rows property.
                     * @param pValue value to set as Object.
                     */
                    set: function (pValue) {
                        this.fcConfig.dataSource.rows = pValue;
                        this.applyChartProperties();
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ChartComponent.prototype, "columns", {
                    /**
                     * Gets the value for columns property.
                     * @return  as value.
                     */
                    get: function () {
                        return this.fcConfig.dataSource.columns;
                    },
                    /**
                     * Sets the value on columns property.
                     * @param pValue value to set as .
                     */
                    set: function (pValue) {
                        this.fcConfig.dataSource.columns = pValue;
                        this.applyChartProperties();
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ChartComponent.prototype, "map", {
                    /**
                     * Gets the value for map property.
                     * @return Object as value.
                     */
                    get: function () {
                        return this.fcConfig.dataSource.map;
                    },
                    /**
                     * Sets the value on map property.
                     * @param pValue value to set as Object.
                     */
                    set: function (pValue) {
                        this.fcConfig.dataSource.map = pValue;
                        this.applyChartProperties();
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ChartComponent.prototype, "markers", {
                    /**
                     * Gets the value for markers property.
                     * @return Object as value.
                     */
                    get: function () {
                        return this.fcConfig.dataSource.markers;
                    },
                    /**
                     * Sets the value on markers property.
                     * @param pValue value to set as Object.
                     */
                    set: function (pValue) {
                        this.fcConfig.dataSource.markers = pValue;
                        this.applyChartProperties();
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ChartComponent.prototype, "categories", {
                    /**
                     * Gets the value for categories property.
                     * @return Object as value.
                     */
                    get: function () {
                        return this.fcConfig.dataSource.categories;
                    },
                    /**
                     * Sets the value on categories property.
                     * @param pValue value to set as Object.
                     */
                    set: function (pValue) {
                        this.fcConfig.dataSource.categories = pValue;
                        this.applyChartProperties();
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ChartComponent.prototype, "baseChartMessageImageHAlign", {
                    /**
                     * Gets the value for baseChartMessageImageHAlign property.
                     * @return string as value.
                     */
                    get: function () {
                        return this.fcConfig.baseChartMessageImageHAlign;
                    },
                    /**
                     * Sets the value on baseChartMessageImageHAlign property.
                     * @param pValue value to set as string.
                     */
                    set: function (pValue) {
                        this.fcConfig.baseChartMessageImageHAlign = pValue;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ChartComponent.prototype, "baseChartMessageImageVAlign", {
                    /**
                     * Gets the value for baseChartMessageImageVAlign property.
                     * @return string as value.
                     */
                    get: function () {
                        return this.fcConfig.baseChartMessageImageVAlign;
                    },
                    /**
                     * Sets the value on baseChartMessageImageVAlign property.
                     * @param pValue value to set as string.
                     */
                    set: function (pValue) {
                        this.fcConfig.baseChartMessageImageVAlign = pValue;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ChartComponent.prototype, "baseChartMessageImageAlpha", {
                    /**
                     * Gets the value for baseChartMessageImageAlpha property.
                     * @return number as value.
                     */
                    get: function () {
                        return this.fcConfig.baseChartMessageImageAlpha;
                    },
                    /**
                     * Sets the value on baseChartMessageImageAlpha property.
                     * @param pValue value to set as number.
                     */
                    set: function (pValue) {
                        this.fcConfig.baseChartMessageImageAlpha = pValue;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ChartComponent.prototype, "baseChartMessageImageScale", {
                    /**
                     * Gets the value for baseChartMessageImageScale property.
                     * @return number as value.
                     */
                    get: function () {
                        return this.fcConfig.baseChartMessageImageScale;
                    },
                    /**
                     * Sets the value on baseChartMessageImageScale property.
                     * @param pValue value to set as number.
                     */
                    set: function (pValue) {
                        this.fcConfig.baseChartMessageImageScale = pValue;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ChartComponent.prototype, "containerClassName", {
                    /**
                     * Gets the value for containerClassName property.
                     * @return string  as value.
                     */
                    get: function () {
                        return this.fcConfig.containerClassName;
                    },
                    /**
                     * Sets the value on containerClassName property.
                     * @param pValue value to set as string .
                     */
                    set: function (pValue) {
                        this.fcConfig.containerClassName = pValue;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ChartComponent.prototype, "linked", {
                    /**
                     * Gets the value for link property.
                     * @return fc.IChartLink as value.
                     */
                    get: function () {
                        return this.fcConfig.link;
                    },
                    /**
                     * Sets the value on link property.
                     * @param pValue value to set as fc.IChartLink.
                     */
                    set: function (pValue) {
                        this.fcConfig.link = pValue;
                        if (this.chartObj) {
                            this.chartObj.configureLink(pValue);
                        }
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * Builds a specific id for DOM el in the template. The fusion charts object will directly refer to this DOM ID.
                 * @return {string} ID.
                 */
                ChartComponent.prototype.computeContainerId = function () {
                    return angular.isDefined(this._id) ? this._id + ChartComponent.CONTAINER_SUFFIX : Date.now() +
                        ChartComponent.CONTAINER_SUFFIX;
                };
                /**
                 * Builds a specific id for js fusion chart instance.
                 * @return {string} ID.
                 */
                ChartComponent.prototype.computeFusionChartId = function () {
                    return angular.isDefined(this._id) ? this._id + ChartComponent.FC_SUFFIX : Date.now() + ChartComponent.FC_SUFFIX;
                };
                /** Suffix for DOM element that will contains the fc chart object. */
                ChartComponent.CONTAINER_SUFFIX = "_cContainer";
                /** Suffix to identify the fc chart object. */
                ChartComponent.FC_SUFFIX = "_fusionChart";
                // Dependency injection
                ChartComponent.$inject = ["$scope", "$q"];
                return ChartComponent;
            })(BaseComponent);
            chart.ChartComponent = ChartComponent;
        })(chart = components.chart || (components.chart = {}));
    })(components = ers.components || (ers.components = {}));
})(ers || (ers = {}));
;

var ers;
(function (ers) {
    var components;
    (function (components) {
        var chart;
        (function (chart) {
            var ChartModule = (function () {
                function ChartModule() {
                }
                ChartModule.MODULE_NAME = "ers.components.chart";
                ChartModule.DEPENDENCIES = ["ers.components.core"];
                ChartModule.DIRECTIVE_NAME = "ersChart";
                return ChartModule;
            })();
            chart.ChartModule = ChartModule;
            // Declare the Angular module.
            angular.module(ChartModule.MODULE_NAME, ChartModule.DEPENDENCIES);
        })(chart = components.chart || (components.chart = {}));
    })(components = ers.components || (ers.components = {}));
})(ers || (ers = {}));



/*
 * Created by serpoletg on 06/03/2015.
 */
var ers;
(function (ers) {
    var components;
    (function (components) {
        var chart;
        (function (chart) {
                        angular.module(chart.ChartModule.MODULE_NAME).directive(chart.ChartModule.DIRECTIVE_NAME, function () {
                return chartDirective();
            });
            /**
             * @ngdoc directive
             * @scope
             * @name ersChart
             * @module ers.components.chart
             * @tag ers-chart
             * @restrict E
             * @binding
             * @data
             * @attribute
             *
             * @description
             *
             * A chart displays any chart type object supported by the FusionCharts library version 3.7.1, including various types of charts, widgets,
             *  power charts, maps, or Gantt charts. For more information, see the
             *  <a href="http://docs.fusioncharts.com/archive/3.7.1/#_ga=1.63945071.1579866760.1438605296" target="_blank">Fusion
             * Charts documentation</a>.
             *
             * ### Usage
             *
             * Use a chart when you want to help the user visualize the data.
             *
             * The chart uses most of the default FusionChart parameters. The **Definition**, **Format**, and **loadStartMessage** parameters differ
             *  from the usual FusionChart attributes.
             *
             * - **Definition**&#151;The Definition attribute replaces the `dataSource` FusionChart parameter. It concatenates
             * the configuration and data aspects of the chart.
             * - **Format**&#151;The Format attribute replaces the `dataFormat` FusionChart parameter. It describes the type of data that feeds
             *  the chart.
             * - **loadStartMessage**&#151;The loadStartMessage attribute replaces the `dataLoadStartMessage` FusionChart
             * parameter. It sets the message so that it displays before the chart data begins loading.
             *
             * Additional properties can be set by suffixing the property name with the corresponding message key:
             *
             *   - dataLoadStartMessageFont
             *   - dataLoadStartMessageFontSize
             *   - dataLoadStartMessageColor
             *
             * If key message properties are not specified, the default CSS style sheet is used.
             *
             * - The default css sizes the chart at 100% for width and height in regards of the parent container.
             * - If you want to size the chart independently, use ng-style for dynamicity or style attributes.
             *
             * ### Examples
             *
             * #### Column2D chart
             *
             * <code-editor identifier="example1" data-title="Column2D chart" html-content-url="demos/ersChart/columnChart/index.html"
             * js-content-url="demos/ersChart/columnChart/script.js" css-content-url="demos/ersChart/columnChart/styles.css"
             * content-mode="html"></code-editor>
             *
             * #### Pie chart
             *
             * <code-editor identifier="example2" data-title="Pie chart" html-content-url="demos/ersChart/pieChart/index.html"
             * js-content-url="demos/ersChart/pieChart/script.js" css-content-url="demos/ersChart/pieChart/styles.css"
             * content-mode="html"></code-editor>
             *
             * #### Area chart
             *
             * <code-editor identifier="example3" data-title="Area chart" html-content-url="demos/ersChart/areaChart/index.html"
             * js-content-url="demos/ersChart/areaChart/script.js" css-content-url="demos/ersChart/areaChart/styles.css"
             * content-mode="html"></code-editor>
             *
             * #### Chart sizing
             *
             * Example demonstrate size the bar chart defined through style and ng-style attributes
             *
             * <code-editor identifier="example4" data-title="Chart sizing" html-content-url="demos/ersChart/chartSize/index.html"
             * js-content-url="demos/ersChart/chartSize/script.js" css-content-url="demos/ersChart/chartSize/styles.css"
             * content-mode="html"></code-editor>
             *
             * ### Design Guidelines
             * - Fusion Charts accept standard CSS styling. For more information, see
             * <a href="http://blog.fusioncharts.com/2013/06/bar-charts-or-column-charts/" target="new">
             * Choosing the right chart type</a>.
             *
             * ### Accessibility Guidelines
             *
             * No accessibility guidelines
             *
             * @param {string} type {@}
             * Provides the name or chart type to be rendered. The data passed to the chart must be compatible with the type of chart specified.
             * For the full list of available charts, see <a href="http://docs.fusioncharts.com/tutorial-setup-list-of-charts.html" target="new">
             * List of Charts</a>.
             *
             * @param {object} definition {=*}
             * Sets the data source and chart configuration. The definition attribute replaces the `dataSource` FusionChart parameter. For more
             *  information about on setting and configuring FusionCharts data sources,
             *  see <a href="http://docs.fusioncharts.com/FusionCharts.properties.html#dataFormats" target="new">dataFormats</a>.
             *
             * @param {string} [format=json] {@?}
             * Sets the type of data passed to the dataSource, either JSON or XML. The Format attribute replaces the dataFormat FusionChart
             *  parameter. For more information about setting and passing data types, see
             * <a href="http://docs.fusioncharts.com/FusionCharts.properties.html#dataFormats" target="new">dataFormats</a>.
             *
             * @param {object} chart {=*?}
             * Sets the visual configuration for the chart.
             *
             * @param {object} data {=*?}
             * Sets the data to be passed to the chart.
             *
             * @param {object} events {=*?}
             * Sets the events bound to the chart. You can bind multiple events to
             * a chart instance with this option by passing an object to this option, where each key is an event
             * name initialized by FusionCharts and value for that key is a callback in the format of an eventListener.
             * For more information about binding events to a chart instance, see
             * <a href="http://docs.fusioncharts.com/archive/3.7.1/api/fusioncharts/fusioncharts-typedefs.html#eventListener" target="new">
             * Events</a>.
             */
            function chartDirective() {
                return {
                    restrict: "E",
                    scope: {
                        id: "@",
                        type: "@",
                        dataFormat: "@?format",
                        definition: "=*?",
                        chart: "=*?",
                        data: "=*?",
                        events: "=*?",
                        showDataLoadingMessage: "@?",
                        showChartLoadingMessage: "@?",
                        dataLoadStartMessage: "@?loadStartMessage",
                        dataLoadErrorMessage: "@?loadErrorMessage",
                        dataInvalidMessage: "@?",
                        dataEmptyMessage: "@?",
                        typeNotSupportedMessage: "@?",
                        loadMessage: "@?",
                        renderErrorMessage: "@?",
                        baseChartMessageFont: "@?",
                        baseChartMessageFontSize: "@?",
                        baseChartMessageColor: "@?",
                        baseChartMessageImageHAlign: "@?",
                        baseChartMessageImageVAlign: "@?",
                        baseChartMessageImageAlpha: "@?",
                        baseChartMessageImageScale: "@?",
                        containerBackgroundColor: "@?",
                        containerBackgroundOpacity: "@?",
                        containerClassName: "@?",
                        linked: "@?link",
                        categories: "@?",
                        dataset: "@?",
                        linkdedata: "@?",
                        trendlines: "@?",
                        vtrendlines: "@?",
                        annotations: "@?",
                        colorrange: "@?",
                        lineset: "@?",
                        axis: "@?",
                        connectors: "@?",
                        pointers: "@?",
                        value: "@?",
                        processes: "@?",
                        tasks: "@?",
                        rows: "@?",
                        columns: "@?",
                        map: "@?",
                        markers: "@?"
                    },
                    bindToController: true,
                    controller: chart.ChartComponent,
                    controllerAs: "ctrl",
                    templateUrl: "chart/template/chart-template.html",
                    link: function (scope, element, attributes) {
                        element.addClass("ers-chart");
                        element.controller("ersChart").link(scope, element, attributes);
                    }
                };
            }
            ;
        })(chart = components.chart || (components.chart = {}));
    })(components = ers.components || (ers.components = {}));
})(ers || (ers = {}));//
//Created by germonneauf on 16/01/2015.
//
//
//Created by germonneauf on 28/01/2015.
//
/**
 * The Checkbox scope interface.
 */
var ers;
(function (ers) {
    var components;
    (function (components) {
        var checkbox;
        (function (checkbox) {
            var CheckboxModel = (function () {
                /**
                 * The default constructor properties.
                 */
                function CheckboxModel() {
                    // Default properties
                    this.cbModel = false.toString();
                    this.cbDisable = false;
                    this.cbRequired = false;
                    this.trueValue = true.toString();
                    this.falseValue = false.toString();
                }
                CheckboxModel.prototype.setValues = function (pTrue, pFalse) {
                    this.trueValue = pTrue;
                    this.falseValue = pFalse;
                };
                CheckboxModel.prototype.checked = function () {
                    return (this.cbModel === this.trueValue);
                };
                CheckboxModel.prototype.required = function () {
                    return this.cbRequired;
                };
                CheckboxModel.prototype.setRequired = function (pValue) {
                    this.cbRequired = pValue;
                };
                CheckboxModel.prototype.disabled = function () {
                    return (this.cbDisable.toString() === true.toString());
                };
                CheckboxModel.prototype.setDisable = function (pValue) {
                    this.cbDisable = pValue;
                };
                CheckboxModel.prototype.readonly = function () {
                    return this.cbReadonly;
                };
                CheckboxModel.prototype.setReadonly = function (pValue) {
                    this.cbReadonly = pValue;
                };
                return CheckboxModel;
            })();
            checkbox.CheckboxModel = CheckboxModel;
        })(checkbox = components.checkbox || (components.checkbox = {}));
    })(components = ers.components || (ers.components = {}));
})(ers || (ers = {}));






/*
 * Created by germonneauf on 28/01/2015.
 */
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var ers;
(function (ers) {
    var components;
    (function (components) {
        var checkbox;
        (function (checkbox) {
            var KEY = ers.components.utility.KEY;
            var DEFAULT_VALIDATION_RULES = ers.components.utility.DEFAULT_VALIDATION_RULES;
            var EditComponent = ers.components.core.EditComponent;
            /**
             * The Checkbox Directive
             * The main class for the checkbox component directive.
             */
            var CheckboxComponent = (function (_super) {
                __extends(CheckboxComponent, _super);
                /**
                 * @constructor
                 */
                function CheckboxComponent($scope, $element, $attrs, $timeout, vm) {
                    _super.call(this, $scope, $element, $attrs, $timeout, vm);
                    this._internalRequired = false;
                    this._internalReadonly = false;
                    this._internalDisabled = false;
                    this._internalTrueValue = true;
                    this._internalFalseValue = false;
                    // Set class and checkbox div element
                    this.$element.addClass("ers-checkbox");
                    this.divCb = $element.find(".erscheckbox");
                    // Initialize
                    this.initOptions();
                    this.setTabIndex();
                    // Add listeners and watchers
                    this.addListeners();
                    this.addWatchers();
                }
                /**
                 * @function Initializes the checkbox options.
                 */
                CheckboxComponent.prototype.initOptions = function () {
                    if (angular.isDefined(this.ngTrueValue)) {
                        this._internalTrueValue = this.ngTrueValue;
                    }
                    if (angular.isDefined(this.ngFalseValue)) {
                        this._internalFalseValue = this.ngFalseValue;
                    }
                    if (angular.isDefined(this.ngReadonly)) {
                        this._internalReadonly = this.ngReadonly;
                    }
                    if (angular.isDefined(this.ngDisabled)) {
                        this._internalDisabled = this.ngDisabled;
                    }
                    if (angular.isDefined(this.ngRequired)) {
                        this._internalRequired = this.ngRequired;
                    }
                };
                /**
                 * Initializes the mouse and keyboard event listeners.
                 */
                CheckboxComponent.prototype.addListeners = function () {
                    var _this = this;
                    // 'mousedown event is not triggered before 'click event'.
                    // Avoid focus on a component when it is disabled.
                    this.$element.on("mousedown", function (jqEvent) {
                        if (_this.ngDisabled) {
                            jqEvent.stopImmediatePropagation();
                            jqEvent.preventDefault();
                        }
                    });
                    // Manage click on checkbox
                    this.divCb.on("click", function (jqEvent) {
                        _this.notifyModel();
                        jqEvent.stopPropagation();
                        jqEvent.preventDefault();
                    });
                    // Manage accessibility with keyboard (space)
                    this.$element.on("keydown", function (jqEvent) {
                        _this.onKeyDown(jqEvent);
                    });
                    // Manage blur event
                    this.$element.on("blur", function (jqEvent) {
                        // Force touched (in case where checkbox was not touched but had focus)
                        _this.ngModelController.$setTouched();
                        // Run $validate with checkbox touched
                        _this.ngModelController.$validate();
                    });
                };
                /**
                 * @function Sets watchers on the disabled and read-only options, redrawing the checkbox when the options change.
                 *
                 *
                 *
                 */
                CheckboxComponent.prototype.addWatchers = function () {
                    var _this = this;
                    // Watch disabled option and redraw on change
                    this.$scope.$watch(function () {
                        return _this.ngDisabled;
                    }, function () {
                        _this.updateDOMDisabled();
                    });
                    // Watch readonly option and redraw on change
                    this.$scope.$watch(function () {
                        return _this.ngReadonly;
                    }, function () {
                        _this.updateDOMReadonly();
                    });
                };
                /**
                 * Sets the model controller that validates the component.
                 * @param modelController
                 */
                CheckboxComponent.prototype.setNgModelController = function (modelController) {
                    var _this = this;
                    _super.prototype.setNgModelController.call(this, modelController);
                    this.ngModelController.$render = function () {
                        _this.updateDOMChecked();
                    };
                };
                /**
                 * Returns the check box state, checked or unchecked.
                 * @returns {boolean}
                 */
                CheckboxComponent.prototype.isChecked = function () {
                    return this.ngModelController.$modelValue === this._internalTrueValue;
                };
                /**
                 * @function Manages the focus sequence.
                 */
                CheckboxComponent.prototype.setTabIndex = function () {
                    this._tabindex = this.$element.attr("tabindex");
                    if (!this._tabindex) {
                        this.$element.attr("tabindex", this._tabindex = "0");
                    }
                };
                /**
                 * Updates the DOM to modify the checked or unchecked classes.
                 */
                CheckboxComponent.prototype.updateDOMChecked = function () {
                    if (this.divCb) {
                        this.divCb.toggleClass("unchecked", !this.isChecked());
                        this.divCb.toggleClass("checked", this.isChecked());
                    }
                };
                /**
                 * Updates the DOM to modify the disabled class.
                 */
                CheckboxComponent.prototype.updateDOMDisabled = function () {
                    if (this.divCb) {
                        this.divCb.toggleClass("disabled", this.ngDisabled ? true : false);
                        this.$element.attr("tabindex", this.ngDisabled ? "-1" : this._tabindex);
                    }
                };
                /**
                 * Updates the DOM to modify the readonly class.
                 */
                CheckboxComponent.prototype.updateDOMReadonly = function () {
                    if (this.divCb) {
                        this.divCb.toggleClass("readonly", this._internalReadonly ? true : false);
                    }
                };
                /**
                 * Manages the key down event allowing only the space bar to select or unselect a component.
                 *
                 * @param keyCode&#151;The space bar keystroke ASCII code.
                 * @param modelCtrl&#151;The model controller.
                 * @param $scope&#151;The scope.
                 */
                CheckboxComponent.prototype.onKeyDown = function (jqEvent) {
                    if (jqEvent.keyCode === KEY.SPACE_BAR) {
                        this.notifyModel();
                        jqEvent.stopPropagation();
                        jqEvent.preventDefault();
                    }
                };
                /**
                 * Updates the model value.
                 *
                 * @param modelCtrl The model controller.
                 * @param $scope The scope.
                 */
                CheckboxComponent.prototype.notifyModel = function () {
                    if (!this.ngDisabled && !this.ngReadonly) {
                        var ret = this.ngModelController.$modelValue === this._internalTrueValue
                            ? this._internalFalseValue
                            : this._internalTrueValue;
                        this.ngModelController.$setViewValue(ret);
                        this.ngModelController.$render();
                        this.ngModelController.$validate();
                    }
                };
                Object.defineProperty(CheckboxComponent.prototype, "ngRequired", {
                    /**
                     * Getter for the required option.
                     * @returns {boolean} The actual value of required option.
                     */
                    get: function () {
                        return this._ngRequired;
                    },
                    /**
                     * Setter on required option.
                     * @param value The new value of required option.
                     */
                    set: function (value) {
                        this._ngRequired = value;
                        this._internalRequired = value;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(CheckboxComponent.prototype, "ngDisabled", {
                    /**
                     * Getter disabled.
                     * @returns {boolean} Sets whether or not the getter is disabled.
                     */
                    get: function () {
                        return this._ngDisabled;
                    },
                    /**
                     * Setter disabled.
                     * @param value New value.
                     */
                    set: function (value) {
                        this._ngDisabled = value;
                        this._internalDisabled = value;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(CheckboxComponent.prototype, "ngReadonly", {
                    /**
                     * Getter read-only.
                     * @returns {boolean} Sets whether or not the getter is read-only.
                     */
                    get: function () {
                        return this._ngReadonly;
                    },
                    /**
                     * Setter readonly.
                     * @param value Sets whether or not the setting is read-only.
                     */
                    set: function (value) {
                        this._ngReadonly = value;
                        this._internalReadonly = value;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(CheckboxComponent.prototype, "ngTrueValue", {
                    /**
                     * Setter custom value is true.
                     * @returns {Object}
                     */
                    get: function () {
                        return this._ngTrueValue;
                    },
                    /**
                     * Getter custom value is true.
                     * @param value
                     */
                    set: function (value) {
                        this._ngTrueValue = value;
                        this._internalTrueValue = value;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(CheckboxComponent.prototype, "ngFalseValue", {
                    /**
                     * Getter custom false value.
                     * @returns {Object}
                     */
                    get: function () {
                        return this._ngFalseValue;
                    },
                    /**
                     * Setter custom false value.
                     *
                     */
                    set: function (value) {
                        this._ngFalseValue = value;
                        this._internalFalseValue = value;
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * (@inherit) Returns the associated tooltip.
                 */
                CheckboxComponent.prototype.getTooltipDelegate = function (type) {
                    if (type === void 0) { type = ""; }
                    return this.$element;
                };
                // EditComponent override implementation begins
                CheckboxComponent.prototype.validationRules = function () {
                    var _this = this;
                    var requiredRule = DEFAULT_VALIDATION_RULES.REQUIRED();
                    requiredRule.validator = function (modelValue) {
                        return !_this._internalRequired || modelValue === _this._internalTrueValue;
                    };
                    var modelRule = DEFAULT_VALIDATION_RULES.MODEL();
                    modelRule.validator = function (modelValue) {
                        return !angular.isDefined(modelValue) || modelValue === _this._internalTrueValue ||
                            modelValue === _this._internalFalseValue || modelValue === null;
                    };
                    return [requiredRule, modelRule];
                };
                /**
                 * A list of Angular resources injected into the controller.
                 * @type {string[]}
                 */
                CheckboxComponent.$inject = ["$scope", "$element", "$attrs", "$timeout", "validationManager"];
                return CheckboxComponent;
            })(EditComponent);
            checkbox.CheckboxComponent = CheckboxComponent;
        })(checkbox = components.checkbox || (components.checkbox = {}));
    })(components = ers.components || (ers.components = {}));
})(ers || (ers = {}));

// Only declare the Angular module.
angular.module("ers.components.checkbox", ["ers.components.core"]);



///
/// author germonneauf
/// ERS Angular Directive : ers-checkbox.
/// Check Box component.
///
var ers;
(function (ers) {
    var components;
    (function (components) {
        var checkbox;
        (function (checkbox) {
                        /**
             * @ngdoc directive
             * @name ersCheckbox
             * @restrict E
             *
             * @scope
             * @transclude
             * @binding
             * @data
             *
             * @module ers.components.checkbox
             *
             *
             * @description
             *
             * A check box creates a series of user selectable elements, allowing the user to provide feedback or information.
             *
             * - Check boxes can only consist of text, or of a list of labels.
             * - When the user can select more than one item, use a check box, otherwise, use the
             *  [radio button](#/components/ersRadioButton/documentation).
             * - Where the user is being requested to complete an action, use a standard [button](#/components/ersButton/documentation) instead
             *  of a check box.
             *
             *
             * ### Usage
             *
             * - Use check box to enable selecting multiple options or choices related to the same question.
             * - Use check box when the user is required to acknowledge, accept, or agree to a statement.
             *
             * ### Examples
             *
             * #### Standard check boxes.
             *
             * A set of basic check boxes.
             *
             * <code-editor identifier="example1" data-title="Basic Checkbox"
             * html-content-url="demos/ersCheckbox/basicUsage/index.html"
             * js-content-url="demos/ersCheckbox/basicUsage/script.js" css-content-url="demos/ersCheckbox/basicUsage/styles.css"
             * content-mode="html"></code-editor>
             *
             * #### Dynamic Check Boxes List
             *
             * Check box with `ng-repeat` for a more dynamic configuration.
             *
             * <code-editor identifier="example2" data-title="Dynamic Repeat"
             * html-content-url="demos/ersCheckbox/dynamicRepeat/index.html"
             * js-content-url="demos/ersCheckbox/dynamicRepeat/script.js"
             * css-content-url="demos/ersCheckbox/dynamicRepeat/styles.css" content-mode="html"></code-editor>
             *
             * ### Design Guidelines
             *
             * - The check box uses FontAwesome icons. All checkboxes are infinitely scalable and stylable with a standard CSS.
             *
             * ### Accessibility Guidelines
             *
             * No accessibility guidelines.
             *
             * @param {expression} ng-model {=}
             *
             * Sets the Angular expression to which the data is bound when it changes. The default selection value is false.
             * When the no value is assigned, the checkbox model must be valid. Assigned values are attached to
             * a $scope. Within the scope, the default values for true and false must be defined.
             *
             *  ```
             *  function DemoCtrl($scope) {
             *  $scope.cb1 = true;
             *  $scope.cb2 = false;
             *  }
             *
             *  DemoCtrl.$inject = ['$scope'];
             *  ```
             *
             * @param {boolean} [ng-required=false] {=?}
             *
             * Specifies whether the check box is required or not.
             *
             * @param {boolean} [ng-readonly=false] {=?}
             *
             * Specifies the check box state as read only or not.
             *
             * @param {boolean} [ng-disabled=false] {=?}
             *
             * Specifies whether or not the check box is disabled. When disabled, the check box is not selectable and appears in the disabled style.
             *
             * @param {string} [ng-true-value] {=?}
             *
             * Specifies the attribute to be used when the check box is selected.
             *
             * @param {string} [ng-false-value] {=?}
             *
             * Specifies the attribute to be used when the checkbox is not selected.
             *
             *  ```xml
             *  <ers-checkbox ng-model="license" ng-true-value="accepted" ng-false-value="declined">
             *    I accept the terms of the license agreement.
             *  </ers-checkbox>
             *  ```
             */
            var checkboxDirective = function () {
                return {
                    restrict: "E",
                    templateUrl: "checkbox/template/checkbox-template.html",
                    require: ["?ngModel", "ersCheckbox"],
                    transclude: true,
                    bindToController: true,
                    scope: {
                        ngDisabled: "=?", ngRequired: "=?", ngReadonly: "=?", ngTrueValue: "=?", ngFalseValue: "=?"
                    },
                    controller: checkbox.CheckboxComponent,
                    controllerAs: "checkboxController",
                    link: function ($scope, $element, $attributes, cbbCtrls) {
                        // Check controllers
                        var modelCtrl = cbbCtrls[0];
                        var cbCtrl = cbbCtrls[1];
                        if (!cbCtrl || !modelCtrl) {
                            return;
                        }
                        // Set model controller
                        cbCtrl.setNgModelController(modelCtrl);
                    }
                };
            };
            angular.module("ers.components.checkbox").directive("ersCheckbox", checkboxDirective);
        })(checkbox = components.checkbox || (components.checkbox = {}));
    })(components = ers.components || (ers.components = {}));
})(ers || (ers = {}));/**
 * Created by zhangfa on 6/8/2015.
 */
/**
 * Created by zhangfa on 6/8/2015.
 */
/**
 * Created by ZhangFa on 6/13/2015.
 */
/**
 * Created by zhangfa on 6/10/2015.
 */
/**
 * Created by zhangfa on 6/8/2015.
 */
/**
 * The Context Menu Component Module
 *
 * Created by zhangfa on 6/8/2015.
 */






var ers;
(function (ers) {
    var components;
    (function (components) {
        var contextmenu;
        (function (contextmenu) {
            contextmenu._module = angular.module("ers.components.contextmenu", ["ngSanitize", "ers.components.icon"]);
        })(contextmenu = components.contextmenu || (components.contextmenu = {}));
    })(components = ers.components || (ers.components = {}));
})(ers || (ers = {}));
// Created by germonneauf on 06/03/2015.
var ers;
(function (ers) {
    var components;
    (function (components) {
        var combobox;
        (function (combobox) {
            var ComboboxItemProperties = (function () {
                function ComboboxItemProperties() {
                }
                return ComboboxItemProperties;
            })();
            combobox.ComboboxItemProperties = ComboboxItemProperties;
        })(combobox = components.combobox || (components.combobox = {}));
    })(components = ers.components || (ers.components = {}));
})(ers || (ers = {}));
var ers;
(function (ers) {
    var components;
    (function (components) {
        var combobox;
        (function (combobox) {
                    })(combobox = components.combobox || (components.combobox = {}));
    })(components = ers.components || (ers.components = {}));
})(ers || (ers = {}));



var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
// Created by germonneauf on 27/02/2015.
var ers;
(function (ers) {
    var components;
    (function (components) {
        var combobox;
        (function (combobox) {
                        var KEY = ers.components.utility.KEY;
            var BaseController = ers.components.core.BaseController;
            /**
             * Combobox Item Directive
             * The main class for combobox item component directive.
             */
            var ComboboxItemController = (function (_super) {
                __extends(ComboboxItemController, _super);
                /**
                 * Constructor
                 *
                 * @param $scope
                 */
                function ComboboxItemController($scope, $element, $attributes) {
                    var _this = this;
                    _super.call(this, $scope, $element, $attributes);
                    this.internalDisabled = false;
                    // Initialize properties
                    this.separator = $scope.separator || false;
                    this.value = $scope.value;
                    if (angular.isDefined(this.ngDisabled)) {
                        this.internalDisabled = this.ngDisabled;
                    }
                    // On Destroy (remove callback)
                    this.$scope.$on("destroy", function () {
                        _this.$element.off(); // Remove all events handlers
                    });
                }
                /**
                 * Link functions.
                 *
                 * @param scope combobox Item scope
                 * @param element combobox Item root element
                 * @param attributes combobox Item attributes
                 */
                ComboboxItemController.prototype.link = function (scope, element, attributes) {
                    // Set the observers.
                    this.setObservers();
                    // Set watchers
                    this.setWatchers();
                    // Some update on the DOM element
                    this.setCallback();
                };
                /**
                 * Sets the list of attribute observers, watching for enabled and disabled attributes.
                 */
                ComboboxItemController.prototype.setObservers = function () {
                    var _this = this;
                    // Observe enable/disabled attribute
                    this.$attrs.$observe("disabled", function (interpolatedValue) {
                        _this.ngDisabled = interpolatedValue;
                        if (_this.internalDisabled) {
                            _this.$element.find("a").addClass("disabled");
                        }
                        else {
                            _this.$element.find("a").removeClass("disabled");
                        }
                    });
                };
                /**
                 * Sets the list of watchers for the combobox item properties.
                 */
                ComboboxItemController.prototype.setWatchers = function () {
                    var _this = this;
                    // Set appropriate class for separator
                    this.$scope.$watch(function () {
                        return _this.separator;
                    }, function () {
                        if (_this.separator) {
                            _this.$element.find("li").addClass("divider");
                        }
                        else {
                            _this.$element.find("li").removeClass("divider");
                        }
                    });
                };
                /**
                 * Sets the event responder to an item combobox action.
                 * Two events are available, mouse click and keyboard (the enter key).
                 *
                 */
                ComboboxItemController.prototype.setCallback = function () {
                    var _this = this;
                    // On Mouse click
                    this.$element.on("mousedown", function (event) {
                        // Set callbacks only if item is enable
                        if (!_this.ngDisabled && !_this.separator) {
                            return _this.delegate.onClick(event, _this);
                        }
                        return true;
                    });
                    // On key strike (only with ENTER)
                    this.$element.keydown(function (event) {
                        // Set callbacks only if item is enable
                        if (!_this.ngDisabled && !_this.separator && event.keyCode === KEY.ENTER) {
                            return _this.delegate.onKey(event, _this);
                        }
                        return true;
                    });
                };
                /**
                 * Sets the item view when highlighted or on a mouseover.
                 */
                ComboboxItemController.prototype.setSelected = function () {
                    this.$element.find("li a").addClass("key-hover");
                };
                /**
                 * Sets the item view when not highlighted, or the mouseover is removed.
                 *
                 */
                ComboboxItemController.prototype.setUnselected = function () {
                    this.$element.find("li a").removeClass("key-hover");
                };
                /**
                 * The item combobox UI display.
                 *
                 * @returns {ng.IAugmentedJQuery} The DOM representation of the item.
                 */
                ComboboxItemController.prototype.description = function () {
                    return this.$element.find("a").children();
                };
                Object.defineProperty(ComboboxItemController.prototype, "value", {
                    /**
                     * Gets the embedded value of the item combobox.
                     *
                     * @returns {Object} Returns the value of the item combobox.
                     */
                    get: function () {
                        return this._value;
                    },
                    /**
                     * Set the embedded value of the item combobox.
                     *
                     * @param value Sets the value of the item combobox.
                     */
                    set: function (value) {
                        this._value = value;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ComboboxItemController.prototype, "separator", {
                    get: function () {
                        return this._separator;
                    },
                    /**
                     * Getter and setters properties.
                     */
                    set: function (sep) {
                        this._separator = sep;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ComboboxItemController.prototype, "ngDisabled", {
                    get: function () {
                        return this._ngDisabled;
                    },
                    set: function (disabled) {
                        this._ngDisabled = disabled;
                        this.internalDisabled = disabled;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ComboboxItemController.prototype, "delegate", {
                    /**
                     * Returns the delegate managing mouse and keyboard events.
                     *
                     * @returns {ComboboxComponent} The delegate object returning mouse and keyboard events.
                     */
                    get: function () {
                        return this._delegate;
                    },
                    /**
                     * Sets the delegate managing mouse and keyboard events.
                     *
                     * @param ctrl The delegate object setting mouse and keyboard events.
                     */
                    set: function (ctrl) {
                        this._delegate = ctrl;
                    },
                    enumerable: true,
                    configurable: true
                });
                ComboboxItemController.$inject = ["$scope", "$element", "$attrs"];
                return ComboboxItemController;
            })(BaseController);
            combobox.ComboboxItemController = ComboboxItemController;
        })(combobox = components.combobox || (components.combobox = {}));
    })(components = ers.components || (ers.components = {}));
})(ers || (ers = {}));// Created by germonneauf on 06/03/2015.

/**
 * Created by zhangfa on 3/15/2015.
 */
/**
 * Created by ZhangFa on 3/17/2015.
 */
/**
 * Created by zhangfa on 3/16/2015.
 */
/**
 * Created by zhangfa on 3/19/2015.
 */
/**
 * Created by zhangfa on 3/16/2015.
 */
/*
 * Created by zhangfa on 3/11/2015.
 */

var ers;
(function (ers) {
    var components;
    (function (components) {
        var popover;
        (function (popover) {
            /**
             * @private
             *
             * @param s
             * @param prefix
             * @returns {string}
             */
            function removePrefix(s, prefix) {
                if (!_.startsWith(s, prefix)) {
                    return s;
                }
                return s.substring(prefix.length);
            }
            /**
             * Internally used only for both the popover and tooltip components. See [[TooltipService]], [[PopoverService]]
             *
             * @Singleton
             * @type {{
             *      bindAttrToScope: (function(ng.IAttributes, ng.IScope, string[], string=, function(string): string=): undefined),
             *      parseOptions: (function(ng.IAttributes, string=): IPopOptions), docHeight: (function(): number)
             *  }}
             */
            popover.popoverUtils = {
                /**
                 * Bind the node HTML attribute to the corresponding scope variables.
                 *
                 * @param attr Directive attributes.
                 * @param scope Scope object to bind.
                 * @param keys Scope variable names to bind.
                 * @param prefix Prefix for binding directive attribute names.
                 * @param filter A filter that binds the transformed attribute values to scope.
                 *
                 *
                 */
                bindAttrToScope: function (attr, scope, keys, prefix, filter) {
                    if (!attr) {
                        return;
                    }
                    var bindToScope = function (key) {
                        var akey = _.camelCase(prefix + key);
                        if (attr[akey]) {
                            scope[key] = filter(attr[akey]);
                        }
                        if (attr["$$observers"] && attr["$$observers"][akey]) {
                            attr.$observe(akey, function (newValue) {
                                scope[key] = filter(newValue);
                            });
                        }
                    };
                    angular.forEach(keys, bindToScope);
                },
                /**
                 * Parse the HTML attribute values into popup options.
                 *
                 * @param attr Directive attribute.
                 * @param prefix Prefix of attribute names.
                 * @returns {IPopOptions} Configuration of the pop instance.
                 *
                 */
                parseOptions: function (attr, prefix) {
                    var options = {};
                    if (!attr || !attr.$attr) {
                        return options;
                    }
                    angular.forEach(attr.$attr, function (value, key) {
                        if (prefix && !_.startsWith(value, prefix)) {
                            return;
                        }
                        var okey = _.camelCase(removePrefix(value, prefix));
                        options[okey] = attr[key];
                    });
                    return options;
                }
            };
        })(popover = components.popover || (components.popover = {}));
    })(components = ers.components || (ers.components = {}));
})(ers || (ers = {}));/**
 * Created by zhangfa on 3/18/2015.
 */








var ers;
(function (ers) {
    var components;
    (function (components) {
        var popover;
        (function (popover) {
            popover._module = angular.module("ers.components.popover", ["ers.components.core"]);
        })(popover = components.popover || (components.popover = {}));
    })(components = ers.components || (ers.components = {}));
})(ers || (ers = {}));/**
 * Created by zhangfa on 3/15/2015.
 */
/*
 * Created by zhangfa on 3/16/2015.
 */
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};


var ers;
(function (ers) {
    var components;
    (function (components) {
        var popover;
        (function (popover_1) {
                        var BaseController = ers.components.core.BaseController;
            /**
             * @ngdoc directive
             * @module ers.components.popover
             * @name ersPopover
             *
             * @restrict E
             *
             * @description
             *
             * You can use the `ers-popover` directive to create a popover on any visible element
             *
             * ### Usage
             *
             * Following attributes are available with the directive:
             *
             * - `po-trigger` (attribute) Optional. Trigger way of tooltip. Available options: 'click', 'focus', 'hover',
             * default is 'hover'
             * - `po-placement` (attribute) Optional. Position of tooltip relative to anchor. Available options: 'left', 'right',
             * 'top', 'bottom', default is 'left'
             * - `po-title` (expression) Optional. Displayed title of the popover.
             * - `po-content` (expression) Optional. Displayed content of the popover.
             * - `po-show-delay` (attribute) Optional. Default 0. Delay in ms to show up the popover when triggered.
             * - `po-hide-delay` (attribute) Optional. Default 0. Duration in ms of showing the popover when untriggered.
             * - `po-target` (attribute) Optional. CSS selector of an existing DOM node to pop.
             * - `po-template` (attribute) Optional. Template of popover. Could be an url of html file or an html string
             *
             * ### Examples
             *
             * <code-editor identifier="example1" data-title="Popover" html-content-url="demos/ersPopover/basicUsage/index.html"
             * js-content-url="demos/ersPopover/basicUsage/script.js" css-content-url="demos/ersPopover/basicUsage/styles.css"
             * content-mode="html"></code-editor>
             *
             * ### Design Guidelines
             * - Keep it simple.
             * - Keep it small, never cover more than a third of the parent.
             * - Should only appear in response to a user action.
             *
             * @param {string} [po-title] Sets the title into the scope of the popover instance. Supports HTML
             * when `po-html="true"`.
             *
             * @param {string} [po-id] Sets the ID attribute which will be used for the generated DOM popover in order to have the
             * possibility to find it over the document.
             *
             * @param {string} [po-content] Sets the content into the scope of the popover instance.
             * When `html="true"`, renders an HTML string.
             *
             *
             *
             * @param {string} [po-trigger] Sets how the popover is triggered. Available values are click, focus, or hover.
             *
             * ```xml
             *     <button ers-popover
             *             po-trigger="hover">
             *          A button
             *     </button>
             * ```
             *
             * @param {string} [po-clear-exists] Sets whether or not more than one popover instance can be displayed at a time.
             *  ```xml
             *     <button class="btn btn-default"
             *             ers-popover
             *             po-clear-exists="false">
             *             ...
             *     </button>
             * ```
             *
             *
             *
             * @param {string} [po-placement] Sets the position of popover relative to its anchor; left, right, top or bottom.
             *
             * ```xml
             *     <button ers-popover
             *             po-placement="top">
             *          A button
             *     </button>
             * ```
             *
             * @param {string} [po-target] Sets the CSS selector of an existing DOM node to the popover.
             *
             * ```xml
             * <button class="btn btn-default"
             *         ers-popover
             *         po-target="#popover1">
             * </button>
             *
             * <div id="popover1" class="popover">
             *   <h3 class="popover-title">#popover1 from after the button</h3>
             *
             *   <div class="popover-content">
             *     <p>This is a <b>HTML</b> text</p>
             *   </div>
             * </div>
             * ```
             *
             * @param {string} [po-template] Sets the popover template. The template can be the url of an HTML file or an
             * HTML string.
             *
             * ##### Example - URL
             *
             * ```xml
             *     <button class="btn btn-default"
             *             ers-popover
             *             po-template="components/popover/dynamicTemplate.html">
             *             Popover by url
             *     </button>
             * ```
             *
             * ##### Example - String
             *
             * ```xml
             *     <button class="btn btn-default"
             *             ers-popover
             *             po-content="<div class='popover'><h3 class='popover-title'>title</h3><div class='popover-content'>
             *             content Popover by HTML string</div></div>">
             *     </button>
             * ```
             *
             * @param {boolean} [po-html="false"] Enables the tooltip title to render an HTML string.
             *
             * ```xml
             *     <button class="btn btn-default"
             *             ers-popover
             *             po-title="Bonjour"
             *             po-content="<b>le monde</b>"
             *             html="true">
             *             A button
             *     </button>
             * ```
             *
             *
             *
             *
             *
             * @param {number} [po-show-delay] When the popover is triggered, sets the delay in milliseconds before the popover
             * displays. The default values are 500 milliseconds for Tooltip and '0' for the Popover.
             *
             * ```xml
             *     <button class="btn btn-default"
             *             ers-popover
             *             po-show-delay="1000">
             *             ...
             *     </button>
             * ```
             *
             * @param {number} [po-hide-delay] Sets the popover display duration in milliseconds.
             *
             * ```xml
             *     <button class="btn btn-default"
             *             ers-popover
             *             po-hide-delay="2000">
             *             ...
             *     </button>
             * ```
             *
             *
             * @param {string} [po-container="body"] Sets the container node to which the popover instance is appended on opening.
             * If not specified, the popover instance node is appended to HTML body. The default is body.
             *
             * ```xml
             *     <button class="btn btn-default"
             *             ers-popover
             *             po-container="#container">
             *             A button
             *     </button>
             *     <div id="container"/>
             * ```
             *
             * @param {boolean} [po-show-arrow="false"] Specifies if an arrow is displayed with a popover instance. This is
             * only effective when no template or target is specified.
             *
             * ```xml
             *     <button class="btn btn-default"
             *             ers-popover
             *             po-show-arrow="false">
             *             ...
             *     </button>
             * ```
             *
             *
             *
             * @param {boolean} [po-lazy-load="true"] Sets whether or not a popover instance is initialized immediately
             * when a page is loaded, or if initialization is delayed until the popover is called.
             *
             *  * ```xml
             *     <button class="btn btn-default"
             *             ers-popover
             *             po-lazy-load="false">
             *             ...
             *     </button>
             * ```
             *
             *
             */
            function PopoverDirectiveFactory(popoverService) {
                return {
                    restrict: "EA",
                    controller: PopoverController,
                    bindToController: true,
                    link: function (scope, element, attr) {
                        var config = {};
                        var defaultConfig = {};
                        // Create a new isolated scope with $parent as global scope (to access parent scope properties in case of custom template popover)
                        // => Avoid global scope to share all its properties between the different instance of popover
                        config.$scope = scope.$new(true, scope);
                        // Extract the "id" attribute, if exists, from the element on which is plugged the popover and prefix this ID
                        // with the "po-" value in order to be used as the ID of the popover in the case when the user did not specified one.
                        defaultConfig.id = attr["id"] ? "po-" + attr["id"] : undefined; // May be overridden if a po-id is found later.
                        var popover = popoverService.createPopover(element, attr, config, defaultConfig);
                        scope.$on("$destroy", function () {
                            popover.destroy();
                        });
                        // Register the instance into the controller
                        var controller = element.controller("ersPopover");
                        controller.popover = popover;
                    }
                };
            }
            popover_1.PopoverDirectiveFactory = PopoverDirectiveFactory;
            PopoverDirectiveFactory.$inject = ["popoverService"];
            popover_1._module.directive("ersPopover", PopoverDirectiveFactory);
            /**
             * TreeComponent class
             * @class
             *
             * ### Description
             *
             * The controller linked to the ers-tree directive.
             *
             */
            var PopoverController = (function (_super) {
                __extends(PopoverController, _super);
                /**
                 * Constructor
                 * @param $scope Controller scope.
                 * @param $element Root directive element.
                 */
                function PopoverController($scope, $element) {
                    _super.call(this, $scope, $element);
                }
                Object.defineProperty(PopoverController.prototype, "popover", {
                    /**
                     * Popover instance getter.
                     * @returns {IPopInstance} The popover instance.
                     */
                    get: function () {
                        return this._popover;
                    },
                    /**
                     * Popover instance setter.
                     * @param popover Popover instance.
                     */
                    set: function (popover) {
                        this._popover = popover;
                    },
                    enumerable: true,
                    configurable: true
                });
                PopoverController.$inject = ["$scope", "$element"];
                return PopoverController;
            })(BaseController);
            popover_1.PopoverController = PopoverController;
        })(popover = components.popover || (components.popover = {}));
    })(components = ers.components || (ers.components = {}));
})(ers || (ers = {}));










var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var ers;
(function (ers) {
    var components;
    (function (components) {
        var combobox;
        (function (combobox) {
            var KEY = ers.components.utility.KEY;
            var DEFAULT_VALIDATION_RULES = ers.components.utility.DEFAULT_VALIDATION_RULES;
            var EditComponent = ers.components.core.EditComponent;
            /**
             * Combobox directive
             * The main class for the combobox component directive.
             */
            var ComboboxComponent = (function (_super) {
                __extends(ComboboxComponent, _super);
                /**
                 * @constructor
                 */
                function ComboboxComponent($scope, $element, $attrs, $timeout, vm) {
                    _super.call(this, $scope, $element, $attrs, $timeout, vm);
                    /** Sets the field to flag to bind, or not to trigger. */
                    this.flagToSetTrigger = false;
                    /** The option to set or unset an arrow on the popover. */
                    this.withArrow = false;
                    /** Technical flag that determines if the combobox item is clicked or not. This is important to manage focus
                     * or blur. */
                    this.clickFlag = false;
                    /**
                     * A JQuery element helper that iterates through a collection of JQuery elements until the user selects one.
                     *
                     * @param collection A list a IAugmented JQuery
                     * @returns iterator Object
                     */
                    this.iterator = function (collection) {
                        var index = 0;
                        return {
                            get: function () {
                                // The get() returns the current element in the iteration. Be careful at the current 'index' which should be recomputed
                                // in case of the last element is reached (cf. next() and end()).
                                var ind = (index >= collection.length) ? index - 1 : index;
                                return angular.element(collection[ind]);
                            }, next: function () {
                                index = (index < collection.length) ? (++index) : collection.length;
                                // The next() returns the next element in the current iteration until it reaches the last element. When the last element
                                // is reached, next() returns always the last element, but in this case the stored 'index' is the length of the
                                // collection not the index of the last element ( => to preserve the end() mechanism).
                                return angular.element(collection[(index === collection.length) ? index - 1 : index]);
                            }, prev: function () {
                                index = (index <= 0) ? 0 : (--index);
                                // The prev() returns the previous element in current iteration until it reaches the first element of the
                                // collection. When the first element is reached prev() return always the first element.
                                return angular.element(collection[index]);
                            }, end: function () {
                                // Be careful this condition is deeply link with the index computed in next() and returns true if
                                // the end of the collection is reached else it returns false.
                                return index >= collection.length;
                            }, begin: function () {
                                // Rest the iterator to the beginning of the collection.
                                index = 0;
                                return angular.element(collection[index]);
                            }
                        };
                    };
                    this.generatePopoverIds();
                }
                /**
                 * Generates the IDs required to reference the combobox list items, popover, po-target, and po-container.
                 */
                ComboboxComponent.prototype.generatePopoverIds = function () {
                    var comboboxList = this.$element.find(".ers-combobox-list");
                    comboboxList.uniqueId();
                    this.targetId = comboboxList.attr("id");
                    this.targetElement = comboboxList;
                    this.cbbContainerId = this.cbbContainerId || "#";
                };
                /**
                 * Finishes initializing the combobox object when the DOM completes loading.
                 */
                ComboboxComponent.prototype.setPopover = function () {
                    var poController = angular.element(this.buttonElement).controller("ersPopover");
                    if (poController) {
                        this.mPopover = poController.popover;
                        this.setButtonClick(true);
                        // Close at startup
                        this.arrowRender(false);
                    }
                };
                /**
                 * Trigger to open/close popover combobox.
                 * @param on
                 */
                ComboboxComponent.prototype.setButtonClick = function (on) {
                    var _this = this;
                    if (this.buttonElement) {
                        if (on) {
                            this.buttonElement.on("click", function () {
                                _this.opened = !_this.opened;
                                _this.openClosePopup();
                            });
                        }
                        else {
                            this.buttonElement.off("click");
                        }
                    }
                };
                /**
                 * Returns the appropriate popover container element.
                 * @returns {any} The appropriate popover container element
                 */
                ComboboxComponent.prototype.poContainer = function () {
                    if (this.cbbContainerId == null || this.cbbContainerId === "#") {
                        return this.$element;
                    }
                    else {
                        return angular.element(this.cbbContainerId);
                    }
                };
                /**
                 * Items allowed to manipulate the DOM and set watchers.
                 *
                 * @param $scope The directive scope
                 * @param $element The DOM element (directive start)
                 * @param $attributes The DOM attributes
                 */
                ComboboxComponent.prototype.link = function ($scope, $element, $attributes) {
                    var _this = this;
                    _super.prototype.link.call(this, $scope, $element, $attributes);
                    // Add ers class
                    this.$element.addClass("ers-combobox");
                    this.buttonElement = this.$element.find("button");
                    // Add listeners
                    this.addListeners($element);
                    // Popover
                    this.setPopover();
                    // update form
                    this.updateDisabled();
                    this.updateReadOnly();
                    // set default value once DOM is completely loaded.
                    this.$timeout(function () {
                        // Update combobox and force check model
                        _this.notifyCombobox(_this.retrieveComboboxItemController(_this.ngModelController.$modelValue), false);
                        _this.ngModelController.$validate();
                    }, 0);
                };
                /**
                 * Adds the component event listeners.
                 * @param $element Root element.
                 */
                ComboboxComponent.prototype.addListeners = function ($element) {
                    var _this = this;
                    // Key pressed
                    $element.find(".dropdown-select").keydown(function (event) {
                        _this.onKeyDown(event);
                    });
                    // Focus out
                    this.buttonElement.on("blur", function (event) {
                        _this.onBlur(event);
                    });
                    // Scroll
                    this.onScroll();
                };
                /**
                 * Open/close popup (list combobox items.
                 */
                ComboboxComponent.prototype.openClosePopup = function () {
                    if (this.opened) {
                        // resize the popup because the component size may have changed!
                        this.targetElement.css("width", this.$element.innerWidth());
                        this.arrowRender(true);
                    }
                    else {
                        this.mPopover.hide();
                        this.arrowRender(false);
                    }
                };
                /**
                 * Manages the combobox behavior while scrolling.
                 */
                ComboboxComponent.prototype.onScroll = function () {
                    var _this = this;
                    var inside = false;
                    this.targetElement.hover(function () {
                        inside = true;
                    }, function () {
                        inside = false;
                    });
                    // Listen mouse wheel to prevent mouse scrolling
                    document.addEventListener("mousewheel", function () {
                        if (!inside && _this.mPopover != null && _this.opened === true) {
                            _this.opened = false;
                            _this.openClosePopup();
                        }
                    }, false);
                    // Listen pageUp, pageDown
                    document.addEventListener("keydown", function () {
                        if (!inside && _this.mPopover != null && _this.opened === true) {
                            _this.opened = false;
                            _this.openClosePopup();
                        }
                    }, false);
                };
                /**
                 * Closes the combobox popover when it loses focus.
                 * @param event A JQuery event
                 */
                ComboboxComponent.prototype.onBlur = function (event) {
                    var _this = this;
                    this.opened = false;
                    this.openClosePopup();
                    if (this.clickFlag) {
                        // Blur comes from click item selection, so don't act as blur but keep focus on button
                        // Important: we are using un timeout here due to a legacy bug on firefox:
                        // https://bugzilla.mozilla.org/show_bug.cgi?id=53579
                        this.$timeout(function () { _this.buttonElement[0].focus(); }, 0);
                        // And stop propagation to avoid blur bubble (because there isn't blur, button keep focus)
                        event.stopImmediatePropagation();
                    }
                    this.clickFlag = false;
                };
                /**
                 * Sets the model controller.
                 * @param value The model controller.
                 */
                ComboboxComponent.prototype.setNgModelController = function (value) {
                    var _this = this;
                    _super.prototype.setNgModelController.call(this, value);
                    // Set the model rendering
                    this.ngModelController.$render = function () {
                        // Notify display when model change
                        _this.notifyCombobox(_this.retrieveComboboxItemController(_this.ngModelController.$modelValue), false);
                    };
                };
                /**
                 * Allows the the interface to respond to 'click' combobox events.
                 * @param evt A JQuery event.
                 * @param itemController The combobox controller linked to the event.
                 * @returns {boolean} The return event.
                 */
                ComboboxComponent.prototype.onClick = function (evt, itemController) {
                    this.notifyCombobox(itemController);
                    void 0;
                    this.clickFlag = true;
                    return true;
                };
                /**
                 * Allows the interface to respond to 'enter key' combobox events.
                 *
                 * @param evt A JQuery event.
                 * @param itemController The item combobox controller linked to the event.
                 * @returns {boolean} The return event.
                 */
                ComboboxComponent.prototype.onKey = function (evt, itemController) {
                    this.notifyCombobox(itemController);
                    return true;
                };
                /**
                 * Manages the key down event. Only up and down keyboard events are managed for the combobox
                 * This function selects the previous or the next item in the popover item list
                 *
                 * @param event The JQuery event
                 */
                ComboboxComponent.prototype.onKeyDown = function (event) {
                    // Check combobox state
                    if (this.ngReadonly || this.ngDisabled) {
                        return;
                    }
                    // Compute item to select/unselect
                    var direction = 0;
                    switch (event.keyCode) {
                        case KEY.LEFT_ARROW:
                        case KEY.UP_ARROW:
                            direction = 1;
                            break;
                        case KEY.RIGHT_ARROW:
                        case KEY.DOWN_ARROW:
                            direction = 2;
                            break;
                        case KEY.ESCAPE:
                            // Keep focus after closing popover.
                            this.$element.find("button")[0].focus();
                            break;
                        default:
                            break;
                    }
                    // Apply change
                    if (direction > 0) {
                        // To avoid scrolling page
                        event.stopImmediatePropagation();
                        event.preventDefault();
                        // Notify model, do not change popover state (open or close)
                        this.notifyCombobox(this.retrieveComboboxItemController(this.ngModelController.$modelValue, direction), false);
                    }
                };
                /**
                 * The function that returns the appropriate ComboboxItemController based on a given direction.
                 * Where the direction is provided,
                 * the retrieved controller is the first controller that matches the current modelValue
                 * before or after the current controller. If no direction is provided, the retrieved controller is the first
                 * controller matching the current modelValue.
                 *
                 * @param value The value to match in the items list.
                 * @param direction Up(1), Down(2), or None(0)
                 * @returns {ComboboxItemController} The controller associated to the element.
                 */
                ComboboxComponent.prototype.retrieveComboboxItemController = function (value, direction) {
                    var itemsCombobox = this.targetElement.find("li:not(.divider) a:not(.disabled)"); //aez
                    var it = this.iterator(itemsCombobox);
                    // Searching current controller item combobox controller
                    var itemController = null;
                    for (it; !it.end(); it.next()) {
                        itemController = it.get().controller("ersComboboxItem");
                        if (itemController != null && itemController.value === value) {
                            break;
                        }
                        itemController = null; // no controller match value set it to null
                    }
                    // Case where a direction is wanted
                    if (direction != null && direction > 0) {
                        (direction === 1) ? it.prev() : it.next();
                        var item = it.get();
                        itemController.setUnselected();
                        itemController = item.controller("ersComboboxItem");
                        itemController.setSelected();
                    }
                    return itemController;
                };
                /**
                 * The function that manages and displays the model behavior.
                 *
                 * @param itemController The controller associated to the current item (the item selected)
                 * @param closePopup A display option to close, or not, the popover after display.
                 */
                ComboboxComponent.prototype.notifyCombobox = function (itemController, closePopup) {
                    if (closePopup === void 0) { closePopup = true; }
                    if (itemController != null) {
                        // Set and display model
                        this.ngModelController.$setViewValue(itemController.value);
                        this.renderModel(itemController.description());
                        if (closePopup) {
                            // Ask popover to close and keep focus on button
                            this.opened = false;
                            this.openClosePopup();
                            this.buttonElement[0].focus();
                        }
                    }
                    else {
                        // In this case, we are not able to display any information, so empty string is displaying as current item
                        // and an unexpected error should be raised by the validator
                        this.renderModel(angular.element(""));
                    }
                };
                /**
                 * Display the selected item in the combobox.
                 */
                ComboboxComponent.prototype.renderModel = function (element) {
                    // get the place to set the selected option
                    var contentAnchor = this.$element.find("span.button-text");
                    if (angular.isDefined(contentAnchor) && angular.isDefined(element)) {
                        // Remove old content
                        contentAnchor.children().remove();
                        // Add the new content (selected by the user)
                        contentAnchor.append(element.clone());
                    }
                };
                /**
                 * Checks to see that the correct values are displayed in the combobox list. Controllers must be defined for
                 * all values displayed in the list.
                 *
                 *
                 * @param itemValue The value to check.
                 * @returns {boolean} True if the value belongs on the list, false if it does not.
                 */
                ComboboxComponent.prototype.isValueItemValid = function (itemValue) {
                    // check the controller associated to the corresponding item.
                    return (this.retrieveComboboxItemController(itemValue) !== null);
                };
                /**
                 * Change button arrow depending on the popup state (opened/closed).
                 * @param close
                 */
                ComboboxComponent.prototype.arrowRender = function (close) {
                    var buttonArrow = this.poContainer().find("span .fa-stack .fa");
                    buttonArrow.toggleClass("fa-angle-up", close);
                    buttonArrow.toggleClass("fa-angle-down", !close);
                };
                /*
                 * Set the appropriate class when readonly attribute change
                 */
                ComboboxComponent.prototype.updateReadOnly = function () {
                    this._ngReadonly = angular.isDefined(this._ngReadonly) ? this._ngReadonly : false;
                    if (this.buttonElement) {
                        this.buttonElement.toggleClass("readonly", this._ngReadonly);
                    }
                    // Depending on the value of readonly properties, switch on/off the popover's trigger click
                    if (this._ngReadonly) {
                        this.setButtonClick(false);
                        this.flagToSetTrigger = true;
                    }
                    else {
                        if (this.flagToSetTrigger) {
                            this.setButtonClick(true);
                        }
                    }
                };
                /*
                 * Set appropriate class when disabled attribute change.
                 */
                ComboboxComponent.prototype.updateDisabled = function () {
                    this._ngDisabled = angular.isDefined(this._ngDisabled) ? this._ngDisabled : false;
                    if (this.buttonElement) {
                        this.buttonElement.toggleClass("disabled", this._ngDisabled);
                    }
                };
                Object.defineProperty(ComboboxComponent.prototype, "ngDisabled", {
                    /**
                     * Combobox options for getters and setters.
                     */
                    get: function () {
                        return this._ngDisabled;
                    },
                    set: function (disabled) {
                        this._ngDisabled = disabled;
                        this.updateDisabled();
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ComboboxComponent.prototype, "ngRequired", {
                    get: function () {
                        return this._ngRequired;
                    },
                    set: function (required) {
                        this._ngRequired = required;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ComboboxComponent.prototype, "ngReadonly", {
                    get: function () {
                        return this._ngReadonly;
                    },
                    set: function (readonly) {
                        this._ngReadonly = readonly;
                        this.updateReadOnly();
                    },
                    enumerable: true,
                    configurable: true
                });
                // EditComponent override implementation begins
                /**
                 * (@inheritDoc)
                 */
                ComboboxComponent.prototype.inputElement = function () {
                    return angular.element(this.buttonElement);
                };
                /**
                 * (@inheritDoc)
                 */
                ComboboxComponent.prototype.getTooltipDelegate = function (type) {
                    if (type === void 0) { type = ""; }
                    switch (type) {
                        case "focus":
                            return this.inputElement();
                        default:
                            return this.$element;
                    }
                };
                ComboboxComponent.prototype.validationRules = function () {
                    var _this = this;
                    var modelRule = DEFAULT_VALIDATION_RULES.MODEL();
                    modelRule.validator = function (modelValue, viewValue) {
                        return !angular.isDefined(modelValue) || modelValue === null ||
                            (angular.isDefined(modelValue) && _this.isValueItemValid(modelValue));
                    };
                    var requiredRule = DEFAULT_VALIDATION_RULES.REQUIRED();
                    requiredRule.validator = function (modelValue) {
                        return !_this.ngRequired || (_this.ngRequired && modelValue !== null);
                    };
                    return [requiredRule, modelRule];
                };
                /** External elements allowed to inject into the combobox. */
                ComboboxComponent.$inject = ["$scope", "$element", "$attrs", "$timeout", "validationManager"];
                return ComboboxComponent;
            })(EditComponent);
            combobox.ComboboxComponent = ComboboxComponent;
        })(combobox = components.combobox || (components.combobox = {}));
    })(components = ers.components || (ers.components = {}));
})(ers || (ers = {}));

// only declare angular module
angular.module("ers.components.combobox", ["ers.components.core", "ers.components.popover"]);





// Created by germonneauf on 25/02/2015.
var ers;
(function (ers) {
    var components;
    (function (components) {
        var combobox;
        (function (combobox) {
                        /**
             * @ngdoc directive
             * @name ersCombobox
             * @restrict E (element)
             * @module ers.components.combobox
             * @scope
             * @transclude
             *
             * @description
             *
             * A combobox creates a drop-down selector and corresponding list of items from which to select.
             *
             * - Combobox should only contain combobox items.
             * - Combobox items create each selectable item for the drop-down selector.
             * - Combobox items should only contain text.
             *
             * ### Usage
             *
             * - Use a combobox for presenting options when screen real estate is limited.
             *
             * ### Examples
             *
             * #### Standard Combobox
             * A basic drop-down list with three items.
             *
             * <code-editor identifier="example1" data-title="Basic Combobox"
             * html-content-url="demos/ersCombobox/basicUsage/index.html"
             * js-content-url="demos/ersCombobox/basicUsage/script.js" css-content-url="demos/ersCombobox/basicUsage/styles.css"
             * content-mode="html"></code-editor>
             *
             * #### Combobox with Default Value
             * A basic drop-down list with an item selected by default.
             *
             * <code-editor identifier="example5" data-title=" "
             * html-content-url="demos/ersCombobox/defaultValue/index.html"
             * js-content-url="demos/ersCombobox/defaultValue/script.js" css-content-url="demos/ersCombobox/defaultValue/styles.css"
             * content-mode="html"></code-editor>
             *
             * #### Non Editable Combobox
             * Disabled and read only drop-down lists with three items each.
             *
             * <code-editor identifier="example2" data-title=""
             * html-content-url="demos/ersCombobox/disabledReadonly/index.html"
             * js-content-url="demos/ersCombobox/disabledReadonly/script.js" css-content-url="demos/ersCombobox/disabledReadonly/styles.css"
             * content-mode="html"></code-editor>
             *
             * #### Dynamic Item List
             * Drop-down list defined with `ng-repeat` for a more dynamic configuration.
             *
             * <code-editor identifier="example3" data-title=""
             * html-content-url="demos/ersCombobox/otherUsage/index.html"
             * js-content-url="demos/ersCombobox/otherUsage/script.js" css-content-url="demos/ersCombobox/otherUsage/styles.css"
             * content-mode="html"></code-editor>
             *
             * #### Combobox with Separator
             * A basic drop-down list with two groups of three items.
             *
             * <code-editor identifier="example4" data-title=""
             * html-content-url="demos/ersCombobox/separator/index.html"
             * js-content-url="demos/ersCombobox/separator/script.js" css-content-url="demos/ersCombobox/separator/styles.css"
             * content-mode="html"></code-editor>
          
             *
             * ### Design Guidelines
             *
             * - Strive for 10 or fewer items.  You can use more if users are familiar with the set of choices.
             * - List the items in a logical order. *For example*, order a list of available memory by size
             * (2 MB, 8 MB, and 4 GB). Default to alphabetic or numeric order for items that are not specifically ordered.
             * - If you need an unselected state, include an item with an empty (NULL) value, with an explicit label, for example, Not applicable.
             *
             * ### Accessibility Guidelines
             *
             * No accessibility guidelines.
             *
             * @param {string} [ng-disabled=false] {=?}
             * (ers-combobox) Specifies whether or not the combobox is disabled. When disabled, the combobox does not open and
             *  appears in the disabled style.
             *
             * @param {string} [ng-disabled=false] {=?}
             * (ers-combobox-item) Specifies whether or not the item is disabled. When disabled, the item is not selectable and
             *  appears in the disabled style. The remaining items in the drop-down are selectable.
             *
             * @param {string} ng-model {=}
             * (ers-combobox) Defines the model bound to the selected item.
             *
             * @param {boolean} [ng-required] {=?}
             * (ers-combobox) Marks the input as required. This adds the red asterisk to the combobox list item.
             *
             * @param {boolean} [ng-readonly] {=?}
             * (ers-combobox) Specifies whether or not the drop-down selected value can be changed.
             *
             * @param {string} [ng-change] {=?}
             * (ers-combobox) Updates the output value when the combobox input value changes.
             *
             *  @param {string} [value] {=}
             * (ers-combobox-item) Sets the value bound to the model when the item is selected in the drop-down list. The value is required excepted
             *  when separator is set to true.
             *
             *  @param {boolean} [separator=false] {=?}
             * (ers-combobox-item) Defines that the item is a separator in the list and not a selectable item. Do not define a value for the item
             *  when separator is set to true.
             *
             *
             */
            var comboboxDirective = function () {
                return {
                    restrict: "E",
                    templateUrl: "combobox/template/combobox-template.html",
                    transclude: true,
                    scope: {
                        ngDisabled: "=?", ngRequired: "=?", ngReadonly: "=?", cbbContainerId: "@?"
                    },
                    bindToController: true,
                    controller: combobox.ComboboxComponent,
                    controllerAs: "comboboxController",
                    require: ["ngModel", "ersCombobox"],
                    link: function ($scope, $element, $attributes, cbbCtrls) {
                        var modelCtrl = cbbCtrls[0];
                        var cbbCtrl = cbbCtrls[1];
                        // Set the model controller
                        cbbCtrl.setNgModelController(modelCtrl);
                        // Call the controller link
                        cbbCtrl.link($scope, $element, $attributes);
                    }
                };
            };
            angular.module("ers.components.combobox").directive("ersCombobox", comboboxDirective);
        })(combobox = components.combobox || (components.combobox = {}));
    })(components = ers.components || (ers.components = {}));
})(ers || (ers = {}));





// Created by germonneauf on 27/02/2015.
var ers;
(function (ers) {
    var components;
    (function (components) {
        var combobox;
        (function (combobox_1) {
                        /**
             *
             * @-ngdoc directive
             * @name ersComboboxItem
             * @restrict E
             * @module ers.components.combobox
             * @scope
             * @transclude
             *
             * @description
             *
             * Use the `ers-combobox-item` to create lists of selectable items for the drop-down selector in `ers-combobox`.
             *
             * <div style="margin: 30px;" ng-init="selectedFood=null;foods=[{name: 'Pizza'}, {name: 'Salad'}, {name:'Steak'}]">
             *   <ers-combobox ng-model="selectedFood">
             *     <ers-combobox-item separator="item.separator" ng-repeat="food in foods" value="food">
             *       {{food.name}}
             *     </ers-combobox-item>
             *   </ers-combobox>
             * </div>
             *
             * #### Visual Design Guidelines
             *
             * Consider the following visual design guidelines:
             *
             * - Use a drop-down menu or combo box for presenting options when screen real estate is limited.
             *
             * - Use a rich combo box to add images or labels to the menu.
             *
             * - Keep the number of items limited.
             *
             * - List the items in a logical order. For example, order a list of available memory by size
             * (2 MB, 8 MB, and 4 GB). Default to alphabetic or numeric order for items that are not specifically ordered.
             *
             * - If "None" is a valid value, include it as a menu item.  Otherwise, users will not be able to reset the menu
             * to "None" after another value is chosen.
             *
             * - Use the separator to group similar items.
             *
             * #### Example
             *
             * The following example displays the code from the description display. Note the `ers-combobox` wraps the
             * `ers-combobox-item`.
             *
             * ```xml
             * <div style="margin: 30px;" ng-init="selectedFood=null;foods=[{name: 'Pizza'}, {name: 'Salad'}, {name:'Steak'}]">
             *   <ers-combobox ng-model="selectedFood">
             *     <ers-combobox-item separator="item.separator" ng-repeat="food in foods" value="food">
             *       {{food.name}}
             *     </ers-combobox-item>
             *   </ers-combobox>
             * </div>
             *
             * ```
             *
             *  @param {string} [ng-disabled=false] {=}
             * Sets the code associated with the item.
             *
             *  @param {string} [value] {=}
             * Sets the value for this item in the combobox.
             *
             */
            var comboboxItemDirective = function () {
                return {
                    restrict: "E",
                    require: ["ersComboboxItem", "^?ersCombobox"],
                    scope: {
                        ngDisabled: "=?", value: "=", separator: "=?"
                    },
                    transclude: true,
                    templateUrl: "combobox/template/combobox-item-template.html",
                    // bindToController: true,
                    controller: combobox_1.ComboboxItemController,
                    link: function ($scope, $element, $attributes, controllers) {
                        // Directive controller required
                        var comboboxItemController = controllers[0];
                        if (!comboboxItemController) {
                            throw new Error("Required controller not found");
                        }
                        // Looking for parent controller (ersCombobox)
                        var comboboxController = controllers[1];
                        if (!comboboxController) {
                            // Parent controller not found. Case where the item combobox is appended to the body and not directly inside
                            // the parent ersCombobox. We have to find the parent by the "po-target"'s attribute and get the controller.
                            var id = $element.closest(".ers-combobox-list").attr("id");
                            var combobox = angular.element($("button[po-target='#" + id + "']"));
                            comboboxController = combobox.controller("ersCombobox");
                        }
                        // Finish building item combobox
                        comboboxItemController.link($scope, $element, $attributes);
                        // Set delegate to manage onCLick event
                        comboboxItemController.delegate = comboboxController;
                    }
                };
            };
            angular.module("ers.components.combobox").directive("ersComboboxItem", comboboxItemDirective);
        })(combobox = components.combobox || (components.combobox = {}));
    })(components = ers.components || (ers.components = {}));
})(ers || (ers = {}));/**
 * Created by germonneauf on 10/14/2015.
 */
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};


var ers;
(function (ers) {
    var components;
    (function (components) {
        var core;
        (function (core) {
            /**
             * Controller dedicated for attribute component.
             */
            var DecoratorComponent = (function (_super) {
                __extends(DecoratorComponent, _super);
                /**
                 * Decorator constructor
                 * @param $scope Component private scope
                 * @param $element Component element
                 */
                function DecoratorComponent($scope, $element) {
                    _super.call(this, $scope, $element);
                }
                return DecoratorComponent;
            })(core.BaseController);
            core.DecoratorComponent = DecoratorComponent;
        })(core = components.core || (components.core = {}));
    })(components = ers.components || (ers.components = {}));
})(ers || (ers = {}));

/**
 * Event constant
 */
var ers;
(function (ers) {
    var components;
    (function (components) {
        var core;
        (function (core) {
            var event;
            (function (event) {
                                /**
                 * Utility which contains the event constants.
                 */
                event.EVENT = {
                    RESIZE: "resize"
                };
            })(event = core.event || (core.event = {}));
        })(core = components.core || (components.core = {}));
    })(components = ers.components || (ers.components = {}));
})(ers || (ers = {}));


var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var ers;
(function (ers) {
    var components;
    (function (components) {
        var drawer;
        (function (drawer) {
                        var DecoratorComponent = ers.components.core.DecoratorComponent;
            var EVENT = ers.components.core.event.EVENT;
            /**
             *
             * @ngdoc directive
             * @name ersDrawer
             * @restrict A
             * @module ers.components.drawer
             * @scope
             * @transclude
             *
             * @description
             *
             * Use the `ers-drawer` component to `slide` a secondary panel over your primary browser window, or
             * parent container window, displaying another interaction panel.
             * The secondary panel starts as partially hidden and is activated by clicking
             * the` ers-drawer-header`. Once expanded, the panel can be 'pinned' to retain full visibility.
             *
             * ### Usage
             *
             *  The slide component has two states:
             *
             * - Pin/Unpin State
             * - Drawer State
             *
             * #### Pin/Unpin State
             * - The Pin state displays the drawer without the drawer look and feel. Content is displayed as
             * defined in the HTML page. The `ers-drawer-header` icon notifies you that this is a drawer component and toggles
             * the pin/unpin drawer behavior.
             * - The pin/unpin icon activates the ers-drawer-header component. Clicking the icon toggles the drawer between
             * fully extended, or displayed, and collapsed, or hidden. In pinned mode, the drawer can be configured
             * to cover the entire page.
             *
             * #### Drawer State
             * - When the drawer is unpinned, the component can slide from the designated direction, left, right, top, or bottom,
             * to fully or partially expanded, or collapsed. The drawer is initiated by clicking the slide tab.
             *
             * ### Examples
             *
             * The following example demonstrates a drawer configured as:
             *
             * - Drawer from right
             * - Drawer width 500px
             * - Pinned option=true
             * - Drawer tab labeled 'Action tab'
             *
             * <code-editor identifier="example1" data-title="Drawer" html-content-url="demos/ersDrawer/basicUsage/index.html"
             * js-content-url="demos/ersDrawer/basicUsage/script.js" css-content-url="demos/ersDrawer/basicUsage/styles.css"
             * content-mode="html"></code-editor>
             *
             * ### Design Guidelines
             * <!--needs additional information -  TODO -->
             *
             * The drawer component provide additional information about the sheet container to which they are attached. Unlike
             * the left-navigation panel, the ers-drawer panel is only visible on demand, when clicked.
             *
             * ers-drawer is a navigation panel embedded within another parent container including:
             * - Data grid
             * - Forms
             * - Panel containers
             * - Sections
             *
             * ### Accessibility Guidelines
             *
             * No accessibility guidelines
             *
             * @param {string} [ers-drawer-from="left"] {=?}
             *  Specifies the initial drawer position and the direction from which the drawer originates, top, right, left, or
             *  bottom. The default is left.
             *
             * @param {boolean} [ers-drawer-pinned] {=?}
             * Specifies  the pin state of this drawer. When true, the drawer is pinned at the location defined in the html page.
             * When false, the drawer is pinned under the sheet container in the location defined
             * in the 'slide-from' attribute. When not defined, the default setting is collapsed on the left side
             * of the page container. Use `ers-drawer-header` to create a pinned/unpinned icon.
             *
             *
             * @param {string} [ers-drawer-max-width-size] {@}
             * Specifies  the maximum width of the drawer. If the designated maximum width exceeds the sheet container, the
             * maximum width is reset to the width of the container.
             *
             *  @param {string} [ers-drawer-max-height-size] {@}
             *  Specifies  the maximum height of the drawer. If the designated maximum height exceeds the sheet container, the
             * maximum height is reset to the width of the container.
             *
             *
             * @param {string} [ers-drawer-label] {@}
             *
             * Specifies  the label displayed when the drawer is unpinned.
             *
             * @param {boolean} [ers-drawer-collapsed] {=?}
             *
             * Specifies the collapsed state.
             *
             */
            angular.module("ers.components.drawer", ["ers.components.core", "ngSanitize"]).directive("ersDrawer", function () {
                return {
                    restrict: "A",
                    templateUrl: "drawer/template/drawer-template.html",
                    controller: DrawerComponent,
                    controllerAs: "drawerController",
                    bindToController: true,
                    transclude: true,
                    scope: {
                        "slideFrom": "=?ersDrawerFrom",
                        "pinned": "=?ersDrawerPinned",
                        "collapsed": "=?ersDrawerCollapsed",
                        "maxWidthSize": "@ersDrawerMaxWidthSize",
                        "maxHeightSize": "@ersDrawerMaxHeightSize",
                        "label": "@ersDrawerLabel"
                    }
                };
            });
            var DrawerComponent = (function (_super) {
                __extends(DrawerComponent, _super);
                /**
                 *
                 * Constructor.
                 * @param $element The component element.
                 * @param $timeout The Angular timeout service that is currently used to initiate a function when the
                 * model controller is fully loaded.
                 * @param $transclude The $transclude function.
                 * @param $scope The scope.
                 * @param $rootScope The rootscope.
                 *
                 */
                function DrawerComponent($element, $timeout, $scope, $rootScope, containerEventService) {
                    var _this = this;
                    _super.call(this, $scope, $element);
                    /**
                     *
                     * This property is used to determine if the drawer is fully collapsed (true),
                     * or not (false). The default value is true.
                     *
                     */
                    this._isFullyCollapsed = true;
                    /**
                     *
                     * This property is used to determine if the drawer is partially collapsed (true), and that
                     * the size of the drawer container is equal to the minimum size or not (false). The initial value is false.
                     *
                     */
                    this._isPartiallyCollapsed = false;
                    /**
                     * True if the initialization is in progress.
                     */
                    this.initInProgress = false;
                    /**
                     * Using JavaScript to manage the CSS splitter ellipsis behavior as pure CSS cannot.
                     *
                     */
                    this.splitterEllipsisCSSOnMouseover = function () {
                        if (!_this._splitterCollapseArrow.is(":hover") && !_this._splitterExpandArrow.is(":hover")) {
                            _this._splitterEllipsis.css("color", "#000000");
                        }
                    };
                    /**
                     * Using JavaScript to manage the CSS splitter ellipsis behavior as pure CSS cannot.
                     *
                     */
                    this.splitterEllipsisCSSOnMouseOut = function () {
                        _this._splitterEllipsis.css("color", "#7f7f7f");
                    };
                    /**
                     * The function called when the user clicks the left arrow.
                     */
                    this.mouseClickEventOnExpandArrow = function () {
                        if (!_this._splitterExpandArrow.hasClass("ng-disabled")) {
                            if (_this.isBottomTop() && _this._proxySize < _this._maxHeightSizeIntValue) {
                                _this._drawerBlockContainer.css("height", _this._maxHeightSizeIntValue);
                                _this._proxySize = _this._maxHeightSizeIntValue;
                            }
                            else if (!_this.isBottomTop() && _this._proxySize < _this._maxWidthSizeIntValue) {
                                _this._drawerBlockContainer.css("width", _this._maxWidthSizeIntValue);
                                _this._proxySize = _this._maxWidthSizeIntValue;
                            }
                            _this.computeTabPosition();
                            _this._splitterExpandArrow.addClass("ng-disabled");
                            _this._splitterCollapseArrow.removeClass("ng-disabled");
                            _this._isPartiallyCollapsed = false;
                            _this._isFullyCollapsed = false;
                            // Propagate resize event to registered layout.
                            _this.containerEventService.dispatch(EVENT.RESIZE, _this.$scope);
                        }
                    };
                    /**
                     * The function called when the user clicks the left arrow.
                     */
                    this.mouseClickEventOnCollapseArrow = function () {
                        if (!_this._splitterCollapseArrow.hasClass("ng-disabled")) {
                            if (_this.isBottomTop() && _this._proxySize - _this._splitterBar.outerHeight() > DrawerComponent.DRAWER_MIN_WIDTH) {
                                // Resize the drawer container to the minimal size position.
                                _this._drawerBlockContainer.css("height", DrawerComponent.DRAWER_MIN_WIDTH);
                            }
                            else if (!_this.isBottomTop() && _this._proxySize - _this._splitterBar.outerWidth() > DrawerComponent.DRAWER_MIN_WIDTH) {
                                // Resize the drawer container to the minimal size position.
                                _this._drawerBlockContainer.css("width", DrawerComponent.DRAWER_MIN_WIDTH);
                            }
                            _this._proxySize = DrawerComponent.DRAWER_MIN_WIDTH;
                            _this.computeTabPosition();
                            _this._splitterExpandArrow.removeClass("ng-disabled");
                            _this._splitterCollapseArrow.addClass("ng-disabled");
                            _this._isPartiallyCollapsed = true;
                            // Propagate resize event to registered layout.
                            _this.containerEventService.dispatch(EVENT.RESIZE, _this.$scope);
                        }
                    };
                    /**
                     *
                     * The function is called when the user clicks the tab icon.
                     *
                     */
                    this.mouseClickEventOnTabBar = function () {
                        _this.collapsed = !_this.collapsed;
                        // Change the icon direction, update the size of the drawer container and the drawer block container.
                        if (_this._isFullyCollapsed) {
                            _this.computeElements();
                            _this._proxySize = _this.isBottomTop() ? _this._drawerBlockContainer.outerHeight() : _this._drawerBlockContainer.outerWidth();
                        }
                        else {
                        }
                    };
                    /**
                     *
                     * The function is called when the user clicks and holds the mouse button down, dragging the splitter.
                     * @param event The mouse down event.
                     *
                     */
                    this.mouseDownEvent = function (event) {
                        if (event.which === 1) {
                            _this._mouseBtnPressed = true;
                            _this._splitterBar.addClass("splitter-bar-" + _this.slideFrom + "-dragged");
                            if (_this.isBottomTop()) {
                                _this._proxySize = _this._drawerBlockContainer.outerHeight();
                                _this._yRef = event.pageY;
                            }
                            else {
                                _this._proxySize = _this._drawerBlockContainer.outerWidth();
                                _this._xRef = event.pageX;
                            }
                        }
                    };
                    /**
                     * This function is called on mouse up.
                     * @param event The mouse up event.
                     */
                    this.mouseUpEvent = function (event) {
                        _this._splitterBar.removeClass("splitter-bar-" + _this.slideFrom + "-dragged");
                        if (_this._mouseBtnPressed && _this._mouseIsDragging) {
                            var offset = _this.isBottomTop() ? (_this.isLeftTop() ? event.pageY - _this._yRef : _this._yRef - event.pageY)
                                : (_this.isLeftTop() ? event.pageX - _this._xRef : _this._xRef - event.pageX);
                            _this._proxySize = _this._proxySize + offset;
                            if (_this._proxySize > (_this.isBottomTop() ? _this._maxHeightSizeIntValue : _this._maxWidthSizeIntValue)) {
                                // Don't exceed the max size.
                                _this.applyExpandBehaviours();
                                _this._proxySize = _this.isBottomTop() ? _this._maxHeightSizeIntValue : _this._maxWidthSizeIntValue;
                            }
                            else {
                                if (_this._proxySize - (_this.isBottomTop() ? _this._splitterBar.outerHeight() :
                                    _this._splitterBar.outerWidth()) > DrawerComponent.DRAWER_MIN_WIDTH) {
                                    _this._drawerBlockContainer.css(_this.isBottomTop() ? "height" : "width", _this._proxySize);
                                    _this._proxySize = _this.isBottomTop() ? _this._splitterBar.outerHeight() : _this._splitterBar.outerWidth();
                                }
                                else {
                                    _this._proxySize = DrawerComponent.DRAWER_MIN_WIDTH;
                                }
                            } // else { // Nothing to do. No resize with the proxy width and no collapse.  }
                        }
                        _this._mouseBtnPressed = false;
                        _this._mouseIsDragging = false;
                    };
                    /**
                     * This function manages the click and drag mouse mouse behavior.
                     * @param event The mouse button press.
                     */
                    this.mouseMoveEvent = function (event) {
                        if (_this._mouseBtnPressed) {
                            var offset = _this.isBottomTop() ? (_this.isLeftTop() ? event.pageY - _this._yRef : _this._yRef - event.pageY)
                                : (_this.isLeftTop() ? event.pageX - _this._xRef : _this._xRef - event.pageX);
                            _this._proxySize = _this._proxySize + offset;
                            if (DrawerComponent.DRAWER_MIN_WIDTH < _this._proxySize && _this._proxySize <= (_this.isBottomTop() ?
                                _this._maxHeightSizeIntValue : _this._maxWidthSizeIntValue)) {
                                // Don't exceed the max size.
                                _this._drawerBlockContainer.css(_this.isBottomTop() ? "height" : "width", _this._proxySize);
                                _this.computeTabPosition();
                                _this._proxySize = _this.isBottomTop() ? _this._drawerBlockContainer.outerHeight() :
                                    _this._drawerBlockContainer.outerWidth();
                                _this._splitterExpandArrow.removeClass("ng-disabled");
                                _this._splitterCollapseArrow.removeClass("ng-disabled");
                            }
                            else if (DrawerComponent.DRAWER_MIN_WIDTH >= _this._proxySize) {
                                _this._splitterExpandArrow.removeClass("ng-disabled");
                                _this._splitterCollapseArrow.addClass("ng-disabled");
                            }
                            else if (_this._proxySize >= (_this.isBottomTop() ? _this._maxHeightSizeIntValue : _this._maxWidthSizeIntValue)) {
                                _this._splitterExpandArrow.addClass("ng-disabled");
                                _this._splitterCollapseArrow.removeClass("ng-disabled");
                            } // else { // Nothing to do. No resize with the proxy width and no collapse.  }
                            if (_this.isBottomTop()) {
                                _this._yRef = event.pageY;
                            }
                            else {
                                _this._xRef = event.pageX;
                            }
                            _this._mouseIsDragging = true;
                        }
                        event.preventDefault();
                        event.stopPropagation();
                    };
                    this.$timeout = $timeout;
                    this.initInProgress = true;
                    this.$rootscope = $rootScope;
                    this.containerEventService = containerEventService;
                    containerEventService.registerDispatcher(EVENT.RESIZE, $scope);
                    if (this.pinned) {
                        $element.addClass("ers-drawer-pinned");
                    }
                    else {
                        $element.addClass("ers-drawer");
                    }
                    this.computeElements();
                    this.collapsed = this.innerCollapsed === undefined ? this.collapsed : this.innerCollapsed;
                    this.slideFrom = this.innerSlideFrom === undefined ? this.slideFrom : this.innerSlideFrom;
                    this.pinned = this.innerPinned === undefined ? this.pinned : this.innerPinned;
                    this.initInProgress = false;
                }
                /**
                 * Initialize the drawer.
                 */
                DrawerComponent.prototype.init = function () {
                    var _this = this;
                    if (this.$element) {
                        this.$element.addClass("ers-drawer-" + this.slideFrom);
                        setTimeout(function () {
                            //we remove the listeners.
                            _this.removeListeners();
                            // Find all needed element.
                            _this.computeElements();
                            _this.declareListeners();
                            // set some css prop
                            _this._tabContainer.css("top", "");
                            _this._splitterCollapseArrow.addClass(_this.getSplitterCollapseArrow());
                            _this._splitterExpandArrow.addClass(_this.getSplitterExpandArrow());
                            _this._splitterEllipsis.addClass(_this.getSplitterEllipsisIcon());
                            _this._tabContainer.css(_this.slideFrom, (_this.isBottomTop() ? _this._tabContainer.innerHeight()
                                : _this._tabContainer.innerWidth()) + _this._tabContainer.position[_this.slideFrom]);
                            // Initiate some properties.
                            _this._xRef = 0;
                            _this._yRef = 0;
                            // we have to find the real maxWidth/maxHeight
                            _this.computeMaxSizes();
                            // show the drawer and set listeners
                            if (_this.collapsed) {
                                _this._tabIcon.addClass(_this.getTabIconExpandDirection());
                            }
                            else {
                                _this._tabIcon.addClass(_this.getTabIconCollapseDirection());
                            }
                            _this._tabContainer.css("display", _this.pinned ? "none" : "inline-block");
                        }, 0);
                    }
                };
                /**
                 *
                 * Retrieve all of the ers-drawer elements according to their classes and their slideFrom.
                 *
                 */
                DrawerComponent.prototype.computeElements = function () {
                    this._tabContainer = this.$element.find(".ers-drawer-tab-container-" + this.slideFrom);
                    this._tabIcon = this.$element.find(".ers-drawer-tab-icon-" + this.slideFrom + " i");
                    this._drawerBlockContainer = this.$element.find(".ers-drawer-block-container-" + this.slideFrom);
                    this._splitterBar = this.$element.find(".ers-splitter-bar-" + this.slideFrom);
                    this._splitterCollapseArrow = this._splitterBar.find("i.fa.after-icon");
                    this._splitterExpandArrow = this._splitterBar.find("i.fa.before-icon");
                    this._splitterEllipsis = this._splitterBar.find("i.fa.ellipsis-icon");
                };
                /**
                 * Compute the maximum slide sizes from all drawer directions.
                 */
                DrawerComponent.prototype.computeMaxSizes = function () {
                    if (this.pinned) {
                        this._drawerBlockContainer.css("height", "");
                        this._drawerBlockContainer.css("width", "");
                    }
                    else {
                        this._drawerBlockContainer.css("height", this.maxHeightSize);
                        this._drawerBlockContainer.css("width", this.maxWidthSize);
                    }
                    this._maxHeightSizeIntValue = this._drawerBlockContainer.outerHeight();
                    this._maxWidthSizeIntValue = this._drawerBlockContainer.outerWidth();
                    this._savedSizeState = this.isBottomTop() ? this._maxHeightSizeIntValue : this._maxWidthSizeIntValue;
                };
                /**
                 *
                 * Declare the mouse event listeners on the drawer.
                 *
                 */
                DrawerComponent.prototype.declareListeners = function () {
                    this._tabContainer.on("click", this.mouseClickEventOnTabBar);
                    this._splitterBar.on("mousedown", this.mouseDownEvent);
                    document.addEventListener("mouseup", this.mouseUpEvent);
                    document.addEventListener("mousemove", this.mouseMoveEvent);
                    this._splitterCollapseArrow.on("click", this.mouseClickEventOnCollapseArrow);
                    this._splitterExpandArrow.on("click", this.mouseClickEventOnExpandArrow);
                    // The ellipsis CSS on :hover and not(:hover) CSS event must be manage with Javascript because with the current
                    // CSS specification is not possible to disable the hover event on parent when child are also hover.
                    this._splitterBar.on("mousedown", this.mouseDownEvent).on("mouseover", this.splitterEllipsisCSSOnMouseover).on("mouseout", this.splitterEllipsisCSSOnMouseOut);
                };
                /**
                 *
                 * Remove the mouse event listeners on the drawer.
                 *
                 */
                DrawerComponent.prototype.removeListeners = function () {
                    if (!this._tabContainer) {
                        return;
                    }
                    this._tabContainer.off("click", this.mouseClickEventOnTabBar);
                    document.removeEventListener("mouseup", this.mouseUpEvent);
                    document.removeEventListener("mousemove", this.mouseMoveEvent);
                    this._splitterCollapseArrow.off("click", this.mouseClickEventOnCollapseArrow);
                    this._splitterExpandArrow.off("click", this.mouseClickEventOnExpandArrow);
                    this._splitterBar.off("mousedown", this.mouseDownEvent).off("mouseover", this.splitterEllipsisCSSOnMouseover)
                        .off("mouseout", this.splitterEllipsisCSSOnMouseOut);
                };
                /**
                 *
                 * The function called to apply the expand behavior to the drawer component.
                 *
                 */
                DrawerComponent.prototype.applyExpandBehaviours = function () {
                    if (this._tabIcon) {
                        this._tabIcon.removeClass(this.getTabIconExpandDirection());
                        this._tabIcon.addClass(this.getTabIconCollapseDirection());
                        var prop = this.isBottomTop() ? "Height" : "Width";
                        this._proxySize = this._savedSizeState;
                        this._drawerBlockContainer.css(prop.toLowerCase(), this._savedSizeState);
                        this._drawerBlockContainer.css("display", "block");
                        if (this._proxySize >= this["_max" + prop + "SizeIntValue"]) {
                            this._splitterExpandArrow.addClass("ng-disabled");
                        }
                        this.computeTabPosition();
                        this._isFullyCollapsed = false;
                        this._isPartiallyCollapsed = false;
                    }
                };
                /**
                 *
                 * The function called to apply the collapse behavior to the drawer component.
                 *
                 */
                DrawerComponent.prototype.applyCollapseBehaviours = function () {
                    if (this._tabIcon) {
                        this._tabIcon.removeClass(this.getTabIconCollapseDirection());
                        this._tabIcon.addClass(this.getTabIconExpandDirection());
                        this._savedSizeState = this._proxySize;
                        this._drawerBlockContainer.css(this.isBottomTop() ? "height" : "width", "0px");
                        this._drawerBlockContainer.css("display", "none");
                        this._proxySize = 0;
                        this.computeTabPosition();
                        this._isFullyCollapsed = true;
                        this._isPartiallyCollapsed = false;
                    }
                };
                /**
                 * Computes and sets the the tab position.
                 */
                DrawerComponent.prototype.computeTabPosition = function () {
                    this._tabContainer.css("right", "");
                    this._tabContainer.css("left", "");
                    this._tabContainer.css("top", "");
                    this._tabContainer.css("bottom", "");
                    this._tabContainer.css(this.slideFrom, this._proxySize);
                };
                /**
                 * @returns Sets the tab icon direction based on the "slide from" collapsed property.
                 */
                DrawerComponent.prototype.getTabIconExpandDirection = function () {
                    return DrawerComponent.ROTATIONS_ICONS["tabIconExpandDirection"][this.slideFrom];
                };
                /**
                 * @returns Sets the tab icon direction based on the "slide from" expanded property.
                 */
                DrawerComponent.prototype.getTabIconCollapseDirection = function () {
                    return DrawerComponent.ROTATIONS_ICONS["tabIconCollapseDirection"][this.slideFrom];
                };
                /**
                 * @returns Sets the splitter ellipsis icon based on the "slide from" property.
                 */
                DrawerComponent.prototype.getSplitterEllipsisIcon = function () {
                    return DrawerComponent.ROTATIONS_ICONS["splitterEllipsisIcon"][this.slideFrom];
                };
                /**
                 * @returns Sets the splitter collapse arrow based on the "slide from" property.
                 */
                DrawerComponent.prototype.getSplitterCollapseArrow = function () {
                    return DrawerComponent.ROTATIONS_ICONS["splitterCollapseArrow"][this.slideFrom];
                };
                /**
                 * @returns Sets the splitter expand arrow based on the "slide from" property.
                 */
                DrawerComponent.prototype.getSplitterExpandArrow = function () {
                    return DrawerComponent.ROTATIONS_ICONS["splitterExpandArrow"][this.slideFrom];
                };
                Object.defineProperty(DrawerComponent.prototype, "slideFrom", {
                    /**
                     *
                     * @returns {string} The slide direction.
                     */
                    get: function () {
                        return angular.isUndefined(this._slideFrom) ? "left" : this._slideFrom;
                    },
                    /**
                     *
                     * @param pSlideFrom The slide direction.
                     */
                    set: function (pSlideFrom) {
                        if (DrawerComponent.AUTHORIZED_SIDE_FROM.indexOf(pSlideFrom) >= 0) {
                            if (this.$element) {
                                var tempFrom = this._slideFrom;
                                if (tempFrom !== pSlideFrom) {
                                    //we reset the tab css and hide it.
                                    if (this._tabContainer) {
                                        this._tabContainer.css("display", "none");
                                        //  this._splitterBar.css("display", "none");
                                        this._tabIcon.removeClass(this.getTabIconCollapseDirection());
                                        this._tabIcon.removeClass(this.getTabIconExpandDirection());
                                    }
                                    //we reset the splitter
                                    if (this._splitterEllipsis) {
                                        this._splitterCollapseArrow.removeClass(this.getSplitterCollapseArrow());
                                        this._splitterExpandArrow.removeClass(this.getSplitterExpandArrow());
                                        this._splitterEllipsis.removeClass(this.getSplitterEllipsisIcon());
                                    }
                                    if (this.$element) {
                                        this.$element.removeClass("ers-drawer-" + tempFrom);
                                    }
                                    this._slideFrom = pSlideFrom;
                                    // if the drawer is expanded, we collapse it
                                    if (!this.pinned && angular.isDefined(this._isFullyCollapsed) && !this._isFullyCollapsed) {
                                        this.collapsed = this.initInProgress ? this.collapsed : true;
                                    }
                                    this.init();
                                }
                            }
                            else {
                                this.innerSlideFrom = pSlideFrom;
                            }
                        }
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * Toggle the drawer pin state.
                 */
                DrawerComponent.prototype.togglePinned = function () {
                    this.pinned = !this.pinned;
                };
                Object.defineProperty(DrawerComponent.prototype, "pinned", {
                    /**
                     *
                     * @returns {boolean} True if the content is pinned.
                     */
                    get: function () {
                        return angular.isUndefined(this._pinned) ? true : this._pinned;
                    },
                    /**
                     *
                     * @param pPinned True if the drawer is pinned.
                     *
                     */
                    set: function (pPinned) {
                        if (this.$element) {
                            if (this._pinned !== pPinned) {
                                this._pinned = pPinned;
                                // drawer is pinned
                                if (pPinned) {
                                    this.$element.removeClass("ers-drawer");
                                    this.$element.addClass("ers-drawer-pinned");
                                    if (this._tabContainer) {
                                        this._tabContainer.css("display", "none");
                                        this._drawerBlockContainer.css("height", "");
                                        this._drawerBlockContainer.css("width", "");
                                        this.collapsed = true;
                                        this._drawerBlockContainer.css("display", "block");
                                    }
                                }
                                else {
                                    this.collapsed = this.initInProgress ? this.collapsed : false;
                                    this.$element.addClass("ers-drawer");
                                    this.$element.removeClass("ers-drawer-pinned");
                                    if (this._tabContainer) {
                                        this._tabContainer.css("display", "inline-block");
                                    }
                                    if (this._drawerBlockContainer) {
                                        this.computeMaxSizes();
                                        this.applyExpandBehaviours();
                                    }
                                }
                            }
                        }
                        else {
                            this.innerPinned = pPinned;
                        }
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(DrawerComponent.prototype, "collapsed", {
                    /**
                     *
                     * @returns {boolean} True if the drawer is collapsed.
                     *
                     */
                    get: function () {
                        return angular.isUndefined(this._collapsed) ? true : this._collapsed;
                    },
                    /**
                     *
                     * @param pCollapsed True if the content is collapsed.
                     */
                    set: function (pCollapsed) {
                        var _this = this;
                        if (this.$element) {
                            this._collapsed = pCollapsed;
                            setTimeout(function () {
                                if (!_this.pinned) {
                                    if (pCollapsed && _this.applyCollapseBehaviours) {
                                        _this.computeMaxSizes();
                                        _this.applyCollapseBehaviours();
                                    }
                                    else if (_this.applyExpandBehaviours) {
                                        _this.computeMaxSizes();
                                        _this.applyExpandBehaviours();
                                    }
                                    _this.render();
                                    // Propagate resize event to registered layout.
                                    _this.containerEventService.dispatch(EVENT.RESIZE, _this.$scope);
                                }
                            }, 0);
                        }
                        else {
                            this.innerCollapsed = pCollapsed;
                        }
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 *
                 * @returns {boolean} True if the drawer is a left or top left slide type.
                 */
                DrawerComponent.prototype.isLeftTop = function () {
                    return "lefttop".indexOf(this.slideFrom) >= 0;
                };
                /**
                 *
                 * @returns {boolean} True if the drawer is a bottom or top slide type.
                 */
                DrawerComponent.prototype.isBottomTop = function () {
                    return "bottomtop".indexOf(this.slideFrom) >= 0;
                };
                /**
                 * Updates html
                 */
                DrawerComponent.prototype.render = function () {
                    if (this.$rootscope && !this.$rootscope.$$phase) {
                        this.$rootscope.$apply();
                    }
                };
                /**
                 *
                 * Specifies the side from which the drawer slides. The default is from the left.
                 *
                 */
                DrawerComponent.AUTHORIZED_SIDE_FROM = ["left", "top", "right", "bottom"];
                /**
                 *
                 * The drawer minimum width setting in pixels (px).  When the drawer is minimized beyond this setting, the
                 * panel snaps to collapsed view.
                 *
                 */
                DrawerComponent.DRAWER_MIN_WIDTH = 310;
                /**
                 *
                 * The CSS to apply and the icons impacted based on the drawer origination and the direction to which it slides.
                 *
                 */
                DrawerComponent.ROTATIONS_ICONS = {
                    tabIconCollapseDirection: {
                        right: "fa-rotate-0",
                        left: "fa-rotate-180",
                        top: "fa-rotate-270",
                        bottom: "fa-rotate-90"
                    },
                    tabIconExpandDirection: {
                        right: "fa-rotate-180",
                        left: "fa-rotate-0",
                        top: "fa-rotate-90",
                        bottom: "fa-rotate-270"
                    },
                    splitterEllipsisIcon: {
                        right: "fa-ellipsis-v",
                        left: "fa-ellipsis-v",
                        top: "fa-ellipsis-h",
                        bottom: "fa-ellipsis-h"
                    },
                    splitterCollapseArrow: {
                        right: "fa-caret-right",
                        left: "fa-caret-left",
                        top: "fa-caret-up",
                        bottom: "fa-caret-down"
                    },
                    splitterExpandArrow: {
                        right: "fa-caret-left",
                        left: "fa-caret-right",
                        top: "fa-caret-down",
                        bottom: "fa-caret-up"
                    }
                };
                DrawerComponent.$inject = ["$element", "$timeout", "$scope", "$rootScope", "containerEventService"];
                return DrawerComponent;
            })(DecoratorComponent);
            drawer.DrawerComponent = DrawerComponent;
        })(drawer = components.drawer || (components.drawer = {}));
    })(components = ers.components || (ers.components = {}));
})(ers || (ers = {}));

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var ers;
(function (ers) {
    var components;
    (function (components) {
        var drawer;
        (function (drawer) {
                        var BaseComponent = ers.components.core.BaseComponent;
            /**
             *
             * @-ngdoc directive
             * @name ersDrawerHeader
             * @restrict E
             * @module ers.components.drawer
             * @scope
             * @transclude
             *
             * @description
             *
             * Use the `ers-drawer-header` component to create the pin or unpin icon for the `ers-drawer` component.
             *
             *
             * The following example displays the ers-drawer-header icon configured with a
             * basic drawer. <!-configured with TODO. needs better example-->
             *
             * <style type="text/css">
             * </style>
             *
             * <div ers-drawer ers-drawer-from="'right'" ers-drawer-max-width-size="400px"
             *  ers-drawer-max-height-size="500px" ers-drawer-pinned="true"
             *  ers-drawer-label="Action Tab " id="title" <!--ers-drawer-collapsed="true">
             *     <ers-drawer-header style="position: right; padding-right: 20px;" ></ers-drawer-header>
             *      <div style="height: 35px; padding-left: 10px;">
             *          <div style="position: center;">
             *              <ers-number name="Number"></ers-number>
             *          </div>
             *      </div>
             *  </div>
             *
             *
             *
             * #### Visual Design Guidelines
             *
             * *For more information, see* [ers-drawer](#/components/ersDrawer/documentation)
             *
             *
             *
             * #### Examples
             *
             * The following example displays the code from the description display.
             *
             *
             * ```xml
             * <div ers-drawer ers-drawer-from="'right'" ers-drawer-max-width-size="400px"
             *  ers-drawer-max-height-size="500px" ers-drawer-pinned="true"
             *  ers-drawer-label="Action Tab " id="title" <!--ers-drawer-collapsed="true">
             *     <ers-drawer-header style="position: right; padding-right: 20px;" ></ers-drawer-header>
             *      <div style="height: 35px; padding-left: 10px;">
             *          <div style="position: center;">
             *              <ers-number name="Number"></ers-number>
             *          </div>
             *      </div>
             *  </div>
             *
             * ```
             *
             */
            angular.module("ers.components.drawer").directive("ersDrawerHeader", function () {
                return {
                    restrict: "E",
                    templateUrl: "drawer/template/drawer-header-template.html",
                    controller: DrawerHeaderComponent,
                    controllerAs: "drawerHeaderComponent",
                    bindToController: true,
                    transclude: true,
                    require: ["^ersDrawer"],
                    scope: {},
                    link: function ($scope, element, attrs, ctrl) {
                        element.inheritedData().$ersDrawerHeaderController.drawerController = ctrl[0];
                    }
                };
            });
            /**
             * ###Drawer header component
             * Use the `ers-drawer-header` component to create the pin or unpin icon for the `ers-drawer` component.
             *
             * * ### Available Methods
             *
             * * [togglePinned](#togglePinned)
             * ### Examples
             *
             * #### Example.
             *
             * ```xml
             *
             *   <div ers-drawer ers-drawer-from="'right'" ers-drawer-max-width-size="400px"
             *  ers-drawer-max-height-size="500px" ers-drawer-pinned="true"
             *  ers-drawer-label="Action Tab " id="title" <!--ers-drawer-collapsed="true">
             *     <ers-drawer-header style="position: right; padding-right: 20px;" ></ers-drawer-header>
             *      <div style="height: 35px; padding-left: 10px;">
             *          <div style="position: center;">
             *              <ers-number name="Number"></ers-number>
             *          </div>
             *      </div>
             *  </div>
             *
             * ```
             *
             */
            var DrawerHeaderComponent = (function (_super) {
                __extends(DrawerHeaderComponent, _super);
                /**
                 * Constructor.
                 * @param $element The component element.
                 * @param $timeout The Angular timeout service used to run a
                 * function when the model controller is fully committed.
                 *
                 */
                function DrawerHeaderComponent($scope, $element, $timeout) {
                    _super.call(this, $scope, $element, null, $timeout);
                }
                /**
                 * Toggles the pin state.
                 */
                DrawerHeaderComponent.prototype.togglePinned = function () {
                    this.drawerController["togglePinned"]();
                };
                DrawerHeaderComponent.$inject = ["$scope", "$element", "$timeout"];
                return DrawerHeaderComponent;
            })(BaseComponent);
            drawer.DrawerHeaderComponent = DrawerHeaderComponent;
        })(drawer = components.drawer || (components.drawer = {}));
    })(components = ers.components || (ers.components = {}));
})(ers || (ers = {}));



var ers;
(function (ers) {
    var components;
    (function (components) {
        var dropdown;
        (function (dropdown) {
                        angular.module("ers.components.dropdown", [
                "ers.bootstrap.dropdown"
            ]).directive("ersDropdownWrapper", function () {
                return {};
            });
            /**
            * @ngdoc directive
            * @module ers.components.dropdown
            * @scope
            * @data
            * @binding
            * @name ersDropdown
            * @constructor
            *
            * @description
            *
            * <p class="lead">Dropdown presents a menu of options to your users. It allows your users to
            * pass in any element type for your dropdown-toggle and dropdown-content.</p>
            *
            * - Dropdown consists of wrapper directive, which transforms your element into a dropdown.
            * - Dropdown consists of a toggle directive, allowing the dropdown to be toggled via click. This directive is optional.
            * - Dropdown consists of a content directive, allowing the content included to be shown in the dropdown.
            *
            * #### Usage
            *
            * Use the dropdown to show content to your users in a dropdown format on click.
            * This component is useful when you want the ability to make any type of element
            * serve as the toggle point or content for your dropdown.
            *
            * ### Examples
            *
            * #### Input Dropdown
            *
            * <code-editor identifier="example2" data-title="Input Dropdown"
            * html-content-url="demos/ersDropdown/inputDropdown/index.html"
            * js-content-url="demos/ersDropdown/inputDropdown/script.js"
            * css-content-url="demos/ersDropdown/inputDropdown/styles.css"
            * content-mode="html"></code-editor>
            *
            * #### Design Guidelines
            *
            * No design guidelines.
            *
            * #### Accessibility Guidelines
            *
            * No accessibility guidelines.
            *
            * @param {string} [auto-close=always] {@?}
            * Used on the <b>ers-dropdown</b> directive. Available options are always, disabled, outsideClick.
            * <b>always</b> automatically closes the dropdown when any of its elements are clicked,
            * <b>disabled</b> disables the auto close. You can control it
            * manually with is-open. It still gets closed if the toggle is clicked, esc is pressed or another dropdown is open,
            * <b>outsideClick</b> closes the dropdown automatically only when the user clicks any element outside
            * the dropdown.
            *
            * @param {boolean} [dropdown-append-to-body=false] {=?}
            * Used on the <b>ers-dropdown</b> directive.
            * Appends the inner dropdown-menu to the body element.
            *
            * @param {boolean} [is-open=false] {=?}
            * Used on the <b>ers-dropdown</b> directive.
            * Defines whether or not the dropdown-content is open. The <b>ers-dropdown-toggle</b> will toggle this attribute
            * on click.
            *
            * @param {boolean} [keyboard-nav=false] {=?}
            * Used on the <b>ers-dropdown</b> directive.
            * Enables the navigation of the dropdown list elements with the arrow keys.
            *
            * @param {function} [on-toggle(open)] {&?}
            * Used on the <b>ers-dropdown</b> directive.
            * An optional expression called when the dropdown content is opened or closed.
            *
            * @param {string} [openClass=open] {@?}
            * Class to apply when the dropdown is open.
            *
            *
            */
            var SimpleDropdownComponent = (function () {
                function SimpleDropdownComponent() {
                }
                return SimpleDropdownComponent;
            })();
            dropdown.SimpleDropdownComponent = SimpleDropdownComponent;
        })(dropdown = components.dropdown || (components.dropdown = {}));
    })(components = ers.components || (ers.components = {}));
})(ers || (ers = {}));



var ers;
(function (ers) {
    var components;
    (function (components) {
        var dropdownSelect;
        (function (dropdownSelect) {
                        angular.module("ers.components.dropdownSelect", [
                "ers.components.core"
            ]).directive("ersDropdownSelect", function () {
                return {
                    restrict: "E",
                    replace: true,
                    transclude: true,
                    templateUrl: function (element, attrs) {
                        if (attrs["dropdownSelectType"] === "grid") {
                            return "dropdown-select/template/dropdown-select-grid.html";
                        }
                        else {
                            return "dropdown-select/template/dropdown-select-standard.html";
                        }
                    },
                    scope: {
                        dropdownSelectType: "@?",
                        filterMode: "@?",
                        filterText: "@?",
                        filterTextChange: "&?",
                        gridColumnHeaders: "=?",
                        items: "=",
                        itemDisplayProperty: "@?",
                        multiSelect: "=?",
                        ngDisabled: "=?",
                        ngRequired: "=?",
                        ngChange: "&?",
                        ngModel: "=?",
                        noResultsMessage: "@?",
                        open: "=?",
                        placeholder: "@?",
                        showSelectedItem: "=?",
                        useSearchIcon: "=?"
                    },
                    bindToController: true,
                    controller: DropdownComponent,
                    controllerAs: "ctrl"
                };
            });
            /**
         * @ngdoc directive
         * @module ers.components.dropdownSelect
         * @scope
         * @transclude
         * @data
         * @binding
         * @name ersDropdownSelect
         * @restrict E
         * @constructor
         *
         * @description
         *
         * <p class="lead">Dropdown-Select presents a menu of options to your users.</p>
         *
         * - Dropdown-Select consists of a toggle element, an input or button, which opens and closes the dropdown.
         * - Dropdown-Select consists of a dropdown element, displaying the appropriate information in a table or list.
         * - Dropdown-Select input or button should be properly labeled to describe the information contained in the dropdown.
         *
         * #### Usage
         *
         * - By default, use an auto filter with a standard dropdown to present data in an unordered list and allow filtering of that data.
         * - Use a manual filter with a grid dropdown to present data organized in a table and be able to create your own filter.
         * - Turn filtering off to disable the filtering functionality and only allow toggling of the dropdown.
         * - You may combine any type of filter-mode and select-type. See below for different options available.
         *
         * ### Examples
         *
         * #### Auto Filter with Standard Dropdown
         *
         * Example of the default dropdown-select component, with "auto" filter and a "standard" dropdown.
         * Data is passed into the component with the "items" attribute.
         *
         * <code-editor identifier="example1" data-title="Auto Filter with Standard Dropdown"
         * html-content-url="demos/ersDropdownSelect/autoStandard/index.html"
         * js-content-url="demos/ersDropdownSelect/autoStandard/script.js"
         * css-content-url="demos/ersDropdownSelect/autoStandard/styles.css"
         * content-mode="html"></code-editor>
         *
         * #### Auto Filter with Standard Dropdown,  Multi-Select set to true
         * Example of the default drodpown-select component with "auto" filter and "standard" drodpown. Mulit-Select feature is active.
         * Data is passed into the component with the "items" attribute, the item containing "Jim" has been pre-selected
         * with ng-model.
         *
         * When the multi-select items are passed outside the component, they are passed in an array, you will want to be sure to loop through the
         * data in your HTML if you want to show the selected items. See the code snippet below for an example.
         *
         *
         * <code-editor identifier="example2" data-title="Auto Filter with Multi-Select"
         * html-content-url="demos/ersDropdownSelect/multiSelect/index.html"
         * js-content-url="demos/ersDropdownSelect/multiSelect/script.js"
         * css-content-url="demos/ersDropdownSelect/multiSelect/styles.css"
         * content-mode="html"></code-editor>
         *
         *
         * #### Filter Off with Standard Dropdown
         *
         * Example of the default dropdown-select component. "filter-mode" is set to "off", removing the
         * ability for the user to filter the items in the dropdown. A specific "placeholder" is specified,
         * and the selected item is passed outside of the component via "ng-change". "ng-model" must
         * be used with "ng-change" and allows you to pre-select an item by default, if you would like.
         * In this case, ng-model has been set to "Jim" and is shown as selected by default.
         *
         * <code-editor identifier="example3" data-title="Filter Off with Standard Dropdown"
         * html-content-url="demos/ersDropdownSelect/noFilterStandard/index.html"
         * js-content-url="demos/ersDropdownSelect/noFilterStandard/script.js"
         * css-content-url="demos/ersDropdownSelect/noFilterStandard/styles.css"
         * content-mode="html"></code-editor>
         *
         *
         * #### Auto Filter with Grid Dropdown
         *
         * Example of a default "auto" filter, with a "grid" dropdown. The "items" and "grid-column-headers" to use in our table are specified.
         * A custom "placeholder" message, and the selected item is passed outside of the component via "ng-change".
         * "ng-model" must be used with "ng-change" and allows you to pre-select an item by default, if you would like.
         * In this case, ng-model has been set to "Jim" and is shown as selected by default.
         *
         *
         * <code-editor identifier="example4" data-title="Auto Filter with Grid Dropdown"
         * html-content-url="demos/ersDropdownSelect/autoGrid/index.html"
         * js-content-url="demos/ersDropdownSelect/autoGrid/script.js"
         * css-content-url="demos/ersDropdownSelect/autoGrid/styles.css"
         * content-mode="html"></code-editor>
         *
         * #### Auto Filter with Grid Dropdown DISABLED
         *
         * Example of a disabled dropdown-select with default, "auto" filtering. The "ng-disabled" attribute has been
         * to true, removing the ability for the user to toggle the dropdown open and closed.
         *
         * <code-editor identifier="example5" data-title="Disabled Auto Filter with Grid Dropdown"
         * html-content-url="demos/ersDropdownSelect/disabledAutoGrid/index.html"
         * js-content-url="demos/ersDropdownSelect/disabledAutoGrid/script.js"
         * css-content-url="demos/ersDropdownSelect/disabledAutoGrid/styles.css"
         * content-mode="html"></code-editor>
         *
         * #### Filter Off with Grid Dropdown DISABLED
         *
         * Example of a disabled dropdown-select, with "filter-mode" set to "off". The "ng-disabled" attribute
         * has been set to true, removing the ability for the user to toggle the dropdown open and closed.
         *
         * <code-editor identifier="example6" data-title="Disabled Filter Off with Grid Dropdown"
         * html-content-url="demos/ersDropdownSelect/disablednoFilterGrid/index.html"
         * js-content-url="demos/ersDropdownSelect/disablednoFilterGrid/script.js"
         * css-content-url="demos/ersDropdownSelect/disablednoFilterGrid/styles.css"
         * content-mode="html"></code-editor>
         *
         * #### Manual Filter with Grid Dropdown
         *
         * Example of a dropdown-select with a "manual" filter and "grid" dropdown. The "items" and "grid-column-headers" to be used are
         * specified as well. The selected item is passed outside of the component via "ng-change". "ng-model" must
         * be used with "ng-change" and allows you to pre-select an item by default, if you would like.
         * In this case, ng-model has been set to "Jim" and is shown as selected by default.
         * The "search" icon is used over the default "angle-down/ angle-up" icons.
         *
         * When filter mode is set to "manual", you need to pass the text outside of the component via "filter-text-change". This allows
         * you to pass the text to your own custom filter. The filtered rows then need to be passed into the
         * "items" attribute.
         *
         * <code-editor identifier="example7" data-title="Manual Filter with Grid Dropdown"
         * html-content-url="demos/ersDropdownSelect/manualGrid/index.html"
         * js-content-url="demos/ersDropdownSelect/manualGrid/script.js"
         * css-content-url="demos/ersDropdownSelect/manualGrid/styles.css"
         * content-mode="html"></code-editor>
         *
         *
         * #### Design Guidelines
         *
         * No design guidelines.
         *
         * #### Accessibility Guidelines
         *
         * No accessibility guidelines.
         *
         * @param {string} [dropdown-select-type=standard] {@?}
         * Available options are standard and grid. <b>Standard</b> shows your items in a basic unordered list,
         * while the <b>grid</b> shows your items in table format.
         *
         * @param {string} [no-results-message=No Results] {@?}
         * Provide a custom message when there are no matching filtered search results.
         *
         * @param {string} [filter-mode=auto] {@?}
         * Available options are  auto, manual, or off. <b>Auto</b> and <b>manual</b> filtering provides an input for the user to filter
         * your items, as well as open/close the dropdown. While setting filter-mode to <b>off</b> removes filtering functionality
         * and shows a button as the element to open/close the dropdown.
         *
         * @param {function} [filter-text-change=not active] {&?}
         * Used with the <b>manual</b> filter, this passes the user typed text outside of the function so that
         * it can be custom filtered. You must use <b>text</b> as the parameter for your function that
         * serves as the value for this attribute.
         *
         * @param {string} [filter-text=none] {@?}
         * If you would like to filter your dropdown data in a specific way by default you can use this attribute to pass in a string of
         * text that will then filter the data. If you pass in both a filter-text and pre-select an item via the ng-model attribute.
         * Your input will show the filter-text and the dropdown list will be filtered accordingly, but the preselected row you have
         * selected with ng-model will also be showing as selected.
         *
         * @param {array} [grid-column-headers=none] {=?}
         * Specify the table headers you would like in the grid dropdown. This attribute must be included with the grid.
         * You may include as many <b>grid-column-headers</b> as you would like.
         *
         * @param {array} [items=none] {=}
         * Specify the data you would like to include in the dropdown. This should contain an array of objects.
         * You may include as many <b>items</b> of data as you would like.
         *
         * @param {string} [item-display-property=name] {=?}
         * Set this attribute to determine the property of your data you would like to display in the
         * <b>Standard</b> drodpown. This attribute also determines the property that displays as the button label or
         * input placeholder upon item selection.
         *
         * @param {boolean} [multi-select=false] {=?}
         * Set this attribute with the value of true if you would the user to have the option to select multiple rows in the
         * dropdown.
         *
         * @param {boolean} [ng-disabled=false] {=?}
         * Set this attribute to <b>true</b> to remove the ability to toggle the dropdown open and closed. The dropdown is always
         * closed when <b>ng-disabled</b> to set to <b>true</b>, even if you have set <b>open</b> to <b>true</b> as well.
         *
         * @param {function} [ng-change=not active] {&?}
         * Pass the selected row of data, in the dropdown, outside of the component when selected. You must use <b>itemSelected</b> as
         * the parameter for the function that serves as the value for this attribute.
         *
         * @param {object} [ng-model=none] {=?}
         * Specify a row to be pre-selected in your dropdown by default.
         *
         * @param {boolean} [open=false] {=?}
         * Set this attribute to <b>true</b> to open the dropdown by default (on page load).
         *
         * @param {string} [placeholder=Select] {@?}
         * Specify the button label, or input placeholder. This should properly describe the data
         * you have included in the items attribute for the dropdown.
         *
         * @param {boolean} [show-selected-item=false] {=?}
         * Remove the specified <b>item-display-property</b> from being set inside the <b>auto</b> or
         * <b>manual</b> filter input element when set to <b>false</b>.
         *
         * @param {boolean} [use-search-icon=false] {=?}
         * Override the default 'angle-down' icon shown in the input element with the 'search' icon.
         * This is only available when filter-mode is set to <b>auto</b> or <b>manual</b> as the input element must be present.
         *
         *
         */
            var DropdownComponent = (function () {
                function DropdownComponent($scope, $document, $attrs, $element, $filter) {
                    this.currentIndex = -1;
                    this.firstManualRun = true;
                    this.$scope = $scope;
                    this.$document = $document;
                    this.$attrs = $attrs;
                    this.$element = $element;
                    this.$filter = $filter;
                    // if ngModel is not used, make sure it is set to null so the "clearSelection" icon doesn't show if ngModel isn't used
                    if (!this.ngModel) {
                        this.ngModel = null;
                    }
                    // set defaults if nothing is passed into isolate scope
                    this.dropdownSelectType = angular.isDefined(this.dropdownSelectType) ? this.dropdownSelectType : "standard";
                    this.filterMode = angular.isDefined(this.filterMode) ? this.filterMode : "auto";
                    this.itemDisplayProperty = angular.isDefined(this.itemDisplayProperty) ? this.itemDisplayProperty : "name";
                    this.noResultsMessage = angular.isDefined(this.noResultsMessage) ? this.noResultsMessage : "No Results";
                    this.placeholder = angular.isDefined(this.placeholder) ? this.placeholder : "Select";
                    this.filteredItems = this.items;
                    this.selectedItems = [];
                    this.firstRun = true;
                    this.initialNgModel = this.ngModel;
                    // save the initial items when manual filter is used so the drodpown can be reset once a selection has been made 
                    if (this.filterMode === "manual" && this.firstManualRun) {
                        this.staticItems = this.items;
                        this.firstManualRun = false;
                    }
                    // compare either single select or multiple select rows and return true or false back to the template
                    this.checkEquality = function (param1, param2) {
                        if (Array.isArray(param2) && param2 !== null) {
                            for (var i = 0; i < param2.length; i++) {
                                if (angular.equals(param1, param2[i])) {
                                    return angular.equals(param1, param2[i]);
                                }
                            }
                            ;
                        }
                        else {
                            return angular.equals(param1, param2);
                        }
                    };
                    // check to see if there is a filterText, if there is use that, otherwise set the input value 
                    // to that of the ngModel or placeholder
                    // watching the ngModel to update the input element for filtering 
                    // if a new ngModel value is selected from an outside component (i.e. ComboBox as done in Test API)
                    var ctrl = this;
                    if (!ctrl.multiSelect) {
                        this.$scope.$watch("ctrl.ngModel", function (newValue, oldValue) {
                            if (ctrl.showSelectedItem !== false) {
                                if (ctrl.filterText) {
                                    if (ctrl.filterMode === "auto" || ctrl.filterMode === "manual") {
                                        ctrl.ngModelValue = ctrl.filterText;
                                        ctrl.filteredItems = ctrl.$filter("filter")(ctrl.items, (_a = {}, _a[ctrl.itemDisplayProperty] = ctrl.filterText, _a));
                                    }
                                }
                                else {
                                    if (ctrl.ngModel) {
                                        ctrl.ngModelValue = ctrl.ngModel[ctrl.itemDisplayProperty];
                                    }
                                    else {
                                        ctrl.placeholder = ctrl.placeholder; // filerText or ngModel wasn't used, so set the input to the placeholder value
                                    }
                                }
                            }
                            var _a;
                        });
                    }
                    else if (ctrl.multiSelect) {
                        if (ctrl.showSelectedItem !== false) {
                            if (ctrl.filterText) {
                                if (ctrl.filterMode === "auto" || ctrl.filterMode === "manual") {
                                    ctrl.ngModelValue = ctrl.filterText;
                                    ctrl.filteredItems = ctrl.$filter("filter")(ctrl.items, (_a = {}, _a[ctrl.itemDisplayProperty] = ctrl.filterText, _a));
                                }
                            }
                            else {
                                if (ctrl.ngModel) {
                                    ctrl.ngModelValue = ctrl.ngModel[ctrl.itemDisplayProperty];
                                }
                                else {
                                    ctrl.placeholder = ctrl.placeholder; // filerText or ngModel wasn't used, so set the input to the placeholder value
                                }
                            }
                        }
                    }
                    // watch for changes on the filtered list if it is not the initialization of the watch
                    this.$scope.$watch("ctrl.items.length", function (newValue, oldValue) {
                        if (newValue !== oldValue) {
                            if (ctrl.filterMode === "auto") {
                                ctrl.filteredItems = ctrl.$filter("filter")(ctrl.items, ctrl.ngModelValue);
                            }
                            else {
                                ctrl.filteredItems = ctrl.items;
                            }
                        }
                    });
                    var _a;
                }
                // sort the items of data that are passed in, items become unordered if not sorted
                DropdownComponent.prototype.sort = function (row) {
                    var sortedValues = [];
                    var info;
                    for (var i = 0; i < this["gridColumnHeaders"].length; i++) {
                        info = this["gridColumnHeaders"][i].toLowerCase();
                        sortedValues.push(row[info]);
                    }
                    return sortedValues;
                };
                // pass the selected row 
                DropdownComponent.prototype.onSelectedLocal = function (row, $event) {
                    if (this.multiSelect && row) {
                        this.setFocusedRow(-1);
                        var result;
                        var i;
                        // if the filterMode has been set to manual and multiSelect is true then we need to store the item chosen if the list has been filtered 
                        // as the unfiltered list of items and the filtered list are two different sets of data. 
                        // staticItems holds the initial set of data before the manual filter creates a new set of items
                        if (this.filterMode === "manual" && this.multiSelect && this.staticItems) {
                            if (this.filteredItems !== this.staticItems && !this.filterText) {
                                this.ngModelValue = "";
                                this.filteredSelection = row;
                                if (this.firstRun && this.initialNgModel && this.ngModel !== null) {
                                    this.firstRun = false;
                                    this.selectedItems.push(this.ngModel);
                                }
                                this.selectedItems.push(row);
                                this.ngModel = this.selectedItems;
                                this.filteredItems = this.staticItems;
                                // update the selectedItems and set ngModelValue for the input element
                                for (i = 0; i < this.selectedItems.length; i++) {
                                    if (this.selectedItems.length > 1) {
                                        this.ngModelValue += this.selectedItems[i][this.itemDisplayProperty] + " ";
                                    }
                                    else {
                                        this.ngModelValue += this.selectedItems[i][this.itemDisplayProperty];
                                    }
                                }
                                return;
                            }
                            else if (this.filteredSelection) {
                                result = angular.equals(row, this.filteredSelection);
                            }
                        }
                        // the selected row is not currently a selected item, add it here
                        // if the ngModel and the selected row are the same then remove it below
                        if (!result && this.selectedItems.indexOf(row) === -1 && !angular.equals(this.initialNgModel, row)) {
                            this.ngModelValue = ""; // clear the ngModelValue, it gets updated in the loop below
                            this.filterText = ""; // clear the originally set filterText
                            for (i = 0; i < this.filteredItems.length; i++) {
                                if (this.filteredItems[i] === row) {
                                    // if its the first time running this function and the intialModel is not null or false, then
                                    // the user has selected a row other then the initialNgModel and we want to push that pre-selected
                                    // row into the selectedItems array so that it keeps the active class along with other selections
                                    if (this.firstRun && this.initialNgModel && this.ngModel !== null) {
                                        this.firstRun = false;
                                        this.selectedItems.push(this.ngModel);
                                    }
                                    this.selectedItems.push(row);
                                }
                            }
                        }
                        else {
                            // the selected row has been clicked on again, remove it from the array and remove the 'active' class from that row
                            this.ngModelValue = ""; // clear the ngModelValue, it gets updated in the loop below
                            var index = this.selectedItems.indexOf(row);
                            // the initialNgModel is set in the constructor, this will remove the pre-selected row based on ng-model
                            // this would run only if the user clicked to de-select the pre-selected ng-model row.
                            if (angular.equals(this.initialNgModel, row)) {
                                this.selectedItems.splice(row, 1);
                                this.initialNgModel = null;
                                this.firstRun = false;
                            }
                            else if (index > -1) {
                                this.selectedItems.splice(index, 1);
                            }
                            else if (result === true) {
                                this.selectedItems.splice(this.filteredSelection, 1);
                                result = false;
                                this.filteredSelection = null;
                            }
                        }
                        // update the selectedItems and set ngModelValue for the input element
                        for (var j = 0; j < this.selectedItems.length; j++) {
                            if (this.selectedItems.length > 1) {
                                this.ngModelValue += this.selectedItems[j][this.itemDisplayProperty] + " ";
                            }
                            else {
                                this.ngModelValue += this.selectedItems[j][this.itemDisplayProperty];
                            }
                        }
                        // if selectedItems is empty, set ngModel to null which removes the removeSelectionIcon or
                        // if not empty update ngModel to equal the selectedItems array, ngModel gets passed to the 
                        // checkGroupEquality function looking for equal rows
                        if (this.selectedItems.length <= 0) {
                            this.ngModel = null;
                        }
                        else {
                            this.ngModel = this.selectedItems;
                        }
                        // pass all selectedRows out of the component
                        if (this.ngChange) {
                            this.ngChange({ itemSelected: this.selectedItems });
                        }
                        // if the row was selected with the space bar, set the filteredItems back to original items 
                        // so if the dropdown was filtered it opens back up
                        if (row || $event["keyCode"] === 32) {
                            if (this.filterMode === "manual" && this.staticItems) {
                                // reset filteredItems back to initial items, need to hold the initial value because manual filter creates a new list of items
                                this.filteredItems = this.staticItems;
                            }
                            else {
                                this.filteredItems = this.items;
                            }
                        }
                        ;
                        // we need to make sure the click event of selecting an item in the dropdown stops here 
                        // otherwise it will run into the resetInput function below and not show the selected 
                        // city in the input element when filterText is used
                        $event.preventDefault();
                        $event.stopPropagation();
                    }
                    else {
                        if (row) {
                            this.setFocusedRow(-1);
                            this.filterText = "";
                            this.ngModel = row;
                            this.ngModelValue = (this.showSelectedItem === false) ? "" : row[this.itemDisplayProperty];
                            // pass the selected item out of the component
                            if (this.ngChange) {
                                this.ngChange({ itemSelected: row });
                            }
                            if (this.filterMode === "manual" && this.staticItems) {
                                // reset filteredItems back to initial items, need to hold the initial value because manual filter creates a new list of items
                                this.filteredItems = this.staticItems;
                            }
                            else {
                                this.filteredItems = this.items;
                            }
                            this.closeDropdown();
                            // we need to make sure the click event of selecting an item in the dropdown stops here 
                            // otherwise it will run into the resetInput function below and not show the selected
                            // city in the input element when filterText is used
                            $event.preventDefault();
                            $event.stopPropagation();
                        }
                    }
                };
                // called on the ng-blur event, allows for escape keyboard functionality
                // when called it either replace the input or button with the placeholder or the current selection property name
                // it also clears all filter text and closes the dropdown
                DropdownComponent.prototype.resetInput = function () {
                    this.setFocusedRow(-1);
                    // if there is no current filterText or ngModel (selection has been removed), 
                    // set the input to the placeholder by clearing the input
                    if (this.filterText === null && this.ngModel === null) {
                        this.ngModelValue = "";
                    }
                    if (this.filterMode === "manual" && this.multiSelect && this.staticItems) {
                        // reset filteredItems back to initial items, need to hold the initial value because manual filter creates a new list of items
                        this.filteredItems = this.staticItems;
                    }
                    else {
                        this.filteredItems = this.items;
                    }
                    // keep the drodpown open on a selection if multiselect is set and the data has been filtered
                    if (!this.multiSelect) {
                        this.closeDropdown();
                    }
                };
                // resets the input when the backspace key is used, this reset does not close the 
                // dropdown when called as does with resetInput above.
                DropdownComponent.prototype.backspacePressedResetInput = function () {
                    this.ngModel = null;
                    this.setFocusedRow(-1);
                    if (this.filterText === null && this.ngModel === null) {
                        this.ngModelValue = "";
                    }
                };
                // set the currently focused row
                DropdownComponent.prototype.setFocusedRow = function (index) {
                    this.currentIndex = index;
                    if (this.currentIndex >= 0 && this.currentIndex < this.filteredItems.length) {
                        this.focusedRow = this.filteredItems[this.currentIndex];
                    }
                    else {
                        this.focusedRow = undefined;
                    }
                };
                // keyboard toggling of the list 
                DropdownComponent.prototype.onKeyboardPressed = function ($event) {
                    this.event = $event;
                    var keyCodes = {
                        BACKSPACE: 8,
                        TAB: 9,
                        RETURNKEY: 13,
                        ESCAPE: 27,
                        SPACEBAR: 32,
                        UPARROW: 38,
                        DOWNARROW: 40,
                        PAGEDOWN: 34
                    };
                    switch ($event["keyCode"]) {
                        case keyCodes.BACKSPACE:
                            if (this.multiSelect) {
                                var i;
                                var j;
                                var text;
                                var currentSelections = [];
                                // this works for Chrome inside an input or textarea but not for IE or Firefox
                                // text = window.getSelection().toString(); 
                                // this works for Chrome and Firefox
                                var input = document.getElementById("inputElement");
                                var start = input["selectionStart"];
                                var end = input["selectionEnd"];
                                text = input["value"].substring(start, end);
                                // if the user has selected text, turn that string into an array and push into a new array so that we remove spaces from the array
                                if (text) {
                                    var selections = text.split(" ");
                                    for (i = 0; i < selections.length; i++) {
                                        if (selections[i] !== "") {
                                            currentSelections.push(selections[i]);
                                        }
                                    }
                                    // if the user selects and deletes the initialNgModel value before clicking in the dropdown this will run
                                    // and remove the initialNgModel
                                    if (this.initialNgModel) {
                                        if (this.initialNgModel[this.itemDisplayProperty] === currentSelections[0]) {
                                            this.initialNgModel = null;
                                        }
                                    }
                                    // compare the selectedItems array filled in onSelectedLocal to the currentSelections highlighted
                                    // if they match then remove them from the array
                                    for (i = 0; i < this.selectedItems.length; i++) {
                                        for (j = 0; j < currentSelections.length; j++) {
                                            if (this.selectedItems[i][this.itemDisplayProperty] === currentSelections[j]) {
                                                this.selectedItems.splice(i, 1);
                                            }
                                        }
                                    }
                                    // update the items below based on the user deletion
                                    this.ngModelValue = "";
                                    this.ngModel = this.selectedItems;
                                    for (i = 0; i < this.selectedItems.length; i++) {
                                        this.ngModelValue += this.selectedItems[i][this.itemDisplayProperty] + " ";
                                    }
                                }
                                else {
                                    // removes one selectedItem at a time
                                    for (i = this.ngModelValue.length - 1; i >= 0; i--) {
                                        if (this.ngModelValue[i] !== " ") {
                                            this.selectedItems.pop();
                                            this.ngModelValue = "";
                                            if (this.selectedItems.length === 0) {
                                                this.ngModel = null;
                                                this.initialNgModel = null;
                                                if (this.filterMode === "manual" && this.staticItems) {
                                                    // reset filteredItems back to initial items, need to hold the initial value because manual filter creates a new list of items
                                                    this.filteredItems = this.staticItems;
                                                }
                                                else {
                                                    this.filteredItems = this.items;
                                                }
                                            }
                                            else {
                                                this.ngModel = this.selectedItems;
                                            }
                                            // update the ngModelValue
                                            for (j = 0; j < this.selectedItems.length; j++) {
                                                this.ngModelValue += this.selectedItems[j][this.itemDisplayProperty] + " ";
                                            }
                                        }
                                        break;
                                    }
                                }
                            }
                            else if (this.ngModelValue.length - 1 === 0) {
                                this.backspacePressedResetInput();
                            }
                            else if (this.ngModelValue.length - this.ngModelValue.length === 0) {
                                this.backspacePressedResetInput();
                            }
                            break;
                        case keyCodes.ESCAPE:
                            this.resetInput();
                            $event.preventDefault();
                            break;
                        case keyCodes.PAGEDOWN:
                            this.resetInput();
                            $event.preventDefault();
                            break;
                        case keyCodes.TAB:
                            this.resetInput();
                            $event.preventDefault();
                            break;
                        case keyCodes.UPARROW:
                            this.currentIndex--;
                            if (this.currentIndex < 0) {
                                this.currentIndex = this.filteredItems.length - 1;
                            }
                            this.setFocusedRow(this.currentIndex);
                            $event.preventDefault();
                            break;
                        case keyCodes.DOWNARROW:
                            this.currentIndex++;
                            if (this.currentIndex > this.filteredItems.length - 1) {
                                this.currentIndex = 0;
                            }
                            this.setFocusedRow(this.currentIndex);
                            $event.preventDefault();
                            break;
                        case keyCodes.SPACEBAR:
                            this.onSelectedLocal(this.filteredItems[this.currentIndex], $event);
                            // don't prevent default here, doing that in onSelectedLocal;
                            // if included here space bar doesn't work for spacing
                            break;
                        case keyCodes.RETURNKEY:
                            this.onSelectedLocal(this.filteredItems[this.currentIndex], $event);
                            // if multi-select is active, and the user filters and then hits enter to make a selection
                            // open the dropdown back to its initial state because the dropdown isn't going to close
                            // when multi-select is active
                            if (this.filterMode === "manual" && this.staticItems) {
                                // reset filteredItems back to initial items, need to hold the initial value because manual filter creates a new list of items
                                this.filteredItems = this.staticItems;
                            }
                            else {
                                this.filteredItems = this.items;
                            }
                            $event.preventDefault();
                            break;
                    }
                };
                // filter the drodpown data
                DropdownComponent.prototype.filterTextChangeLocal = function ($event) {
                    // filter the text if the component is a multi-select and the backspace button was not pressed
                    // $event.which used for IE so that when a user selects a multiSelect row the drodpown does not filter rows
                    if (this.multiSelect && this.event["keyCode"] !== 8 && this.event["which"] !== 13) {
                        this.setFocusedRow(-1);
                        if (this.filterMode === "auto" && this.dropdownSelectType === "standard") {
                            this.filteredItems = this.$filter("filter")(this.items, (_a = {}, _a[this.itemDisplayProperty] = this.ngModelValue, _a));
                        }
                        else if (this.filterMode === "auto" && this.dropdownSelectType === "grid") {
                            this.filteredItems = this.$filter("filter")(this.items, this.ngModelValue);
                        }
                        else if (this.filterMode === "manual") {
                            this.filterTextChange({ text: this.ngModelValue });
                        }
                        ;
                    }
                    else if (!this.multiSelect) {
                        this.setFocusedRow(-1);
                        if (this.filterMode === "auto" && this.dropdownSelectType === "standard") {
                            this.filteredItems = this.$filter("filter")(this.items, (_b = {}, _b[this.itemDisplayProperty] = this.ngModelValue, _b));
                        }
                        else if (this.filterMode === "auto" && this.dropdownSelectType === "grid") {
                            this.filteredItems = this.$filter("filter")(this.items, this.ngModelValue);
                        }
                        else if (this.filterMode === "manual") {
                            this.filterTextChange({ text: this.ngModelValue });
                        }
                        ;
                    }
                    var _a, _b;
                };
                // toggle the dropdown when theinput or button element is clicked
                DropdownComponent.prototype.toggleDropdown = function ($event) {
                    // don't toggle the open variable as it causes the chevron icon to alter, return if disabled
                    if (this.ngDisabled) {
                        return;
                    }
                    // $event.stopPropagation(); //Remove this after target fix
                    if (!this.open) {
                        this.openDropdown($event);
                    }
                    else {
                        this.closeDropdown();
                    }
                };
                DropdownComponent.prototype.clearSelection = function ($event) {
                    this.setFocusedRow(-1);
                    this.ngModel = null;
                    this.initialNgModel = null;
                    this.ngModelValue = "";
                    this.selectedItems = [];
                    // pass the cleared selection outside of the component
                    if (this.ngChange) {
                        this.ngChange({ itemSelected: "" });
                    }
                    if (this.filterMode === "manual" && this.staticItems) {
                        // reset filteredItems back to initial items, need to hold the initial value because manual filter creates a new list of items
                        this.filteredItems = this.staticItems;
                    }
                    else {
                        this.filteredItems = this.items;
                    }
                    this.closeDropdown();
                    $event.preventDefault();
                    $event.stopPropagation();
                };
                // close the dropdown
                DropdownComponent.prototype.closeDropdown = function () {
                    var ctrl = this;
                    if (ctrl.open) {
                        ctrl.open = false;
                        ctrl.$document.unbind("click", this.closeDropdown);
                    }
                };
                // open the dropdown
                DropdownComponent.prototype.openDropdown = function ($event) {
                    // $event.stopPropagation(); //Remove this after target fix    
                    var ctrl = this;
                    if (!ctrl.open) {
                        ctrl.$document.bind("click", function ($event) {
                            var isChild = $(ctrl.$element).has($event["target"]).length > 0;
                            var isSelf = ctrl.$element[0] === $event["target"];
                            if (!isChild && !isSelf) {
                                ctrl.$scope.$apply(function () {
                                    ctrl.closeDropdown();
                                });
                            }
                        });
                        ctrl.open = true;
                    }
                };
                DropdownComponent.$inject = ["$scope", "$document", "$attrs", "$element", "$filter"];
                return DropdownComponent;
            })();
            dropdownSelect.DropdownComponent = DropdownComponent;
        })(dropdownSelect = components.dropdownSelect || (components.dropdownSelect = {}));
    })(components = ers.components || (ers.components = {}));
})(ers || (ers = {}));/*
 * Created by bertheto on 06/04/2015.
 */

angular.module("ers.components.file", ["ers.components.core"]);/*
 * Created by bertheto on 06/16/2015.
 */
/*
 * Created by bertheto on 06/16/2015.
 */
/*
 * Created by bertheto on 06/16/2015.
 */
/*
 * Created by bertheto on 06/16/2015.
 */

/*
 * Created by bertheto on 06/16/2015.
 */





var ers;
(function (ers) {
    var components;
    (function (components) {
        var file;
        (function (file) {
            /**
             * FileItem class: A file wrapper to manage file operations, upload, and selection.
             */
            var FileItem = (function () {
                /**
                 * @constructor
                 * @param pFile The file.
                 */
                function FileItem(pFile) {
                    this.file = pFile;
                }
                /**
                 * Inner callback before upload begins.
                 */
                FileItem.prototype._onBeforeUpload = function () {
                    this.isReadyToUpload = true;
                    this.isUploading = true;
                    this.isUploaded = false;
                    this.isUploadSuccess = false;
                    this.isUploadCanceled = false;
                    this.isUploadError = false;
                    this.uploadProgress = 0;
                    //  this.onBeforeUpload();
                };
                /**
                 * Inner callback progress during the upload.
                 * @param pProgress The upload progress.
                 * @private
                 */
                FileItem.prototype._onUploadProgress = function (progress) {
                    this.uploadProgress = progress;
                    //  this.onProgress(uploadProgress);
                };
                /**
                 * Inner callback when the upload is successful.
                 * @param {string} response The response.
                 * @param {number} status The response status.
                 * @param {{}} headers The headers.
                 * @private
                 */
                FileItem.prototype._onUploadSuccess = function (response, status, headers) {
                    this.isReadyToUpload = false;
                    this.isUploading = false;
                    this.isUploaded = true;
                    this.isUploadSuccess = true;
                    this.isUploadCanceled = false;
                    this.isUploadError = false;
                    this.uploadProgress = 100;
                    //   this.onSuccess(response, status, headers);
                };
                /**
                 * Inner callback when an upload error occurs.
                 * @param {string} response The response.
                 * @param {number} status The status response.
                 * @param {{}} headers The headers.
                 * @private
                 */
                FileItem.prototype._onUploadError = function (response, status, headers) {
                    this.isReadyToUpload = false;
                    this.isUploading = false;
                    this.isUploaded = true;
                    this.isUploadSuccess = false;
                    this.isUploadCanceled = false;
                    this.isUploadError = true;
                    //this.uploadProgress = 0;
                    //   this.onError(response, status, headers);
                };
                /**
                 * Inner callback when the upload is canceled,.
                 * @param {string} response The response
                 * @param {number} status The status response
                 * @param {{}} headers The headers
                 * @private
                 */
                FileItem.prototype._onUploadCancel = function (response, status, headers) {
                    this.isReadyToUpload = false;
                    this.isUploading = false;
                    this.isUploaded = false;
                    this.isUploadSuccess = false;
                    this.isUploadCanceled = true;
                    this.isUploadError = false;
                    this.uploadProgress = 0;
                    // this.onCancel(response, status, headers);
                };
                /**
                 * Inner callback when the upload completes successfully.
                 * @param {string} response The response
                 * @param {number} status The status response
                 * @param {{}} headers The headers
                 * @private
                 */
                FileItem.prototype._onUploadComplete = function (response, status, headers) {
                    //  this.onComplete(response, status, headers);
                    //  if (this.removeAfterUpload) this.remove();
                };
                /**
                 * The destroy phase call.
                 */
                FileItem.prototype.destroy = function () {
                    // nothing
                };
                /**
                 * Preparing the file to be uploaded.
                 */
                FileItem.prototype.prepareToUploading = function () {
                    this.isReadyToUpload = true;
                };
                /**
                 * Cancelling or aborting the upload.
                 */
                FileItem.prototype.abortUpload = function () {
                    if (this.xhrTransport) {
                        this.xhrTransport.abort();
                    }
                };
                /**
                 * @return True, if the upload has started.
                 */
                FileItem.prototype.uploadHasBegun = function () {
                    return this.isUploading || this.isUploadCanceled || this.isUploadError || this.isUploadSuccess || this.isUploaded;
                };
                return FileItem;
            })();
            file.FileItem = FileItem;
        })(file = components.file || (components.file = {}));
    })(components = ers.components || (ers.components = {}));
})(ers || (ers = {}));/*
 * Created by bertheto on 06/16/2015.
 */
/*
 * Created by bertheto on 06/16/2015.
 */

/*
 * Created by bertheto on 06/04/2015.
 */










var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};

var ers;
(function (ers) {
    var components;
    (function (components) {
        var file;
        (function (file_1) {
                        var BaseComponent = ers.components.core.BaseComponent;
            /**
             * @ngdoc directive
             * @module ers.components.file
             * @name ersFile
             * @restrict E
             * @scope
             * @description
             *
             * The `ers-file` component allows you to choose and manage one or more files.
             *
             * ### Usage
             *
             * - The user can select files two ways:
             *  - Browse to and select the file.
             *  - Click to select, drag, and then drop the file or files in drop zone.
             * - After completing the selection, you can add to or remove files from the selection before uploading.
             * - You can configure the file selector to filter according to:
             *  - Extension
             *  - Type (including wildcards)
             *  - Size
             *  - Number of files
             *  - User-created custom filter
             * - Each filter, including user-created filters, is a promise that is resolved if the file is not rejected.
             * - When errors occur, a callback prompts a dialog allowing you to fix the error.
             * - All user-created filters can be saved for future use.
             * - Upload is an optional action button that begins the upload and provides a progress indicator bar for each
             * file.
             * - As the selected file or files are uploaded, the ers-file component displays a progress bar. The user
             * can abort any specific file upload by dismissing that progress bar.
             *
             * ### Examples
             *
             * Filters used in the following example:
             *
             * - multiple="true"
             * - max-files="10"
             * - extensions="['jpg','pdf']"
             * - max-size="5"
             *
             * <code-editor identifier="example1" data-title="Context Menu" html-content-url="demos/ersFile/basicUsage/index.html"
             * js-content-url="demos/ersFile/basicUsage/script.js" css-content-url="demos/ersFile/basicUsage/styles.css"
             * content-mode="html"></code-editor>
             *
             * ### Design Guidelines
             *
             * - The component currently has only one style, but can be themed using standard CSS.
             *
             * ### Accessibility Guidelines
             *
             * No accessibility guidelines.
             *
             * @param {string} [ID] {@}
             * Sets the component ID.
             * ```xml
             * <ers-file id="myId"/>
             * ```
             *
             * @param {string} [selection] {=}
             * Displays the currently selected file or files.
             * ```xml
             * <ers-file selection="ctrl.selection"/>
             * ```
             *
             * @param {boolean} [multiple=true] {=?}
             * Defines whether to allow multiple file selection. The options are on (true), or off (false).
             * ```xml
             * <ers-file multiple="ctrl.multiple"/>
             * ```
             * @param {number} [max-files]  {@?}
             * Sets the maximum number of selected files.
             *
             *
             *
             * ```xml
             *
             * <ers-file max-files="ctrl.maxSize"/>
             * ```
             *
             *
             *
             *
             * @param {number} [max-size]  {@?}
             * Sets the maximum file size allowed.
             *  ```xml
             * <ers-file max-files="ctrl.maxSize"/>
             * ```
             *
             * @param {string} [filters]  {=?}
             * Sets the custom filter or filters array, allowing you to create and save custom
             * filters to the existing filter set.
             *  ```xml
             * <ers-file filters="ctrl.filters"/>
             * ```
             *
             * @param {boolean} [types]  {=?}
             * Sets the files types allowed for upload selection in the `typeFilter` attribute.
             * *For example*, null, "image.*", "audio.*", ".*vnd.ms-excel", ".*jpeg", or "".
             * ```xml
             * <ers-file types="ctrl.types"/>
             * ```
             *
             * @param {boolean} [extensions]  {=?}
             * Sets the file extensions allowed for upload selection in the `ExtensionFilter` attribute.
             * *For example*, null, "jpg", "csv", "mp3", "txt", or "json".
             * ```xml
             * <ers-file extensions="ctrl.extensions"/>
             * ```
             *
             * @param {expression} [on-when-adding-file-failed] {&?}
             * Sets the callback function that is notified when a filter error occurs. The function
             * signature must be: `functionName(errors:ISelectFileError[])`.
             * ```xml
             * <ers-file on-when-adding-file-failed="ctrl.functionName(errors)"/>
             * ```
             *
             * @param {expression} [on-adding-files] {&?}
             * Sets the callback function that is notified when files are selected.
             * The function signature must be: `functionName(files:FileList[])`.
             *  ```xml
             * <ers-file on-adding-files="ctrl.onAddingFiles(files)"/>
             * ```
             *
             * @param {boolean} [all-errors-together=true] {=?}
             * Sets error notification. When set to true, all filter errors are sent together. When set to false,
             * the error messages
             * are sent individually. All error messages are sent via the `onWhenAddingFileFailed` function.
             * ```xml
             * <ers-file on-when-adding-file-failed="ctrl.functionName(errors)"/>
             * ```
             *
             * @param {string} [selection-input-place-holder-text] {@?}
             * Sets the selection input place-holder text.
             *  ```xml
             * <ers-file selection-input-place-holder-text="ctrl.selectionInputPlaceHolderText"/>
             * ```
             *
             *  @param {string} [instruction-text] {@?}
             *  Sets the custom text displayed above the selection input box.
             *   ```xml
             * <ers-file instruction-text="ctrl.instructionText"/>
             * ```
             *
             *  @param {string} [drop-zone-additional-text] {@?}
             *  Sets additional text option for the drop zone.
             *   ```xml
             * <ers-file drop-zone-additional-text="ctrl.dropZoneAdditionalText"/>
             * ```
             *
             *  @param {string} [action-button-text] {@?}
             *  Sets the text displayed on a visiblel action button.
             * ```xml
             * <ers-file action-button-text="ctrl.actionButtonText"/>
             * ```
             *
             *  @param {boolean} [action-button-visible=true] {=?}
             *  Sets either true or false to toggle the action button to visible or not. The default is true.
             * ```xml
             * <ers-file action-button-visible="ctrl.actionButtonVisible"/>
             * ```
             *
             *  @param {string} [action-button-action] {&?}
             *  Sets the action button callback.
             * ```xml
             * <ers-file action-button-action="ctrl.actionButtonAction"/>
             * ```
             *
             *  @param {IUploadOptions} [uploader-options] {=?}
             *  Sets the upload options, *for example*, file size, file type, number of files.
             *  ```xml
             * <ers-file uploader-options="ctrl.uploaderOptions"/>
             * ```
             *
             *   @param {string} [information-tooltip-txt] {=?}
             *  Sets the text of the information tooltip. The text displays under the the file selector input icon when the
             *  user
             *  hovers over the icon with their mouse.
             * ```xml
             * <ers-file information-tooltip-text="ctrl.informationTooltipTxt"/>
             * ```
             *
             *   @param {IMenuItem[]} [selected-item-context-menu] {=?}
             *  Defines the content of the contextual menu for the items.
             *   ```xml
             * <ers-file selected-item-context-menu="ctrl.selectedItemContextMenu"/>
             * ```
             *
             *   @param {boolean} [apply-filters-only-on-push=true] {=?}
             *  Sets whether the filters are applied when the file is first selected, or when the file is committed to upload.
             *
             *
             *  ```xml
             * <ers-file apply-filters-only-on-push="ctrl.applyFiltersOnlyOnPush"/>
             * ```
             *
             */
            angular.module("ers.components.file").directive("ersFile", function () {
                return {
                    restrict: "E", templateUrl: "file/template/file-template.html", transclude: true,
                    /**
                     *  The scope mapping.
                     */
                    scope: {
                        id: "@",
                        selection: "=",
                        multiple: "=?",
                        maxFiles: "@?",
                        maxSize: "@?",
                        filters: "=?",
                        types: "=?",
                        extensions: "=?",
                        onAddingFiles: "&",
                        onWhenAddingFileFailed: "&",
                        selectionInputPlaceHolderText: "@",
                        instructionText: "@",
                        dropZoneAdditionalText: "@",
                        actionButtonText: "@",
                        actionButtonVisible: "=?",
                        actionButtonAction: "&",
                        uploaderOptions: "=?",
                        selectedItemContextMenu: "=?",
                        allErrorsTogether: "=?",
                        informationTooltipTxt: "=?",
                        applyFiltersOnlyOnPush: "=?"
                    }, controllerAs: "ctrl", bindToController: true, controller: FileComponent
                };
            });
            /**
             * ###File component
             * The `ers-file` component allows you to choose and manage one or more files.
             * The user can select files two ways:
             *
             *  - Browse to and select the file.
             *  - Click to select, drag, and then drop the file or files in drop zone.
             *
             * After completing the selection, you can add to or remove files from the selection before uploading.
             *
             *
             * You can configure the file selector to filter according to:
             *
             *  - Extension
             *  - Type (including wildcards)
             *  - Size
             *  - Number of files
             *  - User-created custom filter
             *
             * Each filter, including user-created filters, is a promise that is resolved if the file is not rejected.
             * When errors occur, a callback prompts a dialog allowing you to fix the error.
             *
             *
             * All user-created filters can be saved for future use.
             *
             * Upload is an optional action button that begins the upload and provides a progress indicator bar for each
             * file.
             * As the selected file or files are uploaded, the ers-file component displays a progress bar. The user
             * can abort any specific file upload by dismissing that progress bar.
             *
             *  ### Available Options
             *
             * The following are the options available for the File component:
             *
             * * [id](#id),[selection](#selection), [multiple](#_multiple),
             * [maxFiles](#_maxFiles), [maxSize](#_maxSize),
             * [filters](#_filters),[types](#types),[extensions](#extensions),[allErrorsTogether](#allErrorsTogether),
             * [onAddingFiles](#onAddingFiles),[onWhenAddingFileFailed](#onWhenAddingFileFailed),
             * [selectionInputPlaceHolderText](#selectionInputPlaceHolderText),[applyFiltersOnlyOnPush](#applyFiltersOnlyOnPush)
             * ,[instructionText](#instructionText),[selectionInputPlaceHolderText](#selectionInputPlaceHolderText),
             * [dropZoneAdditionalText](#dropZoneAdditionalText),[uploading](#uploading),[uploaderOptions](#uploaderOptions)
             * ,[_actionButtonText](#actionButtonText),[_actionButtonVisible](#actionButtonVisible)
             * ,[_actionButtonAction](#actionButtonAction),[instructionText](#instructionText)
             * ,[informationTooltipTxt](#informationTooltipTxt),[_selectedItemContextMenu](#selectedItemContextMenu)
             *
             * The following are the methods available for the File component:
             *
             * ### Available Methods
             *
             * [removeFile](#removeFile),[removeAllFiles](#removeAllFiles), [folderFilter](#folderFilter),
             * [queueLimitFilter](#queueLimitFilter),[removeAllFiles](#removeAllFiles),[removeFile](#removeFile),
             * [sizeLimitFilter](#sizeLimitFilter), [typeFilter](#typeFilter), [extensionFilter](#extensionFilter),
             * [extensionFilter](#extensionFilter), [upload](#upload), [cancelUpload](#cancelUpload),
             * [cancelAllUpload](#cancelAllUpload), [getReadyItems](#getReadyItems), [autoUpload](#autoUpload),
             * [getTotalUploadProgress](#getTotalUploadProgress)
             *
             *
             * ### Examples
             *
             * #### Example.
             *
             * ```xml
             *    <ers-file id="fileSandbox" selection="ctrl.selection" multiple="ctrl.multiple"
             * max-files="{{ctrl.maxFiles}}" extensions="[ctrl.currentExtension]"
             * max-size="{{ctrl.maxSize}}" types="[ctrl.currentType]"
             * all-errors-together="ctrl.allErrorsTogether" filters="[ctrl.currentFilter]"
             * on-when-adding-file-failed="ctrl.selectFileFailed(errors)"
             * selection-input-place-holder-text="Select your file here."
             * instruction-text="Select your files here:"
             * drop-zone-additional-text="File Selection" is-upload="ctrl.uploaderOptions"
             * uploader-options="ctrl.uploaderOptions"></ers-file>
             * ```
             *
             */
            var FileComponent = (function (_super) {
                __extends(FileComponent, _super);
                /**
                 * @constructor
                 * @param $scope ng.IScope The scope
                 * @param $element ng.IAugmentedJQuery The component element.
                 * @param $q ng.IQService The promise service.
                 * @param $rootScope ng.IRootScopeService The $rootscope service.
                 * @param $http ng.IHttpService The $http service.
                 * @param $timeout ng.ITimeoutService The $timeout service.
                 */
                function FileComponent($scope, $element, $q, $rootScope, $http, $timeout) {
                    var _this = this;
                    _super.call(this, $scope, $element, null, $timeout);
                    /**
                     * A boolean selection that enables, or not, multiple file selection.
                     * When set to true, multiple files are allowed. When set to false, it blocks multiple selections for
                     * the entire component, both in the browser file selection window and in the drop zone. If you tries
                     * to select file by file, the selected file replaces the
                     * previously selected file.
                     *
                     * @type {boolean}
                     *
                     * ```xml
                     * <ers-file multiple="ctrl.multiple"/>
                     * ```
                     */
                    this._multiple = true;
                    /**
                     * The maximum number of files allowed to be selected as set by the queueLimit filter.
                     *
                     * If this limit is exceeded, an error is returned to the onWhenAddingFileFailed function.
                     *
                     * @type {boolean}
                     *
                     *  ```xml
                     * <ers-file max-files="ctrl.maxFiles"/>
                     * ```
                     */
                    this._maxFiles = -1;
                    /**
                     * The maximum file size (in bytes) allowed to be selected as set by the sizeLimit filter.
                     *
                     * If this limit is exceeded, an error is returned to the onWhenAddingFileFailed function.
                     *
                     * @type {boolean}
                     *
                     *  ```xml
                     * <ers-file max-files="ctrl.maxSize"/>
                     * ```
                     */
                    this._maxSize = -1;
                    /**
                     * True if selecting files is in progress.
                     */
                    this.selecting = false;
                    /**
                     * True if the filters must be applied only when a new file is added to the selection.
                     *
                     * @type {boolean}
                     *
                     *  ```xml
                     * <ers-file apply-filters-only-on-push="ctrl.applyFiltersOnlyOnPush"/>
                     * ```
                     */
                    this.applyFiltersOnlyOnPush = false;
                    /**
                     * Place holder text in the selection input.
                     * @type {string}
                     *
                     *  ```xml
                     * <ers-file selection-input-place-holder-text="ctrl.selectionInputPlaceHolderText"/>
                     * ```
                     */
                    this.selectionInputPlaceHolderText = "Select your files here.";
                    /**
                     *  True if the action button is visible. By default the action button is not visible.
                     * @type {boolean}
                     *
                     *  ```xml
                     * <ers-file action-button-visible="ctrl.actionButtonVisible"/>
                     * ```
                     */
                    this._actionButtonVisible = false;
                    /**
                     *  The action button text (if visible).
                     * @type {string}
                     *
                     *  ```xml
                     * <ers-file action-button-text="ctrl.actionButtonText"/>
                     * ```
                     */
                    this._actionButtonText = "";
                    /**
                     * The text that appears on the second line of the dropzone additional text string.
                     * @type {Function}
                     *
                     *  ```xml
                     * <ers-file drop-zone-additionnal-text="ctrl.dropZoneAdditionalText"/>
                     * ```
                     **/
                    this.dropZoneAdditionalText = "";
                    /**
                     *  True if uploading is in progress. The default is false.
                     * @type {boolean}
                     *
                     *  ```xml
                     * <ers-file uploading="ctrl.uploading"/>
                     * ```
                     */
                    this.uploading = false;
                    /**
                     * The instruction text appearing above the selection input.
                     * @type {string}
                     *
                     *  ```xml
                     * <ers-file instruction-text="ctrl.instructionText"/>
                     * ```
                     */
                    this.instructionText = "Upload your files here:";
                    /**
                     * The XMLHttpRequest transport to upload.
                     * @param {IFileItem} The file to upload.
                     */
                    this.xhrTransport = function (item) {
                        var xhr = new XMLHttpRequest();
                        // prepare the data to upload.
                        var form = new FormData();
                        if (!item || !item.file || typeof (item.file.size) !== "number") {
                            throw new TypeError("The file specified is no longer valid");
                        }
                        form.append("file", item.file, item.file.name);
                        // on load start event.
                        xhr.upload.onloadstart = function () {
                            item._onBeforeUpload();
                            _this.updateUploadingItems();
                            _this.render();
                        };
                        // on progress event.
                        xhr.upload.onprogress = function (event) {
                            var progress = Math.round(event.lengthComputable ? event.loaded * 100 / event.total : 0);
                            _this._onUploadProgressItem(item, progress);
                            _this.render();
                        };
                        // on load event.
                        xhr.onload = function () {
                            // analyse the response and the status code.
                            var headers = _this.parseHeaders(xhr.getAllResponseHeaders());
                            var response = _this.transformResponse(xhr.response, headers);
                            // var gist:string = this.isSuccessCode(xhr.status) ? "Success" : "Error";
                            if (!_this.isSuccessCode(xhr.status)) {
                                item.uploadError = response;
                                item.isUploadError = true;
                                _this.updateFailedItems();
                            }
                            else {
                                _this._onUploadSuccessItem(item, response, xhr.status, headers);
                            }
                            // var method = "_onUpload" + gist + "Item";
                            // this[method](item, response, xhr.status, headers);
                            _this._onUploadCompleteItem(item, response, xhr.status, headers);
                            //update the status
                            _this.updateUploadingItems();
                            _this.updateUploadedItems();
                            _this.render();
                        };
                        // on error event.
                        xhr.onerror = function () {
                            // analyse the response
                            var headers = _this.parseHeaders(xhr.getAllResponseHeaders());
                            var response = _this.transformResponse(xhr.response, headers);
                            item.uploadError = response;
                            _this._onUploadErrorItem(item, response, xhr.status, headers);
                            _this._onUploadCompleteItem(item, response, xhr.status, headers);
                            //update the status
                            _this.updateUploadingItems();
                            _this.updateFailedItems();
                            _this.render();
                        };
                        // on abort event.
                        xhr.onabort = function () {
                            // analyse the response
                            var headers = _this.parseHeaders(xhr.getAllResponseHeaders());
                            var response = _this.transformResponse(xhr.response, headers);
                            _this._onUploadCancelItem(item, response, xhr.status, headers);
                            _this._onUploadCompleteItem(item, response, xhr.status, headers);
                            //update the status
                            _this.updateUploadingItems();
                            _this.render();
                        };
                        // configure the xhr and do the upload.
                        xhr.withCredentials = _this.uploaderOptions.withCredentials;
                        xhr.open(_this.uploaderOptions.method ? _this.uploaderOptions.method : "post", _this.uploaderOptions.url, true);
                        angular.forEach(_this.uploaderOptions.headers, function (value, name) {
                            xhr.setRequestHeader(name, value);
                        });
                        xhr.send(form);
                        _this.render();
                    };
                    this.promiseService = $q;
                    this.$rootscope = $rootScope;
                    this.$http = $http;
                    this.configureUI();
                    this.configureFilters();
                }
                /**
                 * Configuring the drop zone and the select button.
                 */
                FileComponent.prototype.configureUI = function () {
                    var _this = this;
                    if (!this.$element) {
                        return;
                    }
                    setTimeout(function () {
                        // Select button
                        var selectButton = _this.$element.find("#selectFiles_" + _this.id);
                        selectButton.bind("change", function (event) {
                            _this.fileListToSelect = event.currentTarget.files;
                            _this.pushFiles(_this.fileListToSelect);
                            // reset the selected files in the input to allow the change event to trigger.
                            $(event.currentTarget).val("");
                        });
                        // DropZone
                        var dropzone = _this.$element.find(".dropzone");
                        // 1 - drop event
                        dropzone.bind("drop", function (eventObject) {
                            var dragEvent = (eventObject.originalEvent);
                            var dt = dragEvent.dataTransfer;
                            dt.dropEffect = "copy";
                            event.preventDefault();
                            event.stopPropagation();
                            _this.fileListToSelect = dt.files;
                            _this.pushFiles(_this.fileListToSelect);
                            dropzone.removeClass("file-over");
                        });
                        // 2 - drag over event
                        dropzone.bind("dragover", function (eventObject) {
                            dropzone.addClass("file-over");
                            event.preventDefault();
                            event.stopPropagation();
                            return false;
                        });
                        // 2 - drag start event
                        dropzone.bind("dragstart", function (eventObject) {
                            event.preventDefault();
                            event.stopPropagation();
                            return false;
                        });
                        // 3 - drag end event
                        dropzone.bind("dragend", function (eventObject) {
                            dropzone.addClass("file-over");
                            event.preventDefault();
                            event.stopPropagation();
                            return false;
                        });
                        // 4 - drag leave event
                        dropzone.bind("dragleave", function (eventObject) {
                            dropzone.removeClass("file-over");
                            event.preventDefault();
                            event.stopPropagation();
                            return false;
                        });
                    }, 1000);
                };
                Object.defineProperty(FileComponent.prototype, "selection", {
                    /**
                     * The selection getter
                     * @returns {File[]}
                     */
                    get: function () {
                        return this._selection;
                    },
                    /**
                     * The selection setter.
                     * @param pSelection
                     */
                    set: function (pSelection) {
                        this._selection = pSelection;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(FileComponent.prototype, "actionButtonVisible", {
                    /**
                     *
                     * @returns {boolean} True if the action button is visible.
                     */
                    get: function () {
                        return this._actionButtonVisible || (angular.isDefined(this.uploaderOptions) && this.uploaderOptions != null);
                    },
                    /**
                     *
                     * @param pVisible {boolean} True if the action button is visible.
                     */
                    set: function (pVisible) {
                        this._actionButtonVisible = pVisible;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(FileComponent.prototype, "actionButtonText", {
                    /**
                     *
                     * @returns {string} The action button text.
                     */
                    get: function () {
                        return this.uploaderOptions && !this._actionButtonText ? "Upload" : this._actionButtonText;
                    },
                    /**
                     *
                     * @param pText {string} The action button text.
                     */
                    set: function (pText) {
                        this._actionButtonText = pText;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(FileComponent.prototype, "actionButtonAction", {
                    /**
                     *
                     * @returns {Function} The function invoked when the action button is activated.
                     */
                    get: function () {
                        return this.uploaderOptions ? this.upload : this._actionButtonAction;
                    },
                    /**
                     *
                     * @param pAction {Function} The function invoked when the action button is activated.
                     */
                    set: function (pAction) {
                        this._actionButtonAction = pAction;
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 *
                 * @returns {string} The text displayed during the selection or upload process, in addition to the clear all
                 * button.
                 */
                FileComponent.prototype.getSelectorUploaderText = function () {
                    var text = " file";
                    var multipleFiles = "";
                    if (this.selection && this.selection.filter(function (item) {
                        return item.uploadHasBegun();
                    }).length > 0) {
                        if (this.uploading) {
                            var uploadingFiles = this.uploaderOptions.uploadStatus.uploading;
                            multipleFiles = uploadingFiles > 1 ? "s" : "";
                            text = uploadingFiles + text + multipleFiles + " in progress...";
                        }
                        else {
                            var uploadedFiles = this.uploaderOptions.uploadStatus.uploaded;
                            multipleFiles = uploadedFiles > 1 ? "s" : "";
                            text = uploadedFiles + text + multipleFiles + " uploaded";
                        }
                    }
                    else {
                        var selected = this.selection ? this.selection.length : 0;
                        multipleFiles = selected > 1 ? "s" : "";
                        text = selected + text + multipleFiles + " selected";
                    }
                    return text;
                };
                /************* File Selector Specifics ****************************/
                /**
                 * Configures the default filters.
                 */
                FileComponent.prototype.configureFilters = function () {
                    var _this = this;
                    if (!this.filters) {
                        this.filters = [];
                    }
                    //queueLimit Filter: Limits the maximum allowed files.
                    this.filters.unshift({
                        filterName: "queueLimit", fn: this.queueLimitFilter, errorMessage: function () {
                            var limit = 1;
                            if (_this.multiple) {
                                limit = _this._maxFiles;
                            }
                            return "The maximum number of files is: " + limit;
                        }
                    });
                    //sizeLimit filter: limit the allowed files size.
                    this.filters.unshift({
                        filterName: "sizeLimit", fn: this.sizeLimitFilter, errorMessage: function () {
                            return "The file size limit is: (" + _this.maxSize + ") exceeded";
                        }
                    });
                    //typeFilter filter: Limit file types allowed.
                    this.filters.unshift({
                        filterName: "typeFilter", fn: this.typeFilter, errorMessage: function () {
                            return "The allowed filed types are: " + (!angular.isUndefined(_this.types) ? _this.types : "All");
                        }
                    });
                    //extensionFilter filter: limit the allowed files extensions.
                    this.filters.unshift({
                        filterName: "extensionFilter", fn: this.extensionFilter, errorMessage: function () {
                            return "The allowed extensions are: " + (!angular.isUndefined(_this.extensions) ? _this.extensions : "All");
                        }
                    });
                    //folder filter: forbid the folder selection.
                    this.filters.unshift({
                        filterName: "folder", fn: this.folderFilter, errorMessage: function () {
                            return "You cannot select a folder.";
                        }
                    });
                };
                Object.defineProperty(FileComponent.prototype, "filters", {
                    /**
                     * Gets the allowed filters.
                     * @returns {IFileFilter[]} The list of allowed filters.
                     */
                    get: function () {
                        return this._filters;
                    },
                    /**
                     * The filters setter.
                     * @param  Sets the allowed filters.
                     */
                    set: function (pFilters) {
                        var tempFilters = this._filters;
                        this._filters = pFilters;
                        this.configureFilters();
                        // if filters has changed, verify the current selection with filters to remove the non-relevant files.
                        if (!angular.equals(tempFilters, pFilters)) {
                            this.verifyFiles();
                        }
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * The default filter, folderFilter, is a promise that determines whether the selection is a file or a folder,
                 * and resolves the promise when the selection is a file.
                 * @param {Object} The selection being checked.
                 * @returns {Boolean} "True" if the item is a file and not a folder.
                 */
                FileComponent.prototype.folderFilter = function (item) {
                    var deferred = this.promiseService.defer();
                    if (!!(item.file["size"] || item.file["type"])) {
                        deferred.resolve();
                    }
                    else {
                        deferred.reject();
                    }
                    return deferred.promise;
                };
                /**
                 * The queueLimitFilter is a promise that
                 * sets the maximum number of files that can be selected at one time.
                 * The promise, the maximum number of files, must be verified, even though the files have not yet been
                 * pushed in the selection. It is resolved when the maximum number of files is verified.
                 *
                 * @param The maximum number of files against which to check.
                 * @returns {ng.IPromise<Object>} A promise resolved if the maximum number of files has not been reached.
                 */
                FileComponent.prototype.queueLimitFilter = function (file, currentFileIndex) {
                    var deferred = this.promiseService.defer();
                    if ((!this.multiple && this.fileListToSelect) || (this.multiple && (angular.isUndefined(this.maxFiles) ||
                        angular.equals(this.maxFiles, "") ||
                        this.maxFiles < 0))) {
                        deferred.resolve();
                    }
                    else {
                        var total = currentFileIndex;
                        // we have to manage the non multiple case: if the value changes we have to reduce the selection to one file.
                        var max = this.multiple ? this.maxFiles : 1;
                        // check filter during file pushing.
                        if (this.selection && this.fileListToSelect !== null) {
                            total = total + this.selection.length;
                        }
                        else {
                            total = total + 1;
                        }
                        if (total <= max) {
                            deferred.resolve();
                        }
                        else {
                            deferred.reject();
                        }
                    }
                    return deferred.promise;
                };
                /**
                 * The sizeLimitFilter is a promise that sets the maximum size of a selected file. The promise,
                 * maximum file size, is resolved when all of the files have been processed.
                 * @param The files file the file to check.
                 * @returns {ng.IPromise<Object>} A promise that is resolved if the file size limit has not been reached.
                 *
                 */
                FileComponent.prototype.sizeLimitFilter = function (file) {
                    var deferred = this.promiseService.defer();
                    if ((!angular.isUndefined(this.maxSize) && !angular.equals(this.maxSize, "") && this.maxSize >= 0)
                        ? file.file.size / 1000000 <= this.maxSize
                        : true) {
                        deferred.resolve();
                    }
                    else {
                        deferred.reject();
                    }
                    return deferred.promise;
                };
                /**
                 * The typeFilter is a promise that reviews the types of files selected, and resolves when
                 * the files have been processed and the file types are allowed.
                 * @param Filters to check.
                 * @returns {ng.IPromise<Object>} A promise resolved if the file type is allowed.
                 */
                FileComponent.prototype.typeFilter = function (file) {
                    var deferred = this.promiseService.defer();
                    if (!this.types || !this.types.length) {
                        deferred.resolve();
                    }
                    else {
                        var validType = true;
                        angular.forEach(this.types, function (fileType) {
                            validType = fileType === null || file.file.type.toLowerCase().match(fileType) !== null;
                        });
                        if (validType) {
                            deferred.resolve();
                        }
                        else {
                            deferred.reject();
                        }
                    }
                    return deferred.promise;
                };
                /**
                 *
                 *
                 * The extensionFilter is a promise that checks the file extensions and resolves the promise if all of the
                 * extensions are allowed.
                 *
                 * @param Extensions to check.
                 * @returns {ng.IPromise<Object>} A promise resolved if the file extension is allowed.
                 */
                FileComponent.prototype.extensionFilter = function (file) {
                    var deferred = this.promiseService.defer();
                    if (!this.extensions || !this.extensions.length) {
                        deferred.resolve();
                    }
                    else {
                        var validExtension = false;
                        var fileNameParts = file.file.name.split(".");
                        var extension;
                        // if there are at least two pieces to the file name, continue the check
                        if (fileNameParts.length > 1) {
                            // get the extension (i.e., the last "piece" of the file name)
                            extension = fileNameParts[fileNameParts.length - 1];
                            angular.forEach(this.extensions, function (fileExtension) {
                                if (fileExtension === null || extension.toLowerCase().match(fileExtension.toLowerCase()) !== null) {
                                    validExtension = true;
                                }
                            });
                            if (validExtension) {
                                deferred.resolve();
                            }
                            else {
                                deferred.reject();
                            }
                        }
                        else {
                            deferred.reject(); // invalid file name format (no file extension)
                        }
                    }
                    return deferred.promise;
                };
                /**
                 *
                 * Removes one file from the selection, by its index.
                 * @param Index the file index.
                 * @param pUpdateUploadedStatus True if the uploadStatus.uploaded must be updated.
                 */
                FileComponent.prototype.removeFile = function (index, pUpdateUploadedStatus, pKeepInError) {
                    if (pKeepInError === void 0) { pKeepInError = false; }
                    var file = this.selection[index];
                    if (!pKeepInError || !file.isUploadError) {
                        if (file.isUploading) {
                            this.cancelUpload(file);
                        }
                        if (pUpdateUploadedStatus && file.isUploaded) {
                            this.uploaderOptions.uploadStatus.uploaded--;
                        }
                        file.destroy();
                        delete this.selection[index];
                        this.selection.splice(index, 1);
                        // It's the last file, reset the status and progress.
                        if (this.selection.length === 0) {
                            this.uploading = false;
                            this.initUploadStatus();
                            this.resetUploadProgress(true);
                        }
                    }
                };
                /**
                 *
                 * @param file
                 * @param pUpdateUploadedStatus
                 * @param pKeepInError
                 * @private
                 */
                FileComponent.prototype._removeFile = function (file, pUpdateUploadedStatus, pKeepInError) {
                    if (pKeepInError === void 0) { pKeepInError = false; }
                    this.removeFile(this.selection.indexOf(file), pUpdateUploadedStatus, pKeepInError);
                };
                /**
                 * Removes all files from the selection.
                 */
                FileComponent.prototype.removeAllFiles = function (pKeepInError, pUpdateUploadedStatus) {
                    var _this = this;
                    if (pKeepInError === void 0) { pKeepInError = false; }
                    if (pUpdateUploadedStatus === void 0) { pUpdateUploadedStatus = false; }
                    this.uploading = false;
                    // angular.forEach(this.selection.length, (index:number) => {
                    var tempFiles = this.selection.concat([]);
                    //for (var index:number = 0; index < tempFiles.length; index++) {
                    angular.forEach(tempFiles, function (file) {
                        _this._removeFile(file, pUpdateUploadedStatus, pKeepInError);
                    });
                };
                Object.defineProperty(FileComponent.prototype, "maxFiles", {
                    /**
                     * The maxFiles getter.
                     * @returns {number} The maximum number.
                     */
                    get: function () {
                        return this._maxFiles;
                    },
                    /**
                     * The maxFiles setter.
                     * @param pMaxFiles The maximum number of files.
                     */
                    set: function (pMaxFiles) {
                        var tempFiles = this._maxFiles;
                        this._maxFiles = pMaxFiles;
                        // if files number has changed, verify the current selection with filters to remove the non-relevant files.
                        if (tempFiles !== pMaxFiles) {
                            this.verifyFiles();
                        }
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(FileComponent.prototype, "maxSize", {
                    /**
                     * The maxSize getter.
                     * @returns {number} The maximum size of a file.
                     */
                    get: function () {
                        return this._maxSize;
                    },
                    /**
                     * The maxSize setter.
                     * @param pMaxSize The maximum size of a file.
                     */
                    set: function (pMaxSize) {
                        var tempSize = this._maxSize;
                        this._maxSize = pMaxSize;
                        // if size has changed, verify the current selection with filters to remove the non-relevant files.
                        if (tempSize !== pMaxSize) {
                            this.verifyFiles();
                        }
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(FileComponent.prototype, "selectedItemContextMenu", {
                    /**
                     * The context menu on each selected file in the selected items list.
                     * @returns {number} the Context menu .
                     */
                    get: function () {
                        return this._selectedItemContextMenu;
                    },
                    /**
                     * The context menu on each selected file in the selected items list.
                     * @param pMaxFiles The Context menu for each file.
                     */
                    set: function (pselectedItemMenus) {
                        this._selectedItemContextMenu = pselectedItemMenus;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(FileComponent.prototype, "types", {
                    /**
                     * The file types getter.
                     * @returns {string[]} The allowed file types.
                     */
                    get: function () {
                        return this._types;
                    },
                    /**
                     * The file types setter.
                     * @param pTypes The allowed file types.
                     */
                    set: function (pTypes) {
                        var tempType = this._types;
                        this._types = pTypes;
                        // if types has changed, verify the current selection with filters to remove the non-relevant files.
                        if (tempType !== pTypes) {
                            this.verifyFiles();
                        }
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(FileComponent.prototype, "extensions", {
                    /**
                     * The file extensions getter.
                     * @returns {string[]} The allowed file extensions.
                     */
                    get: function () {
                        return this._extensions;
                    },
                    /**
                     * The extensions setter.
                     * @param pExtensions The allowed file extensions.
                     */
                    set: function (pExtensions) {
                        var tempExtensions = this._extensions;
                        this._extensions = pExtensions;
                        // if extensions has changed, verify the current selection with filters to remove the non-relevant files.
                        if (tempExtensions !== pExtensions) {
                            this.verifyFiles();
                        }
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(FileComponent.prototype, "multiple", {
                    /**
                     * The multiple file getter.
                     * @returns {boolean} The list of multiple files selected
                     */
                    get: function () {
                        return this._multiple;
                    },
                    /**
                     * The multiple setter.
                     * @param pMultiple The list of multiple files selected.
                     */
                    set: function (pMultiple) {
                        // Multiple attribute is like the disabled html attribute: we need to add or remove it on the tag.
                        if (this.$element) {
                            var selectInput = this.$element.find("#selectFiles_" + this.id);
                            var dragZone = this.$element.find(".dropzone");
                            if (pMultiple) {
                                if (selectInput) {
                                    $(selectInput).attr("multiple", "multiple");
                                }
                                if (dragZone) {
                                    $(dragZone).attr("multiple", "multiple");
                                }
                            }
                            else {
                                if (selectInput) {
                                    $(selectInput).removeAttr("multiple");
                                }
                                if (dragZone) {
                                    $(dragZone).removeAttr("multiple");
                                }
                            }
                        }
                        var tempMultiple = this._multiple;
                        this._multiple = pMultiple;
                        if (tempMultiple !== pMultiple) {
                            this.verifyFiles();
                        }
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * Verify the validity of all files, and if they are all good, push them to the the selection array,
                 * otherwise, raise an error.
                 *
                 * @param files the File list
                 */
                FileComponent.prototype.pushFiles = function (files) {
                    var _this = this;
                    var filesCount = 0;
                    var filesLength = files.length;
                    this.filesSelected = [];
                    var deferred = this.promiseService.defer();
                    if (this.promiseService) {
                        //var fileIndex:number = 0;
                        var currentFileIndex = 0;
                        this.selecting = true;
                        // Iterate on selected files.
                        angular.forEach(files, function (item) {
                            //
                            var file = new file_1.FileItem(item);
                            var filterPromise = _this.checkFilters(file, 0, currentFileIndex);
                            currentFileIndex = currentFileIndex + 1;
                            filterPromise.then(function () {
                                if (!_this.selection || !_this.multiple) {
                                    _this.selection = [];
                                }
                                //File ok : push it !.
                                _this.filesSelected.push(file);
                            }, function (pFilter) {
                                //File KO : smash it !.
                                _this.manageError(file, pFilter);
                                file = null;
                            }).finally(function () {
                                filesCount = filesCount + 1;
                                if (_this.selecting && filesCount === filesLength) {
                                    if (_this.filesSelected && _this.filesSelected !== []) {
                                        if (!_this.selection) {
                                            _this.selection = [];
                                        }
                                        _this.selection = _this.selection.concat(_this.filesSelected);
                                        // If the errors array is not empty, call the callback to notify the user.
                                        _this.manageErrorsBulk();
                                        _this.onAddingFiles(_this.filesSelected);
                                        if (_this.uploaderOptions) {
                                            _this.resetUploadProgress();
                                            if (_this.uploaderOptions.uploadStatus) {
                                                _this.uploaderOptions.uploadStatus.toBeUploaded = _this.selection.length
                                                    - _this.getProcessedItems().length;
                                            }
                                            if (_this.autoUpload()) {
                                                _this.upload();
                                            }
                                        }
                                        _this.filesSelected = null;
                                    }
                                    deferred.resolve();
                                    _this.selecting = false;
                                    _this.filesSelected = [];
                                    _this.fileListToSelect = null;
                                }
                            });
                        }, this);
                    }
                    else {
                        deferred.resolve();
                    }
                    return deferred.promise;
                };
                /**
                 * Verify the selected files against the filters.
                 */
                FileComponent.prototype.verifyFiles = function () {
                    var _this = this;
                    var deferred = this.promiseService ? this.promiseService.defer() : null;
                    var returnPromise = deferred ? deferred.promise : null;
                    if (!returnPromise || this.applyFiltersOnlyOnPush || !this.selection || this.selection.length < 1 || !this.promiseService) {
                        return returnPromise;
                    }
                    // Iterate on the selected files.
                    angular.forEach(this.selection, function (item) {
                        var fileIndex = _this.selection.indexOf(item);
                        //filters validity  check.
                        var filterPromise = _this.checkFilters(item, 0, fileIndex);
                        filterPromise.then(function () {
                            fileIndex = _this.selection.indexOf(item);
                            //File ok : let it in the selection
                            if (fileIndex === _this.selection.length) {
                                // if the errors array not empty, we have to call the callback to notify the user.
                                _this.manageErrorsBulk();
                                deferred.resolve();
                            }
                        }, function (pFilter) {
                            fileIndex = _this.selection.indexOf(item);
                            //File KO : remove it from the selection.
                            _this.removeFile(fileIndex, true);
                            _this.manageError(item, pFilter);
                            if (fileIndex === _this.selection.length) {
                                // if the errors array not empty, we have to call the callback to notify the user.
                                _this.manageErrorsBulk();
                                deferred.resolve();
                            }
                        });
                    }, this);
                    return returnPromise;
                };
                /**
                 * Verify that the files pass all the filters. Each filter is a promise which is resolved if
                 * the file is not rejected by the filter or rejected for another reason.
                 *
                 * @param {File} file  The file(s) to check.
                 * @param {number} filterIndex The current filter index.
                 * @param {number} fileIndex The current filter index.
                 * @returns {ng.IPromise<Object>} A promise resolved if all of the files pass all of the filters.
                 */
                FileComponent.prototype.checkFilters = function (file, filterIndex, fileIndex) {
                    var _this = this;
                    var i = filterIndex;
                    var deferred = this.promiseService ? this.promiseService.defer() : null;
                    var returnPromise = deferred ? deferred.promise : null;
                    // no filters, promise resolve.
                    if (!returnPromise || !this.filters.length) {
                        deferred.resolve();
                    }
                    else {
                        // each filter is checked.
                        if (filterIndex < this.filters.length) {
                            var currentFilter = this.filters[filterIndex];
                            if (!currentFilter) {
                                deferred.resolve();
                            }
                            else {
                                var filterPromise = currentFilter.fn.call(this, file, fileIndex);
                                filterPromise.then(function () {
                                    i = i + 1;
                                    filterPromise = _this.checkFilters(file, i, fileIndex);
                                    filterPromise.then(function () {
                                        deferred.resolve();
                                    }, function (pCurrentFilter) {
                                        deferred.reject(pCurrentFilter);
                                    });
                                }, function () {
                                    deferred.reject(currentFilter);
                                });
                            }
                        }
                        else {
                            deferred.resolve();
                        }
                    }
                    return returnPromise;
                };
                /**
                 * The inner callback that passes all the filter errors to the user controller.
                 * @param {ISelectFileError[]} errors The filter errors.
                 */
                FileComponent.prototype._onWhenAddingFileFailed = function (errors) {
                    if (this.onWhenAddingFileFailed) {
                        this.onWhenAddingFileFailed({ errors: errors });
                    }
                };
                FileComponent.prototype.manageError = function (file, filter) {
                    var errorFile = {
                        file: file.file.name,
                        message: filter.errorMessage ? filter.errorMessage() : "",
                        filter: filter.filterName
                    };
                    // if allErrorsTogether == true, we store the errors to send it at the end of the files iteration.
                    // else we call directly the callback.
                    if (this.allErrorsTogether) {
                        if (!this.selectFileError) {
                            this.selectFileError = [];
                        }
                        this.selectFileError.push(errorFile);
                    }
                    else {
                        this._onWhenAddingFileFailed([errorFile]);
                    }
                };
                /**
                 * How error management works when when allErrorsTogether=true.
                 */
                FileComponent.prototype.manageErrorsBulk = function () {
                    if (this.selectFileError) {
                        this._onWhenAddingFileFailed(this.selectFileError);
                        this.selectFileError = null;
                    }
                    this.fileListToSelect = null;
                };
                /************* END File Selector Specifics ****************************/
                /************* File Uploader Specifics ****************************/
                /**
                 * Uploads one or all of the files in the selection.
                 * The upload can be one-by-one, or en masse. The upload can be either sequential or simultaneous.
                 * @param pFileItem a file to upload.
                 */
                FileComponent.prototype.upload = function (pFileItem) {
                    var _this = this;
                    this.uploading = true;
                    // 1st case : all the selection must be uploaded
                    if (!pFileItem) {
                        // progress and status initialisation
                        this.initUploadStatus(0);
                        this.resetUploadProgress();
                        //only the non uploaded items must be uploaded.
                        var items = this.getNotUploadedItems().filter(function (item) {
                            return !item.isUploading;
                        });
                        setTimeout(function () {
                            // uploading each file.
                            angular.forEach(items, function (item) {
                                // simultaneousUpload : file immediately uploaded
                                if (_this.uploaderOptions.simultaneousUpload) {
                                    _this.xhrTransport(item);
                                }
                                else {
                                    item.prepareToUploading();
                                }
                            });
                            // sequential upload
                            if (!_this.uploaderOptions.simultaneousUpload) {
                                // no more files, quit.
                                if (!items.length) {
                                    return;
                                }
                                // file uploaded
                                _this.xhrTransport(items[0]);
                            }
                        }, 0);
                    }
                    else {
                        this.xhrTransport(pFileItem);
                    }
                };
                /**
                 * Cancel uploading one file from the queue.
                 * @param {IFileItem} pFile
                 */
                FileComponent.prototype.cancelUpload = function (pFile) {
                    if (pFile && pFile.isUploading) {
                        pFile.abortUpload();
                    }
                };
                /**
                 * Cancels uploading all files from the queue.
                 */
                FileComponent.prototype.cancelAllUpload = function () {
                    var _this = this;
                    var items = this.getNotUploadedItems();
                    angular.forEach(items, function (item) {
                        _this.cancelUpload(item);
                    });
                };
                /**
                 * Returns the files ready for upload.
                 * @returns {Array}
                 */
                FileComponent.prototype.getReadyItems = function () {
                    return this.selection.filter(function (item) {
                        return (item.isReadyToUpload && !item.isUploading);
                    });
                };
                /**
                 * Returns files not yet uploaded.
                 * @returns {Array}
                 */
                FileComponent.prototype.getNotUploadedItems = function () {
                    return this.selection.filter(function (item) {
                        return !item.isUploaded;
                    });
                };
                /**
                 * Returns uploaded or processed files.
                 * @returns {Array}
                 */
                FileComponent.prototype.getProcessedItems = function () {
                    return this.selection.filter(function (item) {
                        return item.uploadHasBegun();
                    });
                };
                /**
                 *
                 * @returns {boolean} true If the file must be removed from the queue after it is uploaded.
                 */
                FileComponent.prototype.removeAfterUpload = function () {
                    return this.uploaderOptions ? this.uploaderOptions.removeAfterUpload : false;
                };
                /**
                 *
                 * @returns {boolean} true If the file(s) must be uploaded after selection.
                 */
                FileComponent.prototype.autoUpload = function () {
                    return this.uploaderOptions ? this.uploaderOptions.autoUpload : false;
                };
                /**
                 * Initialize the uploadStatus
                 * @param pUploading The uploading number.
                 * @param pUploaded The uploaded number.
                 * @param pFailed The failed number.
                 * @param pProgress The progress number.
                 */
                FileComponent.prototype.initUploadStatus = function (pUploading, pUploaded, pFailed, pProgress) {
                    if (pUploading === void 0) { pUploading = 0; }
                    if (pUploaded === void 0) { pUploaded = 0; }
                    if (pFailed === void 0) { pFailed = 0; }
                    if (pProgress === void 0) { pProgress = 0; }
                    if (!this.uploaderOptions) {
                        return;
                    }
                    if (!this.uploaderOptions.uploadStatus) {
                        this.uploaderOptions.uploadStatus = {
                            uploaded: 0,
                            uploading: 0,
                            failed: 0,
                            toBeUploaded: this.selection.length,
                            progress: 0
                        };
                    }
                    this.uploaderOptions.uploadStatus.uploading = pUploading;
                    this.uploaderOptions.uploadStatus.uploaded = pUploaded;
                    this.uploaderOptions.uploadStatus.progress = pProgress;
                    this.uploaderOptions.uploadStatus.failed = pFailed;
                };
                /**
                 * Update the uploading number.
                 * @param pNumber The uploading number.
                 */
                FileComponent.prototype.updateUploadingItems = function (pNumber) {
                    if (pNumber === void 0) { pNumber = -1; }
                    var uploadingItems = pNumber !== -1 ? pNumber : this.selection.filter(function (item) {
                        return item.isUploading;
                    }).length;
                    if (this.uploaderOptions.uploadStatus) {
                        this.uploaderOptions.uploadStatus.uploading = uploadingItems;
                    }
                    else {
                        this.initUploadStatus(uploadingItems, this.uploaderOptions.uploadStatus.uploaded, this.uploaderOptions.uploadStatus.failed, this.uploaderOptions.uploadStatus.progress);
                    }
                };
                /**
                 * Update the uploaded number.
                 * @param pNumber The uploaded number.
                 */
                FileComponent.prototype.updateUploadedItems = function (pNumber) {
                    if (pNumber === void 0) { pNumber = -1; }
                    this.uploaderOptions.uploadStatus.uploaded = pNumber !== -1 ? pNumber : this.selection.filter(function (item) {
                        return item.isUploadSuccess;
                    }).length;
                };
                /**
                 * Update the failed items number.
                 * @param pNumber The failed items number.
                 */
                FileComponent.prototype.updateFailedItems = function (pNumber) {
                    if (pNumber === void 0) { pNumber = -1; }
                    this.uploaderOptions.uploadStatus.failed = pNumber !== -1 ? pNumber : this.selection.filter(function (item) {
                        return item.isUploadError;
                    }).length;
                };
                /**
                 * Reset the global and item progress.
                 * @param pFullReset True if it must be a full reset, or only an update of the total progress.
                 */
                FileComponent.prototype.resetUploadProgress = function (pFullReset) {
                    var _this = this;
                    this.$timeout(function () {
                        if (pFullReset) {
                            if (_this.uploaderOptions) {
                                _this.uploaderOptions.uploadStatus.progress = 0;
                            }
                            angular.forEach(_this.selection, function (item) {
                                item.uploadProgress = 0;
                                _this.render();
                            });
                        }
                        else if (_this.uploaderOptions && _this.uploaderOptions.uploadStatus) {
                            _this.uploaderOptions.uploadStatus.progress = _this.getTotalUploadProgress();
                        }
                        _this.render();
                    });
                };
                /**
                 *
                 * @param value The current progress.
                 * @returns {any} The total progress
                 */
                FileComponent.prototype.getTotalUploadProgress = function (value) {
                    if (this.removeAfterUpload()) {
                        return value || 0;
                    }
                    var notUploaded = this.getNotUploadedItems().length;
                    var uploaded = notUploaded ? this.selection.length - notUploaded : this.selection.length;
                    var ratio = 100 / this.selection.length;
                    var current = (value || 0) * ratio / 100;
                    return Math.round(uploaded * ratio + current);
                };
                /**
                 * Checks whether or not the upload was successful.
                 * @param {number} Status the response status
                 * @returns {boolean} true if is succeed.
                 */
                FileComponent.prototype.isSuccessCode = function (status) {
                    return (status >= 200 && status < 300) || status === 304;
                };
                /**
                 * Transforms the server response
                 * @param {string} response The server response.
                 * @param {{}} headers The response headers.
                 * @returns {string} The transformed headers response.
                 */
                FileComponent.prototype.transformResponse = function (response, headers) {
                    var headersGetter = this.headersGetter(headers);
                    angular.forEach(this.$http.defaults.transformResponse, function (transformFn) {
                        response = transformFn(response, headersGetter);
                    });
                    return response;
                };
                /**
                 * The parsed response headers
                 * @param {string} headers The headers.
                 * @returns {Object} The parsed headers.
                 * @see https://github.com/angular/angular.js/blob/master/src/ng/http.js
                 */
                FileComponent.prototype.parseHeaders = function (headers) {
                    var parsed = {}, key, val, i;
                    if (!headers) {
                        return parsed;
                    }
                    angular.forEach(headers.split("\n"), function (line) {
                        i = line.indexOf(":");
                        key = line.slice(0, i).trim().toLowerCase();
                        val = line.slice(i + 1).trim();
                        if (key) {
                            parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
                        }
                    });
                    return parsed;
                };
                /**
                 * Return the function that returns the headers.
                 * @param {{}} parsedHeaders The headers.
                 * @returns {Function} The header getter
                 */
                FileComponent.prototype.headersGetter = function (parsedHeaders) {
                    return function (name) {
                        if (name) {
                            return parsedHeaders[name.toLowerCase()] || null;
                        }
                        return parsedHeaders;
                    };
                };
                /**
                 * Inner callback for the file upload progress.
                 * @param {IFileItem} item The file upload.
                 * @param {number} progress The file upload progress.
                 */
                FileComponent.prototype._onUploadProgressItem = function (item, progress) {
                    var total = this.getTotalUploadProgress(progress);
                    this.uploaderOptions.uploadStatus.progress = total;
                    item._onUploadProgress(progress);
                    // this.onProgressItem(item, uploadProgress);
                    // this.onProgressAll(total);
                    this.render();
                };
                /**
                 * Inner callback when the file upload succeeds.
                 * @param {IFileItem} item The file upload.
                 * @param {string} response The file upload response.
                 * @param {number} status The file status response.
                 * @param {{}} headers The file headers.
                 */
                FileComponent.prototype._onUploadSuccessItem = function (item, response, status, headers) {
                    item._onUploadSuccess(response, status, headers);
                    //  this.onSuccessItem(item:IFileItem, response:string, status:string, headers:string);
                };
                /**
                 * Inner callback when the upload fails.
                 * @param {IFileItem} item The file.
                 * @param {string} response The failed upload response.
                 * @param {number} status The status response.
                 * @param {{}} headers The file headers.
                 */
                FileComponent.prototype._onUploadErrorItem = function (item, response, status, headers) {
                    item._onUploadError(response, status, headers);
                    //  this.onErrorItem(item:IFileItem, response:string, status:string, headers:string);
                };
                /**
                 * Inner callback when the upload is canceled
                 * @param {IFileItem} item The canceled file upload.
                 * @param {string} response The callback response upon cancellation.
                 * @param {number} status The status response.
                 * @param {{}} headers The headers.
                 */
                FileComponent.prototype._onUploadCancelItem = function (item, response, status, headers) {
                    item._onUploadCancel(response, status, headers);
                    // this.onCancelItem(item:IFileItem, response:string, status:string, headers:string);
                };
                /**
                 * Inner callback when the upload is completed.
                 * @param {IFileItem} item The file item.
                 * @param {string} response The callback response upon completion.
                 * @param {number} status The status response.
                 * @param {{}} headers The headers.
                 */
                FileComponent.prototype._onUploadCompleteItem = function (file, response, status, headers) {
                    file._onUploadComplete(response, status, headers);
                    this.uploaderOptions.uploadStatus.toBeUploaded--;
                    //file must be removed after the upload
                    if (!file.isUploadError && this.uploaderOptions.removeAfterUpload) {
                        this.removeFile(this.selection.indexOf(file), false);
                    }
                    // this.onCompleteItem(item:IFileItem, response:string, status:string, headers:string);
                    // if we are in sequential upload mode, the next file is uploaded
                    if (!this.uploaderOptions.simultaneousUpload) {
                        var nextItem = this.getReadyItems()[0];
                        if (angular.isDefined(nextItem)) {
                            this.upload(nextItem);
                            return;
                        }
                        //this.onCompleteAll();
                        this.uploaderOptions.uploadStatus.progress = this.getTotalUploadProgress();
                    }
                    // no more file to upload.
                    if (this.getReadyItems().length === 0) {
                        this._onUploadCompleteAllItems();
                    }
                    this.render();
                };
                /**
                 * Inner callback when all of the uploads are complete.
                 */
                FileComponent.prototype._onUploadCompleteAllItems = function () {
                    if (this.uploaderOptions.removeAllAfterUpload) {
                        this.removeAllFiles(true);
                    }
                    else {
                        this.updateUploadingItems(0);
                        this.uploading = false;
                    }
                    this.render();
                };
                /**
                 * HTML updates.
                 */
                FileComponent.prototype.render = function () {
                    if (!this.$rootscope.$$phase) {
                        this.$rootscope.$apply();
                    }
                };
                FileComponent.$inject = ["$scope", "$element", "$q", "$rootScope", "$http", "$timeout"];
                return FileComponent;
            })(BaseComponent);
            file_1.FileComponent = FileComponent;
        })(file = components.file || (components.file = {}));
    })(components = ers.components || (ers.components = {}));
})(ers || (ers = {}));/*
 * Created by bertheto on 06/18/2015.
 */
/**
 * Created by bertheto on 06/04/2015.
 */


var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var ers;
(function (ers) {
    var components;
    (function (components) {
        var file;
        (function (file_1) {
                        var BaseController = ers.components.core.BaseController;
            angular.module("ers.components.file").directive("ersImageFileThumb", function () {
                return {
                    restrict: "E",
                    template: "<div><canvas/></div>",
                    controller: ImageFileThumbComponent,
                    controllerAs: "thumbCtrl",
                    scope: { file: "=", height: "@", width: "@" },
                    bindToController: true
                };
            });
            /**
             * ###Image file thumb component
             * Displays a thumbnail of the image file with the specified height and width.
             *
             *  ### Available Options
             *
             * The following are the options available for the ersImageFileThumb component:
             *
             * * [file](#_file), [width](#width), [height](#height)
             *
             * The following are the methods available for the ersImageFileThumb component:
             *
             * ### Available Methods
             *
             * * [onLoadFile](#onLoadFile), [onLoadImage](#onLoadImage), [isValid](#isValid),
             * [isFile](#isFile), [isImage](#isImage)
             *
             * ### Examples
             *
             * #### Example.
             *
             * ```xml
             *  <tr ng-repeat="imageFile in ctrl.imageFiles">
             *    <td>
             *      <strong>{{ imageFile.name }}</strong>
             *         <ers-image-file-thumb file="imageFile" height="100" width="100"></ers-image-file-thumb>
             *   </td>
             * </tr>
             * ```
             *
             */
            var ImageFileThumbComponent = (function (_super) {
                __extends(ImageFileThumbComponent, _super);
                /**
                 * @constructor
                 * @param $scope ng.IScope The scope.
                 * @param $element ng.IAugmentedJQuery The component element.
                 */
                function ImageFileThumbComponent($scope, $element) {
                    var _this = this;
                    _super.call(this, $scope, $element);
                    /**
                     * The load file event handler that loads the image.
                     * @param event The event
                     */
                    this.onLoadFile = function (event) {
                        _this.img = new Image();
                        _this.img.onload = _this.onLoadImage;
                        _this.img.src = event.target["result"];
                    };
                    /**
                     * The load image event handler that draws the image.
                     */
                    this.onLoadImage = function () {
                        if (_this.canvas) {
                            var canvasWidth = _this.width || _this.img.width / _this.img.height * _this.height;
                            var canvasHeight = _this.height || _this.img.height / _this.img.width * _this.width;
                            _this.canvas.attr({ width: canvasWidth, height: canvasHeight });
                            _this.canvas[0].getContext("2d").drawImage(_this.img, 0, 0, canvasWidth, canvasHeight);
                        }
                    };
                    //check file validity
                    if (!this.isValid(this.file)) {
                        return;
                    }
                    // Destroy management.
                    $scope.$on("$destroy", function () {
                        if (_this.img) {
                            _this.img.removeEventListener("load", _this.onLoadImage);
                            _this.img = null;
                        }
                        if (_this.canvas) {
                            $(document).remove("canvas");
                            _this.canvas = null;
                        }
                        if (_this.reader) {
                            _this.reader.removeEventListener("load", _this.onLoadFile);
                            _this.reader = null;
                        }
                    });
                    // Init UI and read the file.
                    this.canvas = $element.find("canvas");
                    this.reader = new FileReader();
                    this.reader.onload = this.onLoadFile;
                    this.reader.readAsDataURL(this.file);
                }
                Object.defineProperty(ImageFileThumbComponent.prototype, "file", {
                    /**
                     * File getter
                     * @returns {File} The file.
                     */
                    get: function () {
                        return this._file;
                    },
                    /**
                     * File setter
                     * @param pFile The file.
                     */
                    set: function (pFile) {
                        this._file = pFile;
                        if (this.reader) {
                            this.reader.readAsDataURL(this.file);
                        }
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 *
                 * @param item The image file verification that this is an image file.
                 * @returns {boolean} True if the file is really an image file.
                 */
                ImageFileThumbComponent.prototype.isValid = function (item) {
                    if (!this.isFile(this.file)) {
                        return false;
                    }
                    if (!this.isImage(this.file)) {
                        return false;
                    }
                    return true;
                };
                /**
                 *
                 * @param item The image file file verification.
                 * @returns {boolean} True if the file is really a file.
                 */
                ImageFileThumbComponent.prototype.isFile = function (item) {
                    return angular.isObject(item) && item instanceof File;
                };
                /**
                 *
                 * @param file The image file.
                 * @returns {boolean} True if the file is an image of a certain type.
                 */
                ImageFileThumbComponent.prototype.isImage = function (file) {
                    var type = "|" + file.type.slice(file.type.lastIndexOf("/") + 1) + "|";
                    return "|jpg|png|jpeg|bmp|gif|".indexOf(type) !== -1;
                };
                ImageFileThumbComponent.$inject = ["$scope", "$element"];
                return ImageFileThumbComponent;
            })(BaseController);
            file_1.ImageFileThumbComponent = ImageFileThumbComponent;
        })(file = components.file || (components.file = {}));
    })(components = ers.components || (ers.components = {}));
})(ers || (ers = {}));



var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var ers;
(function (ers) {
    var components;
    (function (components) {
        var form;
        (function (form) {
                        var BaseComponent = ers.components.core.BaseComponent;
            form._formModule.directive("ersForm", function () {
                return {
                    restrict: "A", controller: FormController, controllerAs: "c", bindToController: true
                };
            });
            /**
             * @ngdoc directive
             * @name ersForm
             * @restrict A
             * @module ers.components.form
             *
             * @description
             *
             * Use the `ers-form` component to validate the form fields on a page when you click Submit. You can use this
             * component on an form field instead of adding a submit attribute to a different component or using the ng-submit
             * component. When you click Submit, `ers-form`notifies you when:
             *
             * - A field does not validate, and then highlights the invalid field.
             * - All of the fields are valid, and then displays a modal message.
             *
             * ### Usage
             *
             * `ers-form` validates the following ers input components:
             *
             * - Textbox
             * - Number
             * - Calendar
             * - RadioButton
             * - Checkbox
             * - Combobox
             *
             *
             * The component can be configured with a popover or tooltip for more verbose field-level error, success,
             * of help information.
             *
             * ### Examples
             *
             * Use of ers-form component within an HTML form.
             * - Add the requested information to all of the form input fields. All fields are required.
             * - Click Submit.
             *
             * <code-editor identifier="example" data-title="Basic Usage"
             * html-content-url="demos/ersForm/basicUsage/index.html"
             * js-content-url="demos/ersForm/basicUsage/script.js"
             * css-content-url="demos/ersForm/basicUsage/styles.css" content-mode="html"></code-editor>
             *
             * ### Design Guidelines
             *
             * No design guidelines.
             *
             * ### Accessibility Guidelines
             *
             * No accessibility guidelines.
             *
             * @param {Function} ersForm This component evaluates the fields on a form when a
             * "submit" is triggered, and returns a value for valid or not.
             *
             */
            var FormController = (function (_super) {
                __extends(FormController, _super);
                /**
                 * Constructor.
                 * @param $element The component element.
                 * @param $attrs List of the all attributes contained in the XML element of this component.
                 * @param ersFormService ERS form Service configured to validate the components contained
                 * in the form when the submit/reset event occurs.
                 */
                function FormController($scope, $element, $attrs, formService) {
                    var _this = this;
                    _super.call(this, $scope, $element);
                    this._formService = formService;
                    if ($element.context.tagName === "FORM") {
                        this.formName = $attrs["name"];
                        this.submitFct = $attrs["ersForm"];
                        this.$element.submit(function () { _this.ersOnSubmitEventWrapper(); });
                    }
                }
                /**
                 * The function to run when the submit button is clicked.
                 */
                FormController.prototype.ersOnSubmitEventWrapper = function () {
                    if (this.$element) {
                        var formController = this.$element.scope()[this.formName];
                        if (formController.$valid) {
                            // The user "submit" function must be executed only if the form is valid.
                            this.$element.scope().$eval(this.submitFct);
                        }
                        else {
                            if (this._formService) {
                                this._formService.showValidation(this.$element);
                            }
                        }
                    }
                };
                FormController.$inject = ["$scope", "$element", "$attrs", "ersFormService"];
                return FormController;
            })(BaseComponent);
            form.FormController = FormController;
        })(form = components.form || (components.form = {}));
    })(components = ers.components || (ers.components = {}));
})(ers || (ers = {}));var ers;
(function (ers) {
    var components;
    (function (components) {
        var grid;
        (function (grid) {
            /**
             * The available data type options for the grid <code>dataType<code>.
             */
            var DataType = (function () {
                function DataType() {
                }
                /**
                 *
                 * @type {string}
                 */
                DataType.TEXT = "text";
                /**
                 *
                 * @type {string}
                 */
                DataType.DATE = "date";
                /**
                 *
                 * @type {string}
                 */
                DataType.NUMBER = "number";
                /**
                 *
                 * @type {string}
                 */
                DataType.CHECKBOX = "checkbox";
                /**
                 *
                 * @type {string}
                 */
                DataType.COMBOBOX = "combobox";
                return DataType;
            })();
            grid.DataType = DataType;
        })(grid = components.grid || (components.grid = {}));
    })(components = ers.components || (ers.components = {}));
})(ers || (ers = {}));



















var ers;
(function (ers) {
    var components;
    (function (components) {
        var grid;
        (function (grid) {
            var renderer;
            (function (renderer) {
                /**
                 * This helper is only for the column of selection checkbox we add at the
                 * beginning of the grid
                 */
                var CheckboxSelectionRenderer = (function () {
                    function CheckboxSelectionRenderer() {
                    }
                    /**
                     *
                     * @param parameters
                     */
                    CheckboxSelectionRenderer.prototype.renderer = function (cellRendererParams) {
                        var htmlElement = document.createElement("i");
                        $(htmlElement).addClass("custom-checkbox fa");
                        var changeSelection = function (selected) {
                            var classToAdd;
                            var classToRemove;
                            if (selected) {
                                classToAdd = "fa-check-square-o";
                                classToRemove = "fa-square-o";
                            }
                            else {
                                classToAdd = "fa-square-o";
                                classToRemove = "fa-check-square-o";
                            }
                            $(htmlElement).removeClass(classToRemove).addClass(classToAdd);
                        };
                        var desiredClass = cellRendererParams.api.isNodeSelected(cellRendererParams.node) ? "fa-check-square-o" : "fa-square-o";
                        $(htmlElement).addClass(desiredClass);
                        htmlElement.addEventListener("click", function (event) {
                            event.stopPropagation();
                            var selected = cellRendererParams.api.isNodeSelected(cellRendererParams.node);
                            if (!selected) {
                                cellRendererParams.api.selectNode(cellRendererParams.node, true);
                                $(htmlElement).removeClass("fa-square-o").addClass("fa-check-square-o");
                            }
                            else {
                                cellRendererParams.api.deselectNode(cellRendererParams.node);
                                $(htmlElement).removeClass("fa-check-square-o").addClass("fa-square-o");
                            }
                        });
                        cellRendererParams.api.addVirtualRowListener(cellRendererParams.rowIndex, {
                            rowSelected: function (selected) {
                                changeSelection(selected);
                            },
                            rowRemoved: function () {
                                //Noop for now
                            }
                        });
                        return htmlElement;
                    };
                    return CheckboxSelectionRenderer;
                })();
                renderer.CheckboxSelectionRenderer = CheckboxSelectionRenderer;
            })(renderer = grid.renderer || (grid.renderer = {}));
        })(grid = components.grid || (components.grid = {}));
    })(components = ers.components || (ers.components = {}));
})(ers || (ers = {}));var ers;
(function (ers) {
    var components;
    (function (components) {
        var grid;
        (function (grid) {
            /**
             *
             * A helper class that specifies the row selection mode (rowSelection)
             * in your grid options.
             *
             */
            var RowSelectionMode = (function () {
                function RowSelectionMode() {
                }
                /**
                 * This selection mode allows multiple rows to be selected at one time.
                 * @type {string}
                 */
                RowSelectionMode.MULTIPLE = "multiple";
                /**
                 * This selection mode allows only one row to be selected at a time. When a second row is selected, the first
                 * is unselected.
                 *
                 * @type {string}
                 */
                RowSelectionMode.SINGLE = "single";
                return RowSelectionMode;
            })();
            grid.RowSelectionMode = RowSelectionMode;
        })(grid = components.grid || (components.grid = {}));
    })(components = ers.components || (ers.components = {}));
})(ers || (ers = {}));
var ers;
(function (ers) {
    var components;
    (function (components) {
        var grid;
        (function (grid) {
            var renderer;
            (function (renderer) {
                /**
                 *
                 * The first column or default cell renderer for a tree grid.
                 *
                 */
                var TreeviewCellRender = (function () {
                    function TreeviewCellRender() {
                    }
                    /**
                     *
                     * @param parameters
                     */
                    TreeviewCellRender.prototype.renderer = function (cellRendererParams) {
                        var className = "ag-parent-node";
                        /*
                         * We check if we have a parent node or a leaf. If it's the case, we apply a s
                         */
                        if (angular.isDefined(cellRendererParams.node["group"]) && !cellRendererParams.node["group"]) {
                            className = "ag-leaf-node";
                        }
                        return "<span class='" + className + "'>" + cellRendererParams.value + "</span>";
                    };
                    return TreeviewCellRender;
                })();
                renderer.TreeviewCellRender = TreeviewCellRender;
            })(renderer = grid.renderer || (grid.renderer = {}));
        })(grid = components.grid || (components.grid = {}));
    })(components = ers.components || (ers.components = {}));
})(ers || (ers = {}));var ers;
(function (ers) {
    var components;
    (function (components) {
        var grid;
        (function (grid) {
            var utils;
            (function (utils) {
                var StringUtils = (function () {
                    function StringUtils() {
                    }
                    /**
                     *
                     * Transforms a camelCase string to a dash separated string&#151;words separated by a dash and all in lower case.
                     * For example, ngRequired becomes ng-required. See
                     * <a href="http://www.devcurry.com/2011/07/javascript-convert-camelcase-to-dashes.html">
                     *     http://www.devcurry.com/2011/07/javascript-convert-camelcase-to-dashes.html/> for more information.
                     *
                     * @param str
                     * @returns {any}
                     */
                    StringUtils.camelToDash = function (str) {
                        return str.replace(/\W+/g, "-").replace(/([a-z\d])([A-Z])/g, "$1-$2").toLowerCase();
                    };
                    return StringUtils;
                })();
                utils.StringUtils = StringUtils;
            })(utils = grid.utils || (grid.utils = {}));
        })(grid = components.grid || (components.grid = {}));
    })(components = ers.components || (ers.components = {}));
})(ers || (ers = {}));




var ers;
(function (ers) {
    var components;
    (function (components) {
        var grid;
        (function (grid) {
            var renderer;
            (function (renderer) {
                var KEY = ers.components.utility.KEY;
                /**
                 * A common renderer for editing data in the grid. You should not use this. You should extend
                 * this one a customize the exprience following your needs.
                 */
                var CommonErsInputRenderer = (function () {
                    /**
                     *
                     * @param $scope
                     * @param $compile
                     * @param $filterService
                     */
                    function CommonErsInputRenderer($scope, $compile, $filterService) {
                        this.$scope = $scope;
                        this.$compile = $compile;
                        this.$filterService = $filterService;
                    }
                    /**
                     * Default method to give to the grid (cellRenderer field of the column definition).
                     * This method will return the content depending on the mode. If the desired mode is
                     * edition (formalized by the editing field of the column definition), this render
                     * will return an HTMLElement object containing the editor. Otherwise, the reader
                     * is returned.
                     * @param params
                     * @returns {HTMLElement}
                     */
                    CommonErsInputRenderer.prototype.renderer = function (params) {
                        // Set data access
                        this.setDataAccess(params);
                        // Renderer
                        var result;
                        if (!angular.isDefined(params.colDef["editing"]) || angular.equals(params.colDef["editing"], false)) {
                            //This is the viewing mode, we check if the use provided a custom cell render and use it
                            //or use our viewer
                            if (angular.isDefined(params.colDef["userCellRenderer"])) {
                                result = this.getUserCellRender(params);
                            }
                            else {
                                result = this.getReadingView(params);
                            }
                            if (params.colDef["ersEditable"]) {
                                $(result).dblclick(this.onDoubleClick.bind(this, params, result));
                            }
                        }
                        else if (angular.equals(params.colDef["editing"], true)) {
                            result = this.getEditingView(params);
                        }
                        return result;
                    };
                    /**
                     * Default Cell Value getter.
                     * @param params grid raw data and definition
                     */
                    CommonErsInputRenderer.prototype.setDataAccess = function (params) {
                        // If no default value getter is defined, a value getter is forced.
                        // The data is then provided the default behavior => params.data[column name].
                        if (!params.colDef.valueGetter) {
                            params.colDef.valueGetter = function (params) {
                                if (params.data[params.colDef.field] != null && angular.isDefined(params.data[params.colDef.field])) {
                                    return params.data[params.colDef.field];
                                }
                            };
                        }
                    };
                    /**
                     * Just to be able to distinguish this text portion from a component and easily a
                     * CSS style only to this text otherwise my option was to apply a style to the upper
                     * span but then, the component had herited the CSS properties which i didn't wanted.
                     * @param value
                     * @returns {HTMLElement}
                     */
                    CommonErsInputRenderer.prototype.getReadingView = function (params) {
                        var cell = document.createElement("span");
                        cell.className = "ag-cell-value-read";
                        var value = params.value;
                        var eLabel = document.createTextNode(value ? value.toString() : "");
                        cell.appendChild(eLabel);
                        this.restoreCellOverflow(params);
                        return cell;
                    };
                    /**
                     * The grid default's overflow value of cells is hidden. It must be hidden when we
                     * are in reading mode otherwise we can have visual glitch. Be sure to call
                     * this method when you a in reading mode.
                     * @param params
                     */
                    CommonErsInputRenderer.prototype.restoreCellOverflow = function (params) {
                        if (angular.isDefined(params.colDef.cellStyle)) {
                            params.colDef.cellStyle["overflow"] = "hidden";
                        }
                        else {
                            params.colDef.cellStyle = {
                                overflow: "hidden"
                            };
                        }
                    };
                    /**
                     * Return the user's cell render wrapped into an HTMLElement if it's a string.
                     *
                     * @param params
                     * @returns {HTMLElement}
                     */
                    CommonErsInputRenderer.prototype.getUserCellRender = function (params) {
                        var result;
                        var tmpResult = params.colDef["userCellRenderer"](params);
                        if (typeof tmpResult === "string") {
                            result = document.createElement("span");
                            result.innerHTML = tmpResult;
                        }
                        else {
                            result = tmpResult;
                        }
                        if (angular.isDefined(params.colDef.cellStyle)) {
                            params.colDef.cellStyle["overflow"] = "hidden";
                        }
                        else {
                            params.colDef.cellStyle = {
                                overflow: "hidden"
                            };
                        }
                        return result;
                    };
                    /**
                     * It will check provided options (listed in IErsCellRendererOptions) and
                     * for each options, if needed, add it to the provided HTML element
                     * @param options
                     * @returns {string}
                     */
                    CommonErsInputRenderer.prototype.getOptionsAsString = function (options) {
                        var result = "";
                        if (angular.isDefined(options)) {
                            if (angular.equals(options.ngRequired, true)) {
                                result += " ng-required='true'";
                            }
                            if (angular.equals(options.ngDisabled, true)) {
                                result += " ng-disabled='true'";
                            }
                            if (angular.equals(options.ngReadonly, true)) {
                                result += " ng-readonly='true'";
                            }
                        }
                        return result;
                    };
                    /**
                     * Return the editor
                     * @param params
                     * @returns {HTMLElement}
                     */
                    CommonErsInputRenderer.prototype.getEditingView = function (params) {
                        var result = document.createElement("span");
                        var scope = this.$scope.$new();
                        scope["params"] = params;
                        var inputTemplate = "<input ng-model='params.value' />";
                        var compiledTemplate = this.$compile(inputTemplate)(scope);
                        scope.$apply();
                        this.bindEvent(compiledTemplate, params, scope);
                        $(result).empty();
                        $(result).append(compiledTemplate);
                        return result;
                    };
                    /**
                     *
                     * @param compiledTemplate
                     * @param params
                     * @param scope
                     */
                    CommonErsInputRenderer.prototype.bindEvent = function (compiledTemplate, params, scope) {
                        var _this = this;
                        var theInput = $(compiledTemplate).find("input");
                        theInput.on("blur", this.onBlur.bind(this, params, scope));
                        theInput.keydown(function (keyboardEvent) {
                            _this.onKeydown(keyboardEvent, params, scope);
                        });
                    };
                    /**
                     * This method will just update the 'editing' field of the column definition and switch
                     * it the true and launch a cell refresh
                     * @param params
                     * @param cell
                     * @param event
                     */
                    CommonErsInputRenderer.prototype.onDoubleClick = function (params, cell, event) {
                        //Nothing to do in this case
                        event.stopPropagation();
                        //Flag the column as being in edit mode and refresh the cell
                        params.colDef["editing"] = true;
                        params.refreshCell();
                        $(params.eGridCell.getElement()).find("input").focus();
                    };
                    /**
                     * Called when we leave the editor. Check if we are in edit mode and update the editing
                     * field value if it's the case.
                     * Finally, it will launch a cell refresh to update it.
                     * @param params
                     * @param scope
                     * @param targetedCell
                     */
                    CommonErsInputRenderer.prototype.onBlur = function (event, params, scope) {
                        void 0;
                        //In order to avoid loop
                        if (angular.equals(params.colDef["editing"], true)) {
                            delete params.colDef["editing"];
                            params.refreshCell();
                            //Checking if the returned value is undefined (accepted by the textbox.
                            //If not the case, i restore the old value
                            void 0;
                            if (angular.isDefined(params.value)) {
                                var oldValue = this.getData(params);
                                var valueChanged = oldValue !== params.value;
                                if (valueChanged) {
                                    this.changeData(params);
                                }
                            }
                            else {
                                params.value = oldValue;
                            }
                            scope.$destroy();
                        }
                    };
                    CommonErsInputRenderer.prototype.getData = function (params) {
                        if (angular.isDefined(params.colDef.valueGetter)) {
                            if (angular.isFunction(params.colDef.valueGetter)) {
                                return params.colDef.valueGetter(params);
                            }
                            else {
                                return params.colDef.valueGetter;
                            }
                        }
                        else {
                            return params.data[params.colDef.field];
                        }
                    };
                    /**
                     * Will check if the user has set a value setter and use it if it's the case. Otherwise, will store
                     * it in params.data. Moreover, it will trigger needed event for AG-Grid to detect data change.
                     * @param params
                     */
                    CommonErsInputRenderer.prototype.changeData = function (params) {
                        var paramsForCallbacks = {
                            node: params.node,
                            data: params.node["data"],
                            oldValue: this.getData(params),
                            newValue: params.value,
                            rowIndex: params.rowIndex,
                            colDef: params.colDef,
                            api: params.api,
                            context: params.context
                        };
                        if (angular.isDefined(params.colDef.newValueHandler)) {
                            params.colDef.newValueHandler(paramsForCallbacks);
                        }
                        else {
                            params.data[params.colDef.field] = params.value;
                        }
                        if (typeof params.colDef["onCellValueChanged"] === "function") {
                            params.colDef["onCellValueChanged"](paramsForCallbacks);
                        }
                        params.api["eventService"].dispatchEvent(ag.grid.Events.EVENT_CELL_VALUE_CHANGED, paramsForCallbacks);
                    };
                    /**
                     * Try to intercept ENTER and ESCAPE in order to validate data in editing mode
                     * of discard it
                     * @param keyboardEvent
                     * @param params
                     * @param scope
                     */
                    CommonErsInputRenderer.prototype.onKeydown = function (keyboardEvent, params, scope) {
                        if (keyboardEvent.which === KEY.ENTER) {
                            this.onBlur(keyboardEvent, params, scope);
                        }
                        else if (keyboardEvent.which === KEY.ESCAPE) {
                            //If the user choose ESCAPE, we restore the old value and
                            //launch the blur process
                            params.value = params.data[params.colDef.field];
                            this.onBlur(keyboardEvent, params, scope);
                        }
                    };
                    return CommonErsInputRenderer;
                })();
                renderer.CommonErsInputRenderer = CommonErsInputRenderer;
            })(renderer = grid.renderer || (grid.renderer = {}));
        })(grid = components.grid || (components.grid = {}));
    })(components = ers.components || (ers.components = {}));
})(ers || (ers = {}));





var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var ers;
(function (ers) {
    var components;
    (function (components) {
        var grid;
        (function (grid) {
            var renderer;
            (function (renderer) {
                var StringUtils = ers.components.grid.utils.StringUtils;
                var ErsTextboxRenderer = (function (_super) {
                    __extends(ErsTextboxRenderer, _super);
                    /**
                     *
                     * @param $scope
                     * @param $compile
                     * @param $filterService
                     */
                    function ErsTextboxRenderer($scope, $compile, $filterService) {
                        _super.call(this, $scope, $compile, $filterService);
                    }
                    /**
                     *
                     * @param $scope
                     * @param $compile
                     * @param $filterService
                     * @returns {ErsTextboxRenderer}
                     */
                    ErsTextboxRenderer.getInstance = function ($scope, $compile, $filterService) {
                        //Since JS is single thread, this should work. No synchronized needed.
                        if (!angular.isDefined(this._instance)) {
                            this._instance = new ErsTextboxRenderer($scope, $compile, $filterService);
                        }
                        return this._instance;
                    };
                    /**
                     * Return the editor (an Ers Textbox component)
                     * @param params
                     * @returns {HTMLElement}
                     */
                    ErsTextboxRenderer.prototype.getEditingView = function (params) {
                        var result = document.createElement("span");
                        var ersTextboxScope = this.$scope.$new();
                        ersTextboxScope["params"] = params;
                        var ersTextboxTemplate = "<ers-textbox ng-model='params.value' ";
                        if (angular.isDefined(params.colDef.ersCellRendererOptions)) {
                            ersTextboxTemplate += this.getOptionsAsString(params.colDef.ersCellRendererOptions);
                        }
                        ersTextboxTemplate += "></ers-textbox>";
                        var compiledTemplate = this.$compile(ersTextboxTemplate)(ersTextboxScope);
                        ersTextboxScope.$apply();
                        this.bindEvent(compiledTemplate, params, ersTextboxScope);
                        $(result).empty();
                        $(result).append(compiledTemplate);
                        return result;
                    };
                    /**
                     *
                     * Bind the keydown and blur events to the component so the user can exit the
                     * editor.
                     *
                     * @param compiledTemplate
                     * @param params
                     * @param ersTextboxScope
                     *
                     */
                    ErsTextboxRenderer.prototype.bindEvent = function (compiledTemplate, params, ersTextboxScope) {
                        var _this = this;
                        var theInput = $(compiledTemplate).find("input");
                        theInput.blur(function (blurEvent) {
                            _this.onBlur(blurEvent, params, ersTextboxScope);
                        });
                        theInput.keydown(function (keyboardEvent) {
                            _this.onKeydown(keyboardEvent, params, ersTextboxScope);
                        });
                    };
                    /**
                     *
                     * @param options
                     * @returns {string}
                     *
                     */
                    ErsTextboxRenderer.prototype.getOptionsAsString = function (options) {
                        var result = _super.prototype.getOptionsAsString.call(this, options);
                        if (angular.isDefined(options)) {
                            //For each provided option, we add it to the template
                            ["name", "ngPattern", "ngMinLength", "ngMaxlength", "textAlign"].forEach(function (field) {
                                if (angular.isDefined(options[field])) {
                                    result += " " + StringUtils.camelToDash(field) + "=\"" + options[field] + "\"";
                                }
                            });
                        }
                        return result;
                    };
                    return ErsTextboxRenderer;
                })(renderer.CommonErsInputRenderer);
                renderer.ErsTextboxRenderer = ErsTextboxRenderer;
            })(renderer = grid.renderer || (grid.renderer = {}));
        })(grid = components.grid || (components.grid = {}));
    })(components = ers.components || (ers.components = {}));
})(ers || (ers = {}));





var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var ers;
(function (ers) {
    var components;
    (function (components) {
        var grid;
        (function (grid) {
            var renderer;
            (function (renderer) {
                var KEY = ers.components.utility.KEY;
                var StringUtils = ers.components.grid.utils.StringUtils;
                var ErsNumberRenderer = (function (_super) {
                    __extends(ErsNumberRenderer, _super);
                    function ErsNumberRenderer($scope, $compile, $filterService) {
                        _super.call(this, $scope, $compile, $filterService);
                    }
                    /**
                     * Let the developer retrieve the current instance of the singleton.
                     *
                     * @param $scope
                     * @param $compile
                     * @param $filterService
                     * @returns {ErsNumberRenderer}
                     *
                     */
                    ErsNumberRenderer.getInstance = function ($scope, $compile, $filterService) {
                        //Since JS is single thread, this should work. No synchronized needed.
                        if (!angular.isDefined(this._instance)) {
                            this._instance = new ErsNumberRenderer($scope, $compile, $filterService);
                        }
                        return this._instance;
                    };
                    /**
                     * Return the reader part of the renderer and apply the any filter (if any)
                     * to the data before rendering.
                     *
                     * @param params
                     * @returns {HTMLElement}
                     */
                    ErsNumberRenderer.prototype.getReadingView = function (params) {
                        var filter = "amount";
                        if (angular.isDefined(params.colDef.ersCellRendererOptions) &&
                            angular.isDefined(params.colDef.ersCellRendererOptions["format"])) {
                            filter = params.colDef.ersCellRendererOptions["format"];
                        }
                        var cell = document.createElement("span");
                        cell.className = "ag-cell-value-read";
                        //var value:string[] = <string[]> [params.value];
                        var eLabel = document.createTextNode(this.$filterService(filter)(params.value));
                        cell.appendChild(eLabel);
                        return cell;
                    };
                    /**
                     * Return the HTMLElement containing the Numberbox editor
                     * @param params
                     * @returns {HTMLElement}
                     */
                    ErsNumberRenderer.prototype.getEditingView = function (params) {
                        var result = document.createElement("span");
                        var ersNumberScope = this.$scope.$new();
                        ersNumberScope["params"] = params;
                        var ersNumberTemplate = "<ers-number ng-model='params.value' ";
                        if (angular.isDefined(params.colDef.ersCellRendererOptions)) {
                            ersNumberTemplate += this.getOptionsAsString(params.colDef.ersCellRendererOptions);
                        }
                        ersNumberTemplate += "></ers-number>";
                        var compiledTemplate = this.$compile(ersNumberTemplate)(ersNumberScope);
                        ersNumberScope.$apply();
                        this.bindEvent(compiledTemplate, params, ersNumberScope);
                        $(result).append(compiledTemplate);
                        //We give the focus to the input before return the result
                        $(result).find("input").focus();
                        return result;
                    };
                    /**
                     *
                     * Bind keyboard and blur events to the appropriate elements.
                     *
                     * @param compiledTemplate
                     * @param params
                     * @param ersNumberScope
                     *
                     */
                    ErsNumberRenderer.prototype.bindEvent = function (compiledTemplate, params, ersNumberScope) {
                        var _this = this;
                        var theInput = $(compiledTemplate).find("input");
                        theInput.blur(function (blurEvent) {
                            _this.onBlur(blurEvent, params, ersNumberScope);
                        });
                        theInput.keydown(function (keyboardEvent) {
                            _this.onKeydown(keyboardEvent, params, ersNumberScope);
                        });
                    };
                    /**
                     *
                     * Overrides the parent behavior and implements an escape handler for ersNumber.
                     * @param keyboardEvent
                     * @param params
                     * @param scope
                     * @param cell
                     *
                     */
                    ErsNumberRenderer.prototype.onKeydown = function (keyboardEvent, params, scope) {
                        void 0;
                        if (keyboardEvent.which === KEY.ENTER) {
                            this.onBlur(keyboardEvent, params, scope);
                        }
                    };
                    /**
                     * Check the options of the renderer (see IErsNumberRendererOptions) and add it to
                     * the template
                     * @param options
                     * @returns {string}
                     */
                    ErsNumberRenderer.prototype.getOptionsAsString = function (options) {
                        var result = _super.prototype.getOptionsAsString.call(this, options);
                        if (angular.isDefined(options)) {
                            //For each provided option, we add it to the template
                            ["name", "min", "max", "textAlign", "format"].forEach(function (field) {
                                if (angular.isDefined(options[field])) {
                                    result += " " + StringUtils.camelToDash(field) + "=\"" + options[field] + "\"";
                                }
                            });
                        }
                        return result;
                    };
                    return ErsNumberRenderer;
                })(renderer.CommonErsInputRenderer);
                renderer.ErsNumberRenderer = ErsNumberRenderer;
            })(renderer = grid.renderer || (grid.renderer = {}));
        })(grid = components.grid || (components.grid = {}));
    })(components = ers.components || (ers.components = {}));
})(ers || (ers = {}));/**
 * Created by GunduzB on 7/3/2015.
 */







var ers;
(function (ers) {
    var components;
    (function (components) {
        var grid;
        (function (grid) {
            var renderer;
            (function (renderer) {
                /*
              
                 * Notice that the full ers-checkbox component isn't used because it is a full
                 * angularjs component. In this use case, a full Angularjs checkbox has a heavy impact on
                 * performance.
                 *
                 */
                var ErsCheckboxRenderer = (function () {
                    function ErsCheckboxRenderer($scope, $compile) {
                        this.$scope = $scope;
                        this.$compile = $compile;
                    }
                    /**
                     * Allows you to retrieve the individual checkbox.
                     * @param $scope
                     * @param $compile
                     * @returns {ErsCheckboxRenderer}
                     */
                    ErsCheckboxRenderer.getInstance = function ($scope, $compile) {
                        //Since JS is single thread, this should work. No synchronized needed.
                        if (!angular.isDefined(this._instance)) {
                            this._instance = new ErsCheckboxRenderer($scope, $compile);
                        }
                        return this._instance;
                    };
                    ErsCheckboxRenderer.prototype.renderer = function (cellRendererParams) {
                        var SELECTED_CLASS = "fa-check-square-o";
                        var UNSELECTED_CLASS = "fa-square-o";
                        var isReadonly = false;
                        var isDisabled = false;
                        var trueValue = true;
                        var falseValue = false;
                        var checkboxElement = document.createElement("i");
                        $(checkboxElement).addClass("erscheckbox fa");
                        if (angular.equals(cellRendererParams.colDef.ersCellRendererOptions["ngReadonly"], true)
                            || angular.equals(cellRendererParams.colDef.ersCellRendererOptions["ngReadonly"], "true")
                            || angular.isUndefined(cellRendererParams.colDef["ersEditable"])
                            || angular.equals(cellRendererParams.colDef["ersEditable"], false)) {
                            $(checkboxElement).addClass("readonly");
                            isReadonly = true;
                        }
                        if (angular.equals(cellRendererParams.colDef.ersCellRendererOptions["ngDisabled"], true)
                            || angular.equals(cellRendererParams.colDef.ersCellRendererOptions["ngDisabled"], "true")) {
                            $(checkboxElement).addClass("disabled");
                            isDisabled = true;
                        }
                        if (angular.isDefined(cellRendererParams.colDef.ersCellRendererOptions["ngTrueValue"])) {
                            trueValue = cellRendererParams.colDef.ersCellRendererOptions["ngTrueValue"];
                        }
                        if (angular.isDefined(cellRendererParams.colDef.ersCellRendererOptions["ngFalseValue"])) {
                            falseValue = cellRendererParams.colDef.ersCellRendererOptions["ngFalseValue"];
                        }
                        var changeSelection = function (selected) {
                            if (selected) {
                                $(checkboxElement).removeClass(UNSELECTED_CLASS).addClass(SELECTED_CLASS);
                            }
                            else {
                                $(checkboxElement).removeClass(SELECTED_CLASS).addClass(UNSELECTED_CLASS);
                            }
                        };
                        var isSelected = function () {
                            return angular.equals(cellRendererParams.value, trueValue);
                        };
                        changeSelection(isSelected());
                        //If the renderer is in read only mode, we don't bind a click listener
                        if (!isReadonly && !isDisabled && (angular.equals(cellRendererParams.colDef["ersEditable"], true))) {
                            checkboxElement.addEventListener("click", function (event) {
                                if (isSelected()) {
                                    cellRendererParams.data[cellRendererParams.colDef.field] = falseValue;
                                }
                                else {
                                    cellRendererParams.data[cellRendererParams.colDef.field] = trueValue;
                                }
                                cellRendererParams.value = cellRendererParams.data[cellRendererParams.colDef.field];
                                cellRendererParams.refreshCell();
                                var paramsForCallbacks = {
                                    node: cellRendererParams.node,
                                    data: cellRendererParams.node["data"],
                                    oldValue: cellRendererParams.data[cellRendererParams.colDef.field],
                                    newValue: cellRendererParams.value,
                                    rowIndex: cellRendererParams.rowIndex,
                                    colDef: cellRendererParams.colDef,
                                    api: cellRendererParams.api,
                                    context: cellRendererParams.context
                                };
                                if (typeof cellRendererParams.colDef["onCellValueChanged"] === "function") {
                                    cellRendererParams.colDef["onCellValueChanged"](paramsForCallbacks);
                                }
                                cellRendererParams.api["eventService"].dispatchEvent(ag.grid.Events.EVENT_CELL_VALUE_CHANGED, paramsForCallbacks);
                            });
                        }
                        return checkboxElement;
                    };
                    return ErsCheckboxRenderer;
                })();
                renderer.ErsCheckboxRenderer = ErsCheckboxRenderer;
            })(renderer = grid.renderer || (grid.renderer = {}));
        })(grid = components.grid || (components.grid = {}));
    })(components = ers.components || (ers.components = {}));
})(ers || (ers = {}));


var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var ers;
(function (ers) {
    var components;
    (function (components) {
        var grid;
        (function (grid) {
            var renderer;
            (function (renderer) {
                var ErsComboboxRenderer = (function (_super) {
                    __extends(ErsComboboxRenderer, _super);
                    function ErsComboboxRenderer($scope, $compile, $filterService) {
                        _super.call(this, $scope, $compile, $filterService);
                    }
                    /**
                     * Allows you to retrieve the individual combobox.
                     * @param $scope
                     * @param $compile
                     * @param $filterService
                     * @returns {ErsComboboxRenderer}
                     */
                    ErsComboboxRenderer.getInstance = function ($scope, $compile, $filterService) {
                        //Since JS is single thread, this should work. No synchronized needed.
                        if (!angular.isDefined(this._instance)) {
                            this._instance = new ErsComboboxRenderer($scope, $compile, $filterService);
                        }
                        return this._instance;
                    };
                    /**
                     * Returns the HTMLElement editor.
                     * @param params
                     * @returns {HTMLElement}
                     */
                    ErsComboboxRenderer.prototype.getEditingView = function (params) {
                        var result = document.createElement("span");
                        var ersComboboxScope = this.$scope.$new();
                        var compiledTemplate = this.getCompiledTemplate(params, ersComboboxScope);
                        this.bindEvents(compiledTemplate, params, ersComboboxScope);
                        $(result).append(compiledTemplate);
                        params.colDef.cellStyle = {
                            overflow: "visible"
                        };
                        return result;
                    };
                    /**
                     *
                     * Aggregates the HTML with options, binds a scope, and sends it to Angular to compile.
                     * @param params
                     * @param ersComboboxScope
                     * @returns {ng.IAugmentedJQuery}
                     *
                     */
                    ErsComboboxRenderer.prototype.getCompiledTemplate = function (params, ersComboboxScope) {
                        var options = params.colDef.ersCellRendererOptions;
                        ersComboboxScope["params"] = params;
                        ersComboboxScope["items"] = options.items;
                        var ersComboboxTemplate = "<ers-combobox ng-model='params.value' ";
                        ersComboboxTemplate += this.getOptionsAsString(options);
                        ersComboboxTemplate += ">";
                        ersComboboxTemplate += this.getItemsTemplate(params, ersComboboxScope);
                        ersComboboxTemplate += "</ers-combobox>";
                        var compiledTemplate = this.$compile(ersComboboxTemplate)(ersComboboxScope);
                        return compiledTemplate;
                    };
                    /**
                     *
                     * An internal method that creates the corresponding HTML combobox entries.
                     * @param params
                     * @param ersComboboxScope
                     * @returns {string}
                     *
                     */
                    ErsComboboxRenderer.prototype.getItemsTemplate = function (params, ersComboboxScope) {
                        //Now listing items
                        var options = params.colDef.ersCellRendererOptions;
                        var ersComboboxTemplate = "<ers-combobox-item ng-repeat='item in items' ";
                        ersComboboxTemplate += "value='item'>";
                        ersComboboxTemplate += "<span>";
                        if (angular.isDefined(options.innerRenderer)) {
                            ersComboboxScope["innerRenderer"] = options.innerRenderer;
                            ersComboboxTemplate += "{{ innerRenderer(item) }}";
                        }
                        else {
                            ersComboboxTemplate += "{{ item }}";
                        }
                        ersComboboxTemplate += "</span>";
                        ersComboboxTemplate += "</ers-combobox-item>";
                        return ersComboboxTemplate;
                    };
                    /**
                     * Binds the desired keyboard events and 'on change' events to the corresponding onBlue and onKeydown methods.
                     *
                     * See the onBlur and onKeydown method of the CommonersInputRenderer for more information about
                     * those events.
                     *
                     * @param compiledTemplate
                     * @param params
                     * @param ersComboboxScope
                     *
                     */
                    ErsComboboxRenderer.prototype.bindEvents = function (compiledTemplate, params, ersComboboxScope) {
                        var _this = this;
                        $(compiledTemplate).change(function (event) {
                            _this.onBlur(event, params, ersComboboxScope);
                        });
                        // $timeout is required here because DOM element may not completely load when this event fired
                        // So, we need to delay the event treatment. (be careful minification)
                        var injFn = function ($timeout) {
                            $timeout(function () {
                                $(compiledTemplate).find("button").on("blur", function (event) {
                                    void 0;
                                    _this.onBlur(event, params, ersComboboxScope);
                                });
                            }, 0);
                        };
                        injFn.$inject = ["$timeout"];
                        angular.injector(["ng"]).invoke(injFn);
                        $(compiledTemplate).find(".dropdown-select").keydown(function (keyboardEvent) {
                            _this.onKeydown(keyboardEvent, params, ersComboboxScope);
                        });
                    };
                    ErsComboboxRenderer.prototype.onDoubleClick = function (params, cell, event) {
                        _super.prototype.onDoubleClick.call(this, params, cell, event);
                        // wait the Dom to be ready to focus on combobox input
                        var delayFn = function ($timeout) {
                            $timeout(function () {
                                $(params.eGridCell.getElement()).find("button").focus();
                            }, 0);
                        };
                        delayFn.$inject = ["$timeout"];
                        angular.injector(["ng"]).invoke(delayFn);
                    };
                    return ErsComboboxRenderer;
                })(renderer.CommonErsInputRenderer);
                renderer.ErsComboboxRenderer = ErsComboboxRenderer;
            })(renderer = grid.renderer || (grid.renderer = {}));
        })(grid = components.grid || (components.grid = {}));
    })(components = ers.components || (ers.components = {}));
})(ers || (ers = {}));


var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var ers;
(function (ers) {
    var components;
    (function (components) {
        var grid;
        (function (grid) {
            var renderer;
            (function (renderer) {
                var ErsCalendarRenderer = (function (_super) {
                    __extends(ErsCalendarRenderer, _super);
                    /**
                     *
                     * @param $scope
                     * @param $compile
                     * @param $filterService
                     */
                    function ErsCalendarRenderer($scope, $compile, $filterService) {
                        _super.call(this, $scope, $compile, $filterService);
                    }
                    /**
                     * return the singleton
                     * @param $scope
                     * @param $compile
                     * @param $filterService
                     * @returns {ErsCalendarRenderer}
                     */
                    ErsCalendarRenderer.getInstance = function ($scope, $compile, $filterService) {
                        //Since JS is single thread, this should work. No synchronized needed.
                        if (!angular.isDefined(this._instance)) {
                            this._instance = new ErsCalendarRenderer($scope, $compile, $filterService);
                        }
                        return this._instance;
                    };
                    /**
                     * The calendar has a formatter and can be configured by the user using the dedicated
                     * option. (see Calendar component IErsCalendarRendererOptions for more information
                     * about available options)
                     * @param params
                     */
                    ErsCalendarRenderer.prototype.getReadingView = function (params) {
                        var dateFormat = ers.components.calendar.CalendarComponent.DEFAULT_DATE_FORMAT;
                        if (angular.isDefined(params.colDef.ersCellRendererOptions) &&
                            angular.isDefined(params.colDef.ersCellRendererOptions["dateFormat"])) {
                            dateFormat = params.colDef.ersCellRendererOptions["dateFormat"];
                        }
                        var cell = document.createElement("span");
                        cell.className = "ag-cell-value-read";
                        var value = params.value;
                        var eLabel = document.createTextNode(this.$filterService("date")(value, dateFormat));
                        cell.appendChild(eLabel);
                        this.restoreCellOverflow(params);
                        return cell;
                    };
                    ErsCalendarRenderer.prototype.getEditingView = function (params) {
                        var _this = this;
                        var result = document.createElement("span");
                        var ersCalendarScope = this.$scope.$new();
                        var blur = function (blurEvent) {
                            _this.onBlur(blurEvent, params, ersCalendarScope);
                        };
                        document.addEventListener("mousewheel", function (event) {
                            _this.onBlur(event, params, ersCalendarScope);
                        }, false);
                        document.addEventListener("keydown", function (event) {
                            _this.onBlur(event, params, ersCalendarScope);
                        }, false);
                        var compiledTemplate = this.getCompiledTemplate(params, ersCalendarScope, blur);
                        var theInput = compiledTemplate.find("input");
                        theInput.keydown(function (keyboardEvent) {
                            _this.onKeydown(keyboardEvent, params, ersCalendarScope);
                        });
                        $(result).append(compiledTemplate);
                        params.colDef.cellStyle = {
                            overflow: "visible"
                        };
                        return result;
                    };
                    /**
                     * Return the calendar component template compiled by angular. We attach a scope having
                     * needed parameters before requesting the angular compile.
                     * @param params
                     * @param ersCalendarScope
                     * @returns {ng.IAugmentedJQuery}
                     */
                    ErsCalendarRenderer.prototype.getCompiledTemplate = function (params, ersCalendarScope, blur) {
                        var options = params.colDef.ersCellRendererOptions;
                        ersCalendarScope["params"] = params;
                        ersCalendarScope["blur"] = blur;
                        var dateFormat = ers.components.calendar.CalendarComponent.DEFAULT_DATE_FORMAT;
                        var ersCalendarTemplate = "<ers-calendar on-close='blur' append-to-body='false' ng-model='params.value' ";
                        ersCalendarTemplate += this.getOptionsAsString(options);
                        if (angular.isDefined(options)) {
                            if (angular.isDefined(options.dateFormat)) {
                                ersCalendarTemplate += " date-format='" + options.dateFormat + "'";
                            }
                        }
                        else {
                            ersCalendarTemplate += " date-format='" + dateFormat + "'";
                        }
                        ersCalendarTemplate += ">";
                        ersCalendarTemplate += "</ers-calendar>";
                        var compiledTemplate = this.$compile(ersCalendarTemplate)(ersCalendarScope);
                        ersCalendarScope.$apply();
                        return compiledTemplate;
                    };
                    return ErsCalendarRenderer;
                })(renderer.CommonErsInputRenderer);
                renderer.ErsCalendarRenderer = ErsCalendarRenderer;
            })(renderer = grid.renderer || (grid.renderer = {}));
        })(grid = components.grid || (components.grid = {}));
    })(components = ers.components || (ers.components = {}));
})(ers || (ers = {}));













var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
/**
 * @ngdoc directive
 * @module ers.components.grid
 * @name ersGrid
 * @binding
 * @attribute
 *
 * @restrict E
 *
 * @description
 *
 * Use the `ers-grid` component to create and display a data grid. A JSON object contains the options for column and
 * data definitions and provides data after the grid initializes. The `ers-grid` component is a wrapper around
 * the AngularJS grid component, `ag-grid`. For more information, see
 * [http://www.ag-grid.com/](http://www.ag-grid.com/javascript-grid-interfacing-overview/index.php).
 *
 * ### Usage
 *
 * The following options are available when creating a grid:
 *
 * - Basic&#151;The basic grid provides columns and rows with the following options:
 *    - Column resizing
 *    - Column definition
 *    - Column sorting
 *    - Column filtering
 * - Lazy Loading&#151;Lazy loading provides a loading message when loading a large data set and the data array is set
 * to null.
 * - Custom Renderer&#151;Each column can have a custom renderer (`cellRenderer`) to tailor the visual impact of
 * the data on a column-by-column basis.
 * - Selection/Multi-selection&#151;The `checkboxSelection` option allows you to set single rows as selectable.
 * The `rowSelection` option makes multiple rows selectable.
 * - Pagination&#151;Use pagination to navigate through the grid. Pagination works only with the associated datasource.
 * - Treeview&#151;Use treeview to display a hierarchical view of your grid. To use this feature you must formalize
 * your data grouping with `rowsAlreadyGrouped`.
 * - Edition&#151;The edition feature uses `ers-component` to create a text, a number, or a combobox style grid.
 * Indicate the data
 * type in the column definition and include the options for the underlying `ers-component` to enable this feature.
 *
 * ### Examples
 *
 * #### Basic Usage
 *
 * The following example demonstrates a basic grid:
 *
 * <code-editor identifier="example" data-title="Simple Grid" html-content-url="demos/ersGrid/simpleGrid/index.html"
 * js-content-url="demos/ersGrid/simpleGrid/script.js" css-content-url="demos/ersGrid/simpleGrid/styles.css"
 * content-mode="html"></code-editor>
 *
 * #### Sorting and Filtering
 *
 * The following example demonstrates a grid with column sorting and resizable columns:
 *
 * <code-editor identifier="example1" data-title="Sort and filter" html-content-url="demos/ersGrid/basicUsage/index.html"
 * js-content-url="demos/ersGrid/basicUsage/script.js" css-content-url="demos/ersGrid/basicUsage/styles.css"
 * content-mode="html"></code-editor>
 *
 * #### Pagination
 *
 * The following example demonstrates a grid with pagination:
 *
 * <code-editor identifier="example2" data-title="Pagination" html-content-url="demos/ersGrid/pagination/index.html"
 * js-content-url="demos/ersGrid/pagination/script.js" css-content-url="demos/ersGrid/pagination/styles.css"
 * content-mode="html"></code-editor>
 *
 * #### Selection
 *
 * The following example demonstrate a grid with data row selection (Press 'Ctrl' for multiselection):
 *
 * <code-editor identifier="example3" data-title="Selection" html-content-url="demos/ersGrid/multiSelect/index.html"
 * js-content-url="demos/ersGrid/multiSelect/script.js" css-content-url="demos/ersGrid/multiSelect/styles.css"
 * content-mode="html"></code-editor>
 *
 * #### Treeview
 *
 * The following example demonstrate a grid which display your data in a tree view:
 *
 * <code-editor identifier="example4" data-title="Treeview" html-content-url="demos/ersGrid/treeview/index.html"
 * js-content-url="demos/ersGrid/treeview/script.js" css-content-url="demos/ersGrid/treeview/styles.css"
 * content-mode="html"></code-editor>
 *
 * #### Frozen columns
 *
 * The following example demonstrate a grid with frozen columns:
 *
 * <code-editor identifier="example5" data-title="Frozen columns"
 * html-content-url="demos/ersGrid/frozenColumns/index.html"
 * js-content-url="demos/ersGrid/frozenColumns/script.js" css-content-url="demos/ersGrid/frozenColumns/styles.css"
 * content-mode="html"></code-editor>
 *
 * #### Tooltip on columns
 *
 * The following example demonstrate how to set a tooltip on column.
 *
 * - Column 'GUID' has a tooltip:
 *
 * <code-editor identifier="example6" data-title="Tooltip columns"
 * html-content-url="demos/ersGrid/longlabelTooltip/index.html"
 * js-content-url="demos/ersGrid/longlabelTooltip/script.js" css-content-url="demos/ersGrid/longlabelTooltip/styles.css"
 * content-mode="html"></code-editor>
 *
 * #### Min-max width columns
 *
 * The following example demonstrate how to set minimum and maximum width of the column while resizing:
 *
 * - Column 'GUID' is set with minimum and maximum width.
 * - Minimum width: 80px
 * - Maximum width: 260px
 *
 * <code-editor identifier="example7" data-title="min-max width"
 * html-content-url="demos/ersGrid/minmaxWidth/index.html"
 * js-content-url="demos/ersGrid/minmaxWidth/script.js" css-content-url="demos/ersGrid/minmaxWidth/styles.css"
 * content-mode="html"></code-editor>
 *
 * ### Design Guidelines
 * There are no specific visual design or styling guidelines for `ers-grid`.
 *
 * ### Accessibility Guidelines
 *
 * No accessibility guidelines
 *
 *
 * @param {object} options Sets the grid options.
 *
 * See the [IGridOptions](http://galileo/typedoc/interfaces/ers.components.grid.igridoptions.html)
 * API for a full list of grid options.
 *
 *
 */
/*
 * <!-- ```xml
 * <ers-grid options="myOpts"></ers-grid>
 * ```
 */
var ers;
(function (ers) {
    var components;
    (function (components) {
        var grid;
        (function (grid) {
            var BaseComponent = ers.components.core.BaseComponent;
            var CheckboxSelectionRenderer = grid.renderer.CheckboxSelectionRenderer;
            /**
             * The Angular module definition for <code>ers-grid</code>.
             *
             */
            angular.module("ers.components.grid", [
                ers.components.core.coreModule.name,
                "ers.components.textbox",
                "ers.components.numberbox",
                "ers.components.checkbox",
                "ers.components.combobox",
                "agGrid"
            ]);
            /**
             * The Angular module containing all necessary resources for the grid component.
             *
             * @type {IModule}
             *
             */
            grid.gridModule = angular.module("ers.components.grid");
            /**
             * Directive definition for the <code>ers-grid</code>.
             */
            grid.gridModule.directive("ersGrid", function () {
                return {
                    restrict: "E",
                    templateUrl: "grid/template/grid-template.html",
                    scope: {
                        options: "="
                    },
                    controller: GridComponent,
                    controllerAs: "gridController",
                    bindToController: true,
                    require: "ersGrid",
                    link: function (scope, element, attributes, controller) {
                        controller.init();
                    }
                };
            });
            /**
             * The Grid controller.
             */
            var GridComponent = (function (_super) {
                __extends(GridComponent, _super);
                function GridComponent(logger, $element, $attributes, $scope, $compile, $filterService) {
                    _super.call(this, $scope, $element, $attributes);
                    /**
                     *
                     * This flag is set to true when the grid is ready. If grid options are
                     * not provided, the flag stays set to false.
                     *
                     * @type {boolean}
                     *
                     */
                    this.initialized = false;
                    /**
                     * This variable stores the user message displayed when the grid
                     * is loading or when a grid issue occurs.
                     *
                     * @type {string}
                     */
                    this.loadingMessage = GridComponent.MESSAGES[0];
                    this.logger = logger;
                    this.$compile = $compile;
                    this.$filterService = $filterService;
                }
                /**
                 *
                 * Initializes the components, customizing the grid before it renders.
                 *
                 */
                GridComponent.prototype.init = function () {
                    this.$element.addClass("ers-grid");
                    //Do the work only if we have options.
                    if (angular.isDefined(this.options)) {
                        this.customizeHeaderStyle();
                        this.customizeRows();
                        this.setrowSelection();
                        //Be careful of the order of those methods
                        this.customizeForTreeView();
                        this.checkEditableRenderer();
                        //This customization should be applied a the as it will introduce a new column at beginning
                        //in order to handle the checkbox for selection!
                        this.checkCheckboxSelection();
                        this.addListeners();
                        this.initialized = true;
                    }
                    else {
                        this.loadingMessage = GridComponent.MESSAGES[1];
                        this.logger.error("Unable to load your grid, it seems the options has not been set");
                    }
                };
                GridComponent.prototype.addListeners = function () {
                    //Since API of ag-grid is not ready yet, I add listeneres into options.
                    this.options["on" + _.capitalize(ag.grid.Events.EVENT_COLUMN_EVERYTHING_CHANGED)] = this.checkCheckboxSelection.bind(this);
                };
                /**
                 *
                 * Customizes the header style. Currently the only header style customization is the height of the header.
                 *
                 *
                 *
                 */
                GridComponent.prototype.customizeHeaderStyle = function () {
                    //The default height of the title row is too small.
                    //Correcting it using 30px
                    if (!angular.isDefined(this.options.headerHeight)) {
                        this.options.headerHeight = 30;
                    }
                };
                /**
                 *
                 * Customizes the the row height option and sets it to 35px.
                 *
                 */
                GridComponent.prototype.customizeRows = function () {
                    if (!angular.isDefined(this.options.rowHeight)) {
                        this.options.rowHeight = 30; // Reduced rowHeight for MAUI theme.
                    }
                };
                /**
                 *
                 * Sets the default single row selection mode true by clicking on a cell.
                 *
                 */
                GridComponent.prototype.setrowSelection = function () {
                    if (!angular.isDefined(this.options.rowSelection)) {
                        this.options.rowSelection = grid.RowSelectionMode.SINGLE;
                    }
                };
                /**
                 *
                 * Sets the default icons for the treeview if the user has not set unique icons.
                 *
                 *
                 *
                 */
                GridComponent.prototype.customizeForTreeView = function () {
                    if (angular.isDefined(this.options.rowsAlreadyGrouped)
                        && this.options.rowsAlreadyGrouped) {
                        if (angular.isDefined(this.options.columnDefs)
                            && this.options.columnDefs.length > 0) {
                            if (!angular.isDefined(this.options.columnDefs[0].cellRenderer)) {
                                //We do not have any cell renderer configured. Let's help the dev and put the default one :
                                this.options.columnDefs[0].cellRenderer = {
                                    "renderer": "group",
                                    "innerRenderer": (new grid.renderer.TreeviewCellRender()).renderer
                                };
                            }
                            else {
                                //There is already a renderer. Probably due to the checkbox selection
                                this.options.columnDefs[0].cellRenderer["renderer"] = "groupe";
                            }
                        }
                        if (!angular.isDefined(this.options.icons)) {
                            this.options.icons = {
                                groupExpanded: GridComponent.GROUP_EXPANDED_ICON,
                                groupContracted: GridComponent.GROUP_CONTRACTED_ICON
                            };
                        }
                    }
                };
                /**
                 *
                 * Checks to see if the checkbox option is selected. When the checkbox option for a row is selected,
                 * a column for the checkbox component is added.
                 *
                 *
                 *
                 */
                GridComponent.prototype.checkCheckboxSelection = function () {
                    if (angular.isDefined(this.options.checkboxSelection)
                        && (this.options.checkboxSelection)) {
                        if (!angular.isDefined(this.options.rowSelection)) {
                            this.options.rowSelection = grid.RowSelectionMode.SINGLE;
                        }
                        //First, checking if we already added a pinned column to our checkbox
                        if (!angular.isDefined(this.options["checkboxSelectionPinned"])) {
                            if (!angular.isDefined(this.options["pinnedColumnCount"])) {
                                this.options["pinnedColumnCount"] = 0;
                            }
                            this.options["pinnedColumnCount"] = this.options["pinnedColumnCount"] + 1;
                            //If columns are reloaded, we do not a new pinned column
                            this.options["checkboxSelectionPinned"] = true;
                        }
                        void 0;
                        if (!angular.isArray(this.options.columnDefs)) {
                            this.options.columnDefs = [];
                        }
                        if (this.options.columnDefs.length > 0 && (angular.isUndefined(this.options.columnDefs[0]["name"])
                            || (angular.isDefined(this.options.columnDefs[0]["name"])
                                && this.options.columnDefs[0]["name"] !== "ers-checkbox-selection"))) {
                            var columnDefsWithCheckbox = this.options.columnDefs.slice();
                            columnDefsWithCheckbox.unshift({
                                name: "ers-checkbox-selection",
                                headerName: "",
                                headerClass: "ers-checkbox-column",
                                width: 30,
                                editable: false,
                                field: "",
                                enableColResize: false,
                                suppressSorting: true,
                                suppressMenu: true,
                                cellClass: "ag-custom-checkbox",
                                cellRenderer: (new CheckboxSelectionRenderer()).renderer
                            });
                            if (angular.isDefined(this.options.api)) {
                                //API is defined meaning grid is already loaded. Let use the API to set new column definition
                                this.options.api.setColumnDefs(columnDefsWithCheckbox);
                            }
                            else {
                                //Grid not init yet. Using options instead
                                this.options.columnDefs = columnDefsWithCheckbox;
                            }
                        }
                    }
                };
                /**
                 *
                 * Checks each column and sets the appropriate renderer when no renderer is detected.
                 *
                 */
                GridComponent.prototype.checkEditableRenderer = function () {
                    for (var index = 0; index < this.options.columnDefs.length; index++) {
                        if (angular.equals(this.options.columnDefs[index].editable, true)) {
                            //Removing editable param from the columnDefs otherwise angular grid will add his
                            //edition feature. I replace it with a ersEditable variable
                            this.options.columnDefs[index]["ersEditable"] = true;
                            delete this.options.columnDefs[index].editable;
                        }
                        this.resolveCellRenderer(this.options.columnDefs[index]);
                        this.patchDoubleClick(this.options.columnDefs[index]);
                        this.checkCssStyleForColumn(this.options.columnDefs[index]);
                    }
                };
                /**
                 *
                 * Based on the column definition, determines if a cell renderer is needed, and if needed, sets it.
                 *
                 * @param columnDef
                 *
                 */
                GridComponent.prototype.resolveCellRenderer = function (columnDef) {
                    if (angular.isDefined(columnDef.cellRenderer) && angular.isDefined(columnDef.cellRenderer["innerRenderer"])) {
                        //TODO : don't know how to handle this point yet
                        this.logger.warn("ers-grid: The cell renderer is not yet supported.");
                        return;
                    }
                    var selectedRenderer;
                    if (angular.isDefined(columnDef.dataType)) {
                        if (columnDef.dataType === grid.DataType.NUMBER) {
                            selectedRenderer = grid.renderer.ErsNumberRenderer.getInstance(this.$scope, this.$compile, this.$filterService);
                        }
                        else if (columnDef.dataType === grid.DataType.CHECKBOX) {
                            selectedRenderer = grid.renderer.ErsCheckboxRenderer.getInstance(this.$scope, this.$compile);
                        }
                        else if (columnDef.dataType === grid.DataType.COMBOBOX) {
                            selectedRenderer = grid.renderer.ErsComboboxRenderer.getInstance(this.$scope, this.$compile, this.$filterService);
                        }
                        else if (columnDef.dataType === grid.DataType.DATE) {
                            selectedRenderer = grid.renderer.ErsCalendarRenderer.getInstance(this.$scope, this.$compile, this.$filterService);
                        }
                        else {
                            //In all other case, we use the textbox by default for now
                            selectedRenderer = grid.renderer.ErsTextboxRenderer.getInstance(this.$scope, this.$compile, this.$filterService);
                        }
                    }
                    else {
                        //Editable but no datatype, with set the default cellrenderer
                        selectedRenderer = grid.renderer.ErsTextboxRenderer.getInstance(this.$scope, this.$compile, this.$filterService);
                    }
                    //We need to save the cell render if the user already set one
                    if (angular.isDefined(columnDef.cellRenderer)
                        && angular.isUndefined(columnDef["userCellRenderer"])
                        && !angular.equals(columnDef["cellRendererType"], "ErsRenderer")) {
                        //Saving the user's cell renderer elsewhere since we need this field
                        columnDef["userCellRenderer"] = columnDef.cellRenderer;
                    }
                    columnDef.cellRenderer = selectedRenderer.renderer.bind(selectedRenderer);
                    columnDef["cellRendererType"] = "ErsRenderer";
                };
                /**
                 *
                 * Catches the user event (clicking between the component and the grid) and passes it to the underlying
                 * ers component to set the edit mode.
                 *
                 * @param columnDef
                 */
                //Symptom: When the user double click somewhere else than the component container
                //(between the component and the grid's cell edge), the component is not setted to
                //edition mode. So, we catch the event and give it to the underlying ers component
                GridComponent.prototype.patchDoubleClick = function (columnDef) {
                    //If the user already defined a double click behavior,
                    if (angular.isDefined(columnDef.onCellDoubleClicked)) {
                        columnDef["userOnCellDoubleClicked"] = columnDef.onCellDoubleClicked;
                    }
                    columnDef.onCellDoubleClicked = function (params) {
                        void 0;
                        if (!angular.equals(params.colDef["editing"], true)) {
                            //TODO Use params.refreshCell() when it will be available
                            void 0;
                            $(params["eventSource"].firstChild.firstChild.firstChild).dblclick();
                        }
                        //Checking if we have a user defined double click behavior and call it if needed
                        if (angular.isDefined(params.colDef["userOnCellDoubleClicked"])) {
                            params.colDef["userOnCellDoubleClicked"](params);
                        }
                    };
                };
                /**
                 * Checks to see if column rendering requires a custom CSS.
                 *
                 * @param columnDef
                 * @param params
                 *
                 */
                GridComponent.prototype.checkCssStyleForColumn = function (columnDef) {
                    if (angular.isDefined(columnDef.cellStyle)) {
                        //If the user already defined style, we bypass, no need to customize CSS
                        return;
                    }
                    else {
                        columnDef.cellStyle = function (params) {
                            var cssStyle = {
                                "top": "0px",
                                "left": "0px",
                                "right": "0px",
                                "bottom": "0px"
                            };
                            if (angular.isDefined(params.colDef.ersCellRendererOptions)) {
                                if (angular.isDefined(params.colDef.ersCellRendererOptions["textAlign"])) {
                                    cssStyle["text-align"] = params.colDef.ersCellRendererOptions["textAlign"];
                                }
                                else if (angular.equals(params.colDef.dataType, grid.DataType.NUMBER)) {
                                    cssStyle["text-align"] = "right";
                                }
                                else if (angular.equals(params.colDef.dataType, grid.DataType.CHECKBOX)) {
                                    cssStyle["text-align"] = "center";
                                }
                                else {
                                    cssStyle["text-align"] = "left";
                                }
                                return cssStyle;
                            }
                            else if (angular.equals(params.colDef.dataType, grid.DataType.NUMBER)) {
                                //The default behavior of the numberbox is to have text right aligned, in the case that
                                // the user provides none.
                                cssStyle["text-align"] = "right";
                            }
                            else if (angular.equals(params.colDef.dataType, grid.DataType.CHECKBOX)) {
                                cssStyle["text-align"] = "center";
                            }
                            return cssStyle;
                        };
                    }
                };
                /**
                 *
                 * Resources for the Angular component.
                 *
                 * @type {string[]}
                 */
                GridComponent.$inject = ["$log", "$element", "$attrs", "$scope", "$compile", "$filter"];
                /**
                 *
                 * @type {string[]}
                 *
                 */
                GridComponent.MESSAGES = [
                    "Loading...",
                    "Unable to load the grid without grid options. Please add grid options and try again."
                ];
                /**
                 *
                 * Icon definition for the tree view mode when a leaf is opened.
                 *
                 * @type {string}
                 *
                 */
                GridComponent.GROUP_EXPANDED_ICON = "<i class='fa fa-minus-square fa-fw'/>";
                /**
                 * Icon definition for the tree view mode when a leaf is closed.
                 * @type {string}
                 */
                GridComponent.GROUP_CONTRACTED_ICON = "<i class='fa fa-plus-square-o fa-fw'/>";
                return GridComponent;
            })(BaseComponent);
            grid.GridComponent = GridComponent;
        })(grid = components.grid || (components.grid = {}));
    })(components = ers.components || (ers.components = {}));
})(ers || (ers = {}));

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};

// creator kinmaj
/*
 *
 *
 * @description ERS icon Directive: ers-icon.
 * Icon component. This is a standardised set of icons used across the ERS product suite.
 *
 */
var ers;
(function (ers) {
    var components;
    (function (components) {
        var icon;
        (function (icon) {
                        var BaseComponent = ers.components.core.BaseComponent;
            angular.module("ers.components.icon", ["ers.components.core"]).directive("ersIcon", function () {
                return {
                    restrict: "E",
                    controller: IconComponent,
                    controllerAs: "c",
                    bindToController: true,
                    scope: {
                        name: "@", ngDisabled: "=", size: "@"
                    }
                };
            });
            /**
             * @ngdoc directive
             * @name ersIcon
             * @restrict E
             * @module ers.components.icon
             * @scope
             *
             *
             * @description
             *
             * Use the `ers-icon` component to display a variety of Galileo icons.
             *
             * ### Examples
             *
             * A basic set of icons. You can also apply the disabled state.
             *
             * <code-editor identifier="example1" data-title="Basic Icons" html-content-url="demos/ersIcon/basicUsage/index.html"
             * js-content-url="demos/ersIcon/basicUsage/script.js" css-content-url="demos/ersIcon/basicUsage/styles.css"
             * content-mode="html"></code-editor>
             *
             * ### Design Guidelines
             * - Use icons anywhere a user can take an action, or to make specific data or information stand out
             * from the surrounding data.
             * - To make a clickable icon and to activate the specific CSS on a mouse-over, you must set the 'ng-click' attribute.
             *
             * ### Accessibility Guidelines
             *
             * No accessibility guidelines
             *
             * @param {string} [name] {@} Defines the name of icon being displayed.
             *
             * @param {boolean} [ng-disabled=false] {=} Sets the current icon to disabled or not.
             *
             *
             * @param {string} [size] {@} Use this attribute to change the font size of the current icon.
             *   The size is set in pixels, *for example*, size="17px".
             *
             *
             */
            var IconComponent = (function (_super) {
                __extends(IconComponent, _super);
                /**
                 * Constructor.
                 *
                 * @param $element The component element.
                 * @param $attrs The attributes specified in the directive.
                 */
                function IconComponent($scope, $element, $attrs) {
                    _super.call(this, $scope, $element);
                    /** Font size in px for the icon. */
                    this._size = -1;
                    // Set the icon CSS class.
                    $element.addClass("ers-icon");
                    this.$element.append("<span></span>");
                    this.spanHook = this.$element.find("span");
                    if (angular.isDefined($attrs["ngClick"])) {
                        this.isClickable = true;
                        this.$element.addClass("clickable");
                        this.spanHook.find("span").addClass("clickable");
                        if (this.size >= 0) {
                            this.spanHook.find("i").css("font-size", this.size + "px");
                        }
                    }
                    this.configureClickListener();
                }
                /**
                 * Configure the click listener on the current icon. When the icon is disabled, the click event is stopped.
                 */
                IconComponent.prototype.configureClickListener = function () {
                    var _this = this;
                    this.spanHook.on("click", function (event) {
                        if (_this.ngDisabled) {
                            event.preventDefault();
                            event.stopPropagation();
                        }
                    });
                };
                Object.defineProperty(IconComponent.prototype, "name", {
                    /**
                     * Get the current icon name.
                     * @returns {string} Returns the current icon name if it is among the available icons, undefined otherwise.
                     * */
                    get: function () {
                        return this._name;
                    },
                    /**
                     * Set the current icon name.
                     * @param value {string} The name of the current icon among the available icons.
                     */
                    set: function (value) {
                        var html = IconComponent.ICONS[value];
                        if (angular.isDefined(html)) {
                            this._name = value;
                            if (angular.isDefined(this.spanHook)) {
                                this.spanHook.empty();
                                this.spanHook.append(html);
                                if (this.isClickable) {
                                    this.spanHook.find("span").addClass("clickable");
                                }
                            }
                        }
                        else {
                            this._name = undefined;
                        }
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(IconComponent.prototype, "size", {
                    /**
                     * Get the current icon name.
                     * @returns {string} Returns the current icon name if it is among the available icons, undefined otherwise.
                     */
                    get: function () {
                        return this._size;
                    },
                    /**
                     * Set the current icon name.
                     * @param value {string} The name of the current icon among the available icons.
                     */
                    set: function (value) {
                        if (angular.isDefined(value) && this.spanHook) {
                            this.spanHook.find("i").css("font-size", value + "px");
                        }
                    },
                    enumerable: true,
                    configurable: true
                });
                IconComponent.ICONS = {
                    "processing-errors": "<span class=\"fa-danger-action\"><i class=\"fa fa-spinner fa-spin\"></i></span>",
                    "expand": "<span class=\"fa-information-action\"><i class=\"fa fa-expand\"></i></span>",
                    "collapse": "<span class=\"fa-information-action\"><i class=\"fa fa-compress\"></i></span>",
                    "pie-chart": "<span class=\"fa-information-action\"><i class=\"fa fa-pie-chart\"></i></span>",
                    "move": "<span class=\"fa-information-action\"><i class=\"fa fa-arrows\"></i></span>",
                    "data-grid": "<span class=\"fa-information-action\"><i class=\"fa fa-th\"></i></span>",
                    "notification": "<span class=\"fa-information-action\"><i class=\"fa fa-bell\"></i></span>",
                    "move-up": "<span class=\"fa-information-action\" ><i class=\"fa fa-arrow-up\"></i></span>",
                    "history": "<span class=\"fa-information-action\"><i class=\"fa fa-history\"></i></span>",
                    "redo": "<span class=\"fa-information-action\"><i class=\"fa fa-share-square\"></i></span>",
                    "undo": "<span class=\"fa-information-action\"><i class=\"fa fa-share-square fa-flip-horizontal\">" +
                        "</i></span>",
                    "move-down": "<span class=\"fa-information-action\" ><i class=\"fa fa-arrow-down\"></i></span>",
                    "preview": "<span class=\"fa-information-action\"><i class=\"fa fa-eye\"></i></span>",
                    "refresh": "<span class=\"fa-information-action\"><i class=\"fa fa-refresh\"></i></span>",
                    "add": "<span class=\"fa-success-action\"><i class=\"fa fa-plus\"></i></span>",
                    "delete": "<span class=\"fa-danger-action\"><i class=\"fa fa-times\"></i></span>",
                    "edit": "<span class=\"fa-information-action\"><i class=\"fa fa-pencil\"></i></span>",
                    "filter": "<span class=\"fa-information-action\"><i class=\"fa fa-filter\"></i></span>",
                    "display": "<span class=\"fa-information-action\"><i class=\"fa fa-desktop\"></i></span>",
                    "calculator": "<span class=\"fa-information-action\"><i class=\"fa fa-calculator\"></i></span>",
                    "hierarchy": "<span class=\"fa-information-action\"><i class=\"fa fa-sitemap\"></i></span>",
                    "stop": "<span class=\"fa-danger-action fa-stack fa-lg\"><i class=\"fa fa-circle fa-stack-2x\"></i>" +
                        "<i class=\"fa fa-square fa-stack-1x fa-inverse\"></i></span>",
                    "pause": "<span class=\"fa-information-action fa-stack fa-lg\"><i class=\"fa fa-circle fa-stack-2x\">" +
                        "</i><i class=\"fa fa-pause fa-stack-1x fa-inverse\"></i></span>",
                    "start": "<span class=\"fa-success-action\"><i class=\"fa fa-play-circle\"></i></span>",
                    "verified": "<span class=\"fa-success-action\"><i class=\"fa fa-check-square-o\"></i></span>",
                    "calendar": "<span class=\"fa-information\"><i class=\"fa fa-calendar\"></i></span>",
                    "past-duedate": "<span class=\"fa-danger-action\"><i class=\"fa fa-calendar\"></i></span>",
                    "near-duedate": "<span class=\"fa-warning-action\"><i class=\"fa fa-calendar\"></i></span>",
                    "csv-doc": "<span class=\"fa-information-action\"><i class=\"fa fa-file-excel-o\"></i></span>",
                    "file": "<span class=\"fa-information-action\"><i class=\"fa fa-file-o\"></i></span>",
                    "word-doc": "<span class=\"fa-information-action\"><i class=\"fa fa-file-word-o\"></i></span>",
                    "pdf": "<span class=\"fa-information-action\"><i class=\"fa fa-file-pdf-o\"></i></span>",
                    "trash": "<span class=\"fa-information-action\"><i class=\"fa fa-trash\"></i></span>",
                    "edit-log": "<span class=\"fa-information-action\"><i class=\"fa fa-pencil-square-o\"></i></span>",
                    "comment": "<span class=\"fa-information-action\"><i class=\"fa fa-comment-o\"></i></span>",
                    "jump-to": "<span class=\"fa-information-action\"><i class=\"fa fa-share-square-o\"></i></span>",
                    "save": "<span class=\"fa-information-action\"><i class=\"fa fa-save\"></i></span>",
                    "attachment": "<span class=\"fa-information-action\"><i class=\"fa fa-paperclip\"></i></span>",
                    "unlocked": "<span class=\"fa-information-action\"><i class=\"fa fa-unlock-alt\"></i></span>",
                    "locked": "<span class=\"fa-information-action\"><i class=\"fa fa-lock\"></i></span>",
                    "print": "<span class=\"fa-information-action\"><i class=\"fa fa-print\"></i></span>",
                    "statement": "<span class=\"fa-warning-action\"><i class=\"fa fa-file-text-o\"></i></span>",
                    "cancel-action": "<span class=\"fa-information-action\"><i class=\"fa fa-times-circle\"></i></span>",
                    "folder": "<span class=\"fa-information-action\"><i class=\"fa fa-folder-o\"></i></span>",
                    "add-folder": "<span class=\"fa-stack fa-lg stacked-icons fa-success-action\"> " +
                        "<i class=\"fa fa-folder-o fa-stack-2x\"></i> <span class=\"fa-stack stack-bg\"> " +
                        "<i class=\"fa fa-plus fa-small fa-stack-1x\"></i> </span></span>",
                    "delete-folder": "<span class=\"fa-stack fa-lg stacked-icons fa-danger-action\"> " +
                        "<i class=\"fa fa-folder-o fa-stack-2x\"></i> <span class=\"fa-stack stack-bg\"> " +
                        "<i class=\"fa fa-plus fa-small fa-stack-1x fa-rotate-45\"></i> </span></span>",
                    "minus": "<span class=\"fa-information-action\"><i class=\"fa fa-minus-square-o\"></i></span>",
                    "favorite": "<span class=\"fa-warning fa-stack fa-lg\"><i class=\"fa fa-circle fa-stack-2x\">" +
                        "</i><i class=\"fa fa-star fa-stack-1x fa-inverse\"></i></span>",
                    "delete-file": "<span class=\"fa-stack fa-lg stacked-icons fa-danger-action\">" +
                        "<i class=\"fa fa-file-o fa-stack-2x\"></i>   <span class=\"fa-stack stack-bg\">" +
                        "<i class=\"fa fa-plus fa-stack-1x fa-small fa-rotate-45\"></i></span></span>",
                    "import-file": "<span class=\"fa-stack fa-lg stacked-icons fa-information-action\"> " +
                        "<i class=\"fa fa-file-o fa-stack-2x\"></i> <span class=\"fa-stack stack-bg\"> " +
                        "<i class=\"fa fa-arrow-left fa-small fa-stack-1x\"></i> </span></span>",
                    "add-file": "<span class=\"fa-stack fa-lg stacked-icons fa-success-action\">" +
                        "<i class=\"fa fa-file-o fa-stack-2x\"></i><span class=\"fa-stack stack-bg\">" +
                        "<i class=\"fa fa-plus fa-small fa-stack-1x\"></i></span></span>",
                    "export-file": "<span class=\"fa-stack fa-lg stacked-icons fa-information-action\"> " +
                        "<i class=\"fa fa-file-o fa-stack-2x\"></i> <span class=\"fa-stack stack-bg\"> " +
                        "<i class=\"fa fa-arrow-right fa-small fa-stack-1x\"></i> </span></span>",
                    "date-selector": "<span class=\"fa-information-action\"><i class=\"fa fa-calendar-o\">" + "</i></span>",
                    "duplicate-file": "<span class=\"fa-stack stacked-icons fa-information-action\"> " +
                        "<i class=\"fa fa-file-o fa-stack-2x\"></i> <span class=\"fa-stack file-stack-bg\"> " +
                        "<i class=\"fa fa-file-o fa-stack-1x\"></i> </span></span>",
                    "diagram": "<span class=\"fa-information-action\"><i class=\"fa fa-file-photo-o\"></i></span>",
                    "header-down-arrow": "<span class=\"fa-information-action\"><i class=\"fa fa-angle-down\"></i></span>",
                    "information": "<span class=\"fa-information-action\"><i class=\"fa fa-info-circle\"></i></span>",
                    "help": "<span class=\"fa-information-action\"><i class=\"fa fa-question-circle\"></i></span>",
                    "settings": "<span class=\"fa-information-action\"><i class=\"fa fa-gear\"></i></span>",
                    "zoom-out": "<span class=\"fa-information-action\"><i class=\"fa fa-search-minus\"></i></span>",
                    "zoom-in": "<span class=\"fa-information-action\"><i class=\"fa fa-search-plus\"></i></span>",
                    "search": "<span class=\"fa-information-action\"><i class=\"fa fa-search\"></i></span>",
                    "duplicate-folder": "<span class=\"fa-stack stacked-icons fa-information-action\"> " +
                        "<i class=\"fa fa-folder-o fa-stack-2x\"></i> <span class=\"fa-stack file-stack-bg\"> " +
                        "<i class=\"fa fa-folder-o fa-stack-1x\"></i> </span></span>",
                    "take-task": "<span class=\"fa-success-action\"><i class=\"fa fa-external-link\"></i>" + "</span>",
                    "export-folder": "<span class=\"fa-stack fa-lg stacked-icons fa-information-action\"> " +
                        "<i class=\"fa fa-folder-o fa-stack-2x\"></i> <span class=\"fa-stack stack-bg\"> " +
                        "<i class=\"fa fa-arrow-right fa-small fa-stack-1x\"></i> </span> </span>",
                    "open-folder": "<span class=\"fa-information-action\"><i class=\"fa fa-folder-open-o\"></i></span>",
                    "green-complete": "<span class=\"fa-success-action\"><i class=\"fa fa-circle\"></i></span>",
                    "red-complete": "<span class=\"fa-danger-action\"><i class=\"fa fa-circle-o\"></i></span>",
                    "error": "<span class=\"fa-danger-action\"><i class=\"fa fa-exclamation-triangle\"></i></span>",
                    "cancel": "<span class=\"fa-danger-action\"><i class=\"fa fa-ban\"></i></span>",
                    "alerts": "<span class=\"fa-warning-action\"><i class=\"fa fa-exclamation-circle\"></i></span>",
                    "processing": "<span class=\"fa-information-action\"><i class=\"fa fa-spinner fa-spin\"></i></span>",
                    "plus": "<span class=\"fa-information-action\"><i class=\"fa fa-plus-square-o\"></i></span>",
                    "pin": "<span class=\"fa-information-action\"><i class=\"fa fa-thumb-tack\"></i></span>",
                    "unpin": "<span class=\"fa-information-action fa-stack\">" +
                        "<i class=\"fa fa-circle-thin fa-stack-2x fa-unpin-circle\"></i>" +
                        "<i class=\"fa  fa-thumb-tack fa-rotate-45 fa-stack-1x fa-unpin\"></i>" +
                        "<i class=\"fa fa-folder-o fa-stack-1x fa-unpin-cross\"></i></span>",
                    "workflow": "<span class=\"fa-information-action\"><i class=\"fa fa-code-fork fa-rotate-90\"></i>" +
                        "</span>",
                    "start-workflow": "<span class=\"fa-stack fa-lg stacked-fork fa-success-action\"> " +
                        "<i class=\"fa fa-code-fork fa-rotate-90 fa-stack-2x\"></i> <span class=\"fa-stack stack-bg\"> " +
                        "<i class=\"fa fa-plus fa-small fa-stack-1x\"></i> </span></span>",
                    "delete-workflow": "<span class=\"fa-stack fa-lg stacked-fork fa-danger-action\"> " +
                        "<i class=\"fa fa-code-fork fa-rotate-90 fa-stack-2x\"></i> <span class=\"fa-stack stack-bg\"> " +
                        "<i class=\"fa fa-plus fa-small fa-stack-1x fa-rotate-45\"></i> </span></span>",
                    "pause-workflow": "<span class=\"fa-stack fa-lg stacked-fork fa-warning-action\"> " +
                        "<i class=\"fa fa-code-fork fa-rotate-90 fa-stack-2x\"></i> <span class=\"fa-stack stack-bg\"> " +
                        "<i class=\"fa fa-pause fa-small fa-stack-1x\"></i> </span></span>",
                    "confirmed": "<span class=\"fa-success-action\"><i class=\"fa fa-check\"></i></span>",
                    "dropdown-arrow": "<span class=\"fa-information\"><span class=\"fa-stack fa-lg\">" +
                        "<i class=\"fa fa-angle-down fa-stack-1x\"></i></span></span>",
                    "undo-action": "<span class=\"fa-information-action\"><i class=\"fa fa-undo\"></i></span>",
                    "redo-action": "<span class=\"fa-information-action\"><i class=\"fa fa-repeat\"></i></span>",
                    "re-order": "<span class=\"fa-information-action\"><span class=\"fa-stack fa-lg\">" +
                        "<i class=\"fa fa-random fa-stack-1x\"></i></span></span>",
                    "list": "<span class=\"fa-information-action\"><i class=\"fa fa-list\"></i></span>",
                    "rolling-stmt": "<span class=\"fa-stack fa-lg stacked-icons fa-information-action\">" +
                        "<i class=\"fa fa-file-o fa-stack-2x\"></i><span class=\"fa-stack stack-bg\">" +
                        "<i class=\"fa fa-list fa-stack-1x fa-small\"></i></span></span>",
                    "show-stmt": "<span class=\"fa-stack fa-lg stacked-icons fa-information-action\">" +
                        "<i class=\"fa fa-file-o fa-stack-2x\"></i><span class=\"fa-stack stack-bg\">" +
                        "<i class=\"fa fa-eye fa-stack-1x fa-small-stmt\"></i></span></span>",
                    "combined-stmt": "<span class=\"fa-stack fa-lg stacked-icons fa-information-action\">" +
                        "<i class=\"fa fa-file-o fa-stack-2x\"></i><span class=\"fa-stack stack-bg\">" +
                        "<i class=\"fa fa-sitemap fa-stack-1x fa-small-stmt\"></i></span></span>"
                };
                IconComponent.$inject = ["$scope", "$element", "$attrs"];
                return IconComponent;
            })(BaseComponent);
            icon.IconComponent = IconComponent;
        })(icon = components.icon || (components.icon = {}));
    })(components = ers.components || (ers.components = {}));
})(ers || (ers = {}));
///

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
/**
 * @ngdoc directive
 * @name ersLabel
 * @restrict E
 * @module ers.components.label
 * @scope
 *
 * @description
 * Use the `ers-label` component to create custom text labels for use inside of forms.
 *
 * - In areas where long text should be hidden instead of wrapping.
 * - To denote something that is required.
 * - Hovering over the ellipses displays a browser tooltip containing the missing text.
 *
 * ### Usage
 * The label component provides the following options:
 *
 * - Ellipses to indicate a hidden text string.
 * - Browser tool tips that activate on mouse over to display the entire label text.
 * - A red asterisk to indicate required fields.
 *
 * ### Examples
 *
 * <code-editor identifier="example1" data-title="Labels" html-content-url="demos/ersLabel/basicUsage/index.html"
 * js-content-url="demos/ersLabel/basicUsage/script.js" css-content-url="demos/ersLabel/basicUsage/styles.css"
 * content-mode="html"></code-editor>
 *
 * ### Design Guidelines
 *
 * - Use labels form elements to explain to the user what values are expected when filling out a form.
 * - Make the explanations short (1-3 word) descriptions of the input.
 * - You can apply standard HTML and CSS formatting and styles to the label.
 *
 * ### Accessibility Guidelines
 *
 * No accessibility guidelines.
 *
 * @param {string} [value] {@}
 *
 * Defines the label text.
 *
 * ```xml
 *
 * <ers-label value="Hello World!"></ers-label>
 *
 * ```
 *
 * @param {boolean} [ng-required=false] {=}
 *
 * Marks the input as required. This adds the red asterisk(*) to the combo box list item.
 *
 * ```xml
 *
 * <ers-label ng-required="true" value="Birth Date:"></ers-label>
 *
 * ```
 *
 * @param {expression} [ng-change="expression"] {=?}
 *
 * Evaluates the label for user input changes and notifies scope immediately upon change, unlike the JavaScript
 * onChange event, which only notifies at the completion of a change.
 *
 *
 *
 *
 *
 */
var ers;
(function (ers) {
    var components;
    (function (components) {
        var label;
        (function (label) {
                        var BaseComponent = ers.components.core.BaseComponent;
            angular.module("ers.components.label", ["ers.components.core"]).directive("ersLabel", function () {
                return {
                    restrict: "E",
                    templateUrl: "label/template/label-template.html",
                    controller: LabelComponent,
                    controllerAs: "c",
                    bindToController: true,
                    scope: {
                        "value": "@",
                        "required": "=ngRequired"
                    }
                };
            });
            /**
             * The label controller.
             */
            var LabelComponent = (function (_super) {
                __extends(LabelComponent, _super);
                /**
                 * Constructor.
                 *
                 * @param $element The component element.
                 */
                function LabelComponent($scope, $element) {
                    _super.call(this, $scope, $element);
                }
                Object.defineProperty(LabelComponent.prototype, "contentStyle", {
                    get: function () {
                        var style = {};
                        if (this.$element.css("text-align") === "right") {
                            style["width"] = "100%";
                        }
                        else {
                            style["width"] = "auto";
                        }
                        if (this.$element.css("text-decoration") !== null) {
                            style["text-decoration"] = this.$element.css("text-decoration");
                        }
                        else {
                            style["ext-decoration"] = "none";
                        }
                        return style;
                    },
                    enumerable: true,
                    configurable: true
                });
                LabelComponent.$inject = ["$scope", "$element"];
                return LabelComponent;
            })(BaseComponent);
            label.LabelComponent = LabelComponent;
        })(label = components.label || (components.label = {}));
    })(components = ers.components || (ers.components = {}));
})(ers || (ers = {}));

/*
 * Created by germonneauf on 10/04/2015.
 */
// only declare angular module
angular.module("ers.components.layout", ["ers.components.core"]);var ers;
(function (ers) {
    var components;
    (function (components) {
        var layout;
        (function (layout) {
                    })(layout = components.layout || (components.layout = {}));
    })(components = ers.components || (ers.components = {}));
})(ers || (ers = {}));

var ers;
(function (ers) {
    var components;
    (function (components) {
        var layout;
        (function (layout) {
                    })(layout = components.layout || (components.layout = {}));
    })(components = ers.components || (ers.components = {}));
})(ers || (ers = {}));
var ers;
(function (ers) {
    var components;
    (function (components) {
        var layout;
        (function (layout) {
                    })(layout = components.layout || (components.layout = {}));
    })(components = ers.components || (ers.components = {}));
})(ers || (ers = {}));
var ers;
(function (ers) {
    var components;
    (function (components) {
        var layout;
        (function (layout) {
                    })(layout = components.layout || (components.layout = {}));
    })(components = ers.components || (ers.components = {}));
})(ers || (ers = {}));

var ers;
(function (ers) {
    var components;
    (function (components) {
        var layout;
        (function (layout) {
                    })(layout = components.layout || (components.layout = {}));
    })(components = ers.components || (ers.components = {}));
})(ers || (ers = {}));
var ers;
(function (ers) {
    var components;
    (function (components) {
        var layout;
        (function (layout) {
                    })(layout = components.layout || (components.layout = {}));
    })(components = ers.components || (ers.components = {}));
})(ers || (ers = {}));

var ers;
(function (ers) {
    var components;
    (function (components) {
        var layout;
        (function (layout) {
                    })(layout = components.layout || (components.layout = {}));
    })(components = ers.components || (ers.components = {}));
})(ers || (ers = {}));




var ers;
(function (ers) {
    var components;
    (function (components) {
        var layout;
        (function (layout) {
                    })(layout = components.layout || (components.layout = {}));
    })(components = ers.components || (ers.components = {}));
})(ers || (ers = {}));

var ers;
(function (ers) {
    var components;
    (function (components) {
        var layout;
        (function (layout) {
                    })(layout = components.layout || (components.layout = {}));
    })(components = ers.components || (ers.components = {}));
})(ers || (ers = {}));



var ers;
(function (ers) {
    var components;
    (function (components) {
        var layout;
        (function (layout) {
                        /**
             * @-ngdoc directive
             *
             * @name ersCollapse
             *
             * @restrict A
             * @module ers.components.layout
             *
             * @description
             *
             * `ers-collapse` is not a standalone component. It is used with `ers-layout` and `ers-splitter` allowing you to
             * expand or collapse HTML containers.
             *
             *
             * For more
             * information and examples of using ers-collapse, see [ers-layout](#components/ersLayout/documentation).
             *
             *
             *
             * @param {string} [ers-collapse] Sets the direction in which the HTML container collapses.
             * content.
             *
             * - onBothSide&#151;Ability to collapse or expand a portion of an HTML container. The default setting.
             *
             * - onTop&#151;Collapse or expand an HTML container to or from the Top.
             *
             * - onBottom&#151;Collapse or expand an HTML container to or from the Bottom.
             *
             * - onLeft&#151;Collapse or expand an HTML container to or from the left.
             *
             * - onRight&#151;Collapse or expand an HTML container to or from the right.
             *
             *
             *
             */
            var ersCollapseDirective = function () {
                var allowedValues = /(none|onLeft|onRight|onTop|onBottom|onBothSide)/g;
                return {
                    restrict: "A",
                    require: ["?ersLayout", "?ersSplitter"],
                    priority: 10,
                    bindToController: true,
                    link: function ($scope, $element, $attributes, controllers) {
                        if (controllers != null && controllers.length > 1) {
                            var controller = controllers[0] ||
                                controllers[1];
                            if (controller && $attributes != null && $attributes.hasOwnProperty("ersCollapse")) {
                                controller.ersCollapse = "onBothSide";
                                var collapseOption = $attributes["ersCollapse"];
                                if (collapseOption.length > 0) {
                                    var values = collapseOption.match(allowedValues);
                                    if (values != null && values.length > 0) {
                                        controller.ersCollapse = values[0];
                                    }
                                }
                            }
                        }
                    }
                };
            };
            // Add directive to module
            angular.module("ers.components.layout").directive("ersCollapse", ersCollapseDirective);
        })(layout = components.layout || (components.layout = {}));
    })(components = ers.components || (ers.components = {}));
})(ers || (ers = {}));


var ers;
(function (ers) {
    var components;
    (function (components) {
        var layout;
        (function (layout) {
                        /** Private var */
            var digit = /(\d*\.?[\d]+)(?=px)/g;
            var percent = /(\d*\.?[\d]+)(?=%)/g;
            layout.layoutUtils = {
                /*
                 * @function Retrieve raw data from css for a given element.
                 * @param element the DOM element
                 * @param property the property to check
                 * @returns {string} the raw value from css
                 */
                getRawStyle: function (element, property) {
                    var display = window.getComputedStyle(element).getPropertyValue("display");
                    element.style.display = "none";
                    var value = window.getComputedStyle(element).getPropertyValue(property);
                    element.style.display = display;
                    return value;
                },
                /*
                 * @function Retrieve computed css property value and check if it's expressed in percent.
                 * @param element the DOM element to inspect (property)
                 * @param property the css property expressed in number (%, px, em, ...)
                 * @returns {boolean} true if value is expressed in percent else false
                 */
                isPercentBasis: function (element, property) {
                    try {
                        var value = this.getRawStyle(element, property);
                        return (value.indexOf("%") > 0);
                    }
                    catch (e) {
                        return false;
                    }
                },
                /*
                 * @function Retrieve the raw value associated to the given property
                 * @param element the DOM element to inspect (property)
                 * @param property the css property
                 * @returns {number} raw value
                 */
                rawStyle2Number: function (element, property) {
                    try {
                        var digit = /(\d*\.?[\d]+)(?=(px|%))/g;
                        var result = (this.getRawStyle(element, property).match(digit));
                        if (result != null && result.length > 0) {
                            return parseInt(result[0], 0);
                        }
                    }
                    catch (e) {
                        return 0;
                    }
                    return 0;
                },
                /*
                 * @function Convert string property value into number
                 * @param element the DOM element to inspect (property)
                 * @param property the css property
                 * @param exp the regular expression to retrieve
                 * @returns {number} the result of the conversion
                 */
                css2Number: function (element, property, exp) {
                    if (exp === void 0) { exp = null; }
                    try {
                        var result = (window.getComputedStyle(element)[property].match(exp));
                        if (result != null && result.length > 0) {
                            return parseInt(result[0], 0);
                        }
                    }
                    catch (e) {
                        return 0;
                    }
                    return 0;
                },
                /*
                 * @function Convert string property value expressed in px into number
                 * @param element the DOM element to inspect (property)
                 * @param property the css property
                 * @returns {number} the result of the conversion
                 */
                cssPixel2Number: function (element, property) {
                    return this.css2Number(element, property, digit);
                },
                /*
                 * @function Convert string property value expressed in percent into number
                 * @param element the DOM element to inspect (property)
                 * @param property the css property
                 * @returns {number} the result of the conversion
                 */
                cssPercent2Number: function (element, property) {
                    return this.css2Number(element, property, percent);
                },
                /*
                 * @function try to convert the attribute value into number.
                 * @param element DOM element
                 * @param attr attribute name
                 * @returns {number}
                 */
                attr2Number: function (element, attr) {
                    var value = element.attr(attr);
                    try {
                        if (angular.isDefined(value)) {
                            return parseFloat(value);
                        }
                    }
                    catch (e) {
                        return 0;
                    }
                    return 0;
                },
                /*
                 * Switch class to an element.
                 * @param element DOM element
                 * @param oldClass old class
                 * @param newClass new class
                 */
                switchClass: function (element, oldClass, newClass) {
                    if (element.hasClass(oldClass)) {
                        element.removeClass(oldClass);
                    }
                    if (!element.hasClass(newClass)) {
                        element.addClass(newClass);
                    }
                },
                /*
                 * Get the layout controller if exist from a given DOM element.
                 * @param element the DOM element from where start the search
                 * @returns {null}
                 */
                getLayoutController: function (element) {
                    if (element.length > 0) {
                        return element.controller("ersLayout");
                    }
                    else {
                        return null;
                    }
                },
                /*
                 * Check if element is a layout element.
                 * @param element DOM element
                 * @returns {boolean} true if the element is a layout
                 */
                isLayoutElement: function (element) {
                    return element.tagName.toLowerCase() === "ers-layout";
                }
            };
        })(layout = components.layout || (components.layout = {}));
    })(components = ers.components || (ers.components = {}));
})(ers || (ers = {}));
var ers;
(function (ers) {
    var components;
    (function (components) {
        var layout;
        (function (layout) {
                    })(layout = components.layout || (components.layout = {}));
    })(components = ers.components || (ers.components = {}));
})(ers || (ers = {}));
var ers;
(function (ers) {
    var components;
    (function (components) {
        var layout;
        (function (layout) {
                        /**
             * Constants static class. Store all shared constants for the module.
             * @class
             */
            var Constants = (function () {
                function Constants() {
                }
                Constants.DIRECTION_HORIZONTAL = "horizontal";
                Constants.DIRECTION_VERTICAL = "vertical";
                Constants.COLLAPSIBLE_DEFAULT_SIZE = 40;
                Constants.SPLITTER_DEFAULT_SIZE = 10;
                Constants.ON_COLLAPSE_LEFT = "onLeft";
                Constants.ON_COLLAPSE_RIGHT = "onRight";
                Constants.ON_COLLAPSE_TOP = "onTop";
                Constants.ON_COLLAPSE_BOTTOM = "onBottom";
                Constants.ON_COLLAPSE_BOTH = "onBothSide";
                Constants.ON_COLLAPSE_REACH_MIN = "onReachMin";
                Constants.DIRECT_SPLITTER = "direct";
                Constants.PROXY_SPLITTER = "proxy";
                Constants.NO_SPLITTER = "none";
                Constants.NONE = "none";
                return Constants;
            })();
            layout.Constants = Constants;
            /* Set of horizontal layout properties. */
            layout.wStyle = ({
                "property": "width",
                "maxProperty": "maxWidth",
                "minProperty": "minWidth",
                "offsetProperty": "offsetWidth",
                "maxAvailable": "wAvailable",
                "sticky": "w-sticky",
                "reachMin": "w-reach-min",
                "fixed": "w-fixed",
                "maxStore": "w-max-store"
            });
            /* Set of vertical layout properties. */
            layout.hStyle = ({
                "property": "height",
                "maxProperty": "maxHeight",
                "minProperty": "minHeight",
                "offsetProperty": "offsetHeight",
                "maxAvailable": "hAvailable",
                "sticky": "h-sticky",
                "reachMin": "h-reach-min",
                "fixed": "h-fixed",
                "maxStore": "h-max-store"
            });
        })(layout = components.layout || (components.layout = {}));
    })(components = ers.components || (ers.components = {}));
})(ers || (ers = {}));



var ers;
(function (ers) {
    var components;
    (function (components) {
        var layout;
        (function (layout) {
                        /*
             * SplitterProxy class.
             * @class
             */
            var SplitterProxy = (function () {
                /*
                 * @constructor
                 * @param splitter The splitter object
                 */
                function SplitterProxy(splitter) {
                    /* The cumulative quantity of move.*/
                    this.offsetQuantity = 0;
                    /* The DOM representation of the proxy. */
                    this.element = null;
                    /* Threshold for collapse. */
                    this.sensibility = layout.Constants.COLLAPSIBLE_DEFAULT_SIZE;
                    this.splitter = splitter;
                }
                /*
                 * Action on button mouse down
                 * @param event The event raised
                 */
                SplitterProxy.prototype.doMouseDown = function (event) {
                    this.element = angular.element("<div class=\"" + this.splitter.splitterStyle() + "\"></div>");
                    // Warning!!!: Avoid to display this new element depending on next action (move / or just click)
                    this.element.hide();
                    this.element.insertAfter(this.splitter.element);
                    // Initialize position (here it has to work whatever the splitter direction)
                    this.element.css("left", this.splitter.element[0].offsetLeft + "px");
                    this.element.css("top", this.splitter.element[0].offsetTop + "px");
                    this.splitter.refreshMousePos(event);
                };
                /*
                 * Action on button mouse released
                 * @param event The event raised
                 */
                SplitterProxy.prototype.doMouseUp = function (event) {
                    // Redraw elements
                    this.splitter.resize(event, this.offsetQuantity);
                    // Trigger listener: As layout's width and height are computed in percent, this listener should be called before
                    // the resize was done. This listener ask to parent container to resize its children with the appropriate %
                    // depending on children 's width and height.
                    this.splitter.controller.callTriggerResizeEvent();
                    // Reset proxy
                    this.reset();
                };
                /*
                 * Action on button mouse mouse
                 * @param event The raised event
                 */
                SplitterProxy.prototype.doMouseMove = function (event) {
                    // Show element (splitter) move.
                    this.element.show();
                    var quantity = this.splitter.quantity(event);
                    var offset = this.offsetQuantity + quantity;
                    if (this.splitter.checkMoveConstraints(event)) {
                        this.offsetQuantity = offset;
                        this.updateSplitterPosition(this.splitter.getSplitterPosition() + quantity);
                    }
                    this.splitter.refreshMousePos(event);
                };
                /*
                 * @function Delete proxy dom representation, reset quantity of move
                 */
                SplitterProxy.prototype.reset = function () {
                    if (this.element) {
                        this.element.remove();
                    }
                    this.element = null;
                    this.offsetQuantity = 0;
                };
                /*
                 * Update splitter position.
                 * @param value new position
                 */
                SplitterProxy.prototype.updateSplitterPosition = function (value) {
                    this.splitter.setSplitterPosition(value);
                };
                /*
                 * Name of draggable object
                 * @returns {string} name
                 */
                SplitterProxy.prototype.name = function () {
                    return layout.Constants.PROXY_SPLITTER;
                };
                return SplitterProxy;
            })();
            layout.SplitterProxy = SplitterProxy;
        })(layout = components.layout || (components.layout = {}));
    })(components = ers.components || (ers.components = {}));
})(ers || (ers = {}));



var ers;
(function (ers) {
    var components;
    (function (components) {
        var layout;
        (function (layout) {
                        /*
             * SplitterProxy class.
             * @class
             */
            var SplitterDirect = (function () {
                /*
                 * @constructor
                 * @param splitter The splitter object
                 */
                function SplitterDirect(splitter) {
                    /* Threshold for collapse. */
                    this.sensibility = layout.Constants.COLLAPSIBLE_DEFAULT_SIZE;
                    this.splitter = splitter;
                    this.element = this.splitter.element;
                }
                /*
                 * Action on button mouse down
                 * @param event The event raised
                 */
                SplitterDirect.prototype.doMouseDown = function (event) {
                    // Update mouse position
                    this.splitter.refreshMousePos(event);
                    // Trigger listener: As layout's width and height are computed in percent, this listener should be called before
                    // the resize was done. This listener ask to parent container to resize its children with the appropriate %
                    // depending on children 's width and height.
                    this.splitter.controller.callTriggerResizeEvent();
                };
                /*
                 * Action on button mouse released
                 * @param event The event raised
                 */
                SplitterDirect.prototype.doMouseUp = function (event, trigger) {
                    // Update mouse position
                    this.splitter.refreshMousePos(event);
                };
                /*
                 * Action on button mouse move
                 * @param event The raised event
                 */
                SplitterDirect.prototype.doMouseMove = function (event) {
                    var quantity = this.splitter.quantity(event);
                    if (this.splitter.checkMoveConstraints(event)) {
                        this.splitter.resize(event, quantity);
                        this.splitter.controller.callTriggerResizeEvent();
                    }
                    this.splitter.refreshMousePos(event);
                };
                /*
                 * Name of draggable object.
                 * @returns {string} name
                 */
                SplitterDirect.prototype.name = function () {
                    return layout.Constants.DIRECT_SPLITTER;
                };
                return SplitterDirect;
            })();
            layout.SplitterDirect = SplitterDirect;
        })(layout = components.layout || (components.layout = {}));
    })(components = ers.components || (ers.components = {}));
})(ers || (ers = {}));





var ers;
(function (ers) {
    var components;
    (function (components) {
        var layout;
        (function (layout) {
                        /*
             * SplitterDelegate class
             * @class
             */
            var SplitterDelegate = (function () {
                /*
                 * @constructor
                 * @param element The DOM element (splitter representation).
                 */
                function SplitterDelegate(element, $timeout, proxy) {
                    if (proxy === void 0) { proxy = false; }
                    /* Mouse position handler. */
                    this.mousePos = { x: 0, y: 0 };
                    this.element = element;
                    this.configureElements($timeout, proxy);
                }
                /*
                 * @function configure object
                 */
                SplitterDelegate.prototype.configureElements = function ($timeout, proxy) {
                    this.element.addClass(SplitterDelegate.FLEX_FIXED_STYLE);
                    // Set proxy
                    if (proxy) {
                        this.delegate = new layout.SplitterProxy(this);
                    }
                    else {
                        this.delegate = new layout.SplitterDirect(this);
                    }
                };
                /*
                 * Notify that splitter is busy
                 */
                SplitterDelegate.prototype.beginProcessing = function () {
                    this.parentContainer.beginProcessing();
                };
                /*
                 * Notify that splitter is idle.
                 */
                SplitterDelegate.prototype.endProcessing = function () {
                    this.parentContainer.endProcessing();
                };
                /*
                 * Notify when object loaded.
                 */
                SplitterDelegate.prototype.notifyLoaded = function () {
                    // Default: nothing
                };
                /*
                 * @function Delegate action on mouse down to the appropriate proxy
                 * @param event The event raised
                 */
                SplitterDelegate.prototype.onMouseDown = function (event) {
                    // Change state for parent controller
                    this.beginProcessing();
                    this.delegate.doMouseDown(event);
                };
                /*
                 * @function Delegate action on mouse up to the appropriate proxy.
                 * @param event
                 */
                SplitterDelegate.prototype.onMouseUp = function (event, trigger) {
                    this.delegate.doMouseUp(event);
                    // Change state for parent controller
                    this.endProcessing();
                };
                /*
                 * @function Delegate action on mouse move to the appropriate proxy.
                 * @param event
                 */
                SplitterDelegate.prototype.onMouseMove = function (event, trigger) {
                    this.delegate.doMouseMove(event);
                };
                /*
                 * Set the parent container (i.e. layout)
                 * @param parent the parent container.
                 */
                SplitterDelegate.prototype.setParentContainer = function (parent) {
                    this.parentContainer = parent;
                };
                Object.defineProperty(SplitterDelegate.prototype, "controller", {
                    /*
                     * Handler to the component controller.
                     * @returns {any} the splitter controller
                     */
                    get: function () {
                        return this.element.controller("ersSplitter");
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(SplitterDelegate.prototype, "prev", {
                    /*
                     * Get the first previous wrapper from the current splitter.
                     * @returns {IAugmentedJQuery} the previous wrapper element.
                     */
                    get: function () {
                        return angular.element(this.element.prevAll("." + SplitterDelegate.CSS_FILTER).first());
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(SplitterDelegate.prototype, "next", {
                    /*
                     * Get the first next wrapper from the current splitter.
                     * @returns {IAugmentedJQuery} the next wrapper element.
                     */
                    get: function () {
                        return angular.element(this.element.nextAll("." + SplitterDelegate.CSS_FILTER).first());
                    },
                    enumerable: true,
                    configurable: true
                });
                /*
                 * @function Switch the flex box ability from fixed to stretch.
                 * @param element The DOM element on which apply style
                 */
                SplitterDelegate.prototype.switchFlexbox = function (element) {
                    if (!element.hasClass("ers-flex-grow")) {
                        element.addClass("ers-flex-grow");
                    }
                    if (element.hasClass("ers-flex-fixed")) {
                        element.removeClass("ers-flex-fixed");
                    }
                };
                SplitterDelegate.prototype.switchFixed = function (element) {
                    if (!element.hasClass("ers-flex-fixed")) {
                        element.addClass("ers-flex-fixed");
                    }
                    if (element.hasClass("ers-flex-grow")) {
                        element.removeClass("ers-flex-grow");
                    }
                };
                /* Generic splitter CSS definition */
                SplitterDelegate.FLEX_FIXED_STYLE = "ers-flex-fixed";
                SplitterDelegate.CSS_FILTER = "ers-layout-wrapper";
                return SplitterDelegate;
            })();
            layout.SplitterDelegate = SplitterDelegate;
        })(layout = components.layout || (components.layout = {}));
    })(components = ers.components || (ers.components = {}));
})(ers || (ers = {}));
var ers;
(function (ers) {
    var components;
    (function (components) {
        var layout;
        (function (layout) {
                    })(layout = components.layout || (components.layout = {}));
    })(components = ers.components || (ers.components = {}));
})(ers || (ers = {}));



var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var ers;
(function (ers) {
    var components;
    (function (components) {
        var layout;
        (function (layout) {
                        /*
             * HorizontalSplitterDelegate class
             * @class
             */
            var HorizontalSplitterDelegate = (function (_super) {
                __extends(HorizontalSplitterDelegate, _super);
                /*
                 * @constructor
                 * @param element The DOM element (splitter representation).
                 */
                function HorizontalSplitterDelegate(element, $timeout, useProxy) {
                    if (useProxy === void 0) { useProxy = false; }
                    _super.call(this, element, $timeout, useProxy);
                }
                /*
                 * @function configure object
                 */
                HorizontalSplitterDelegate.prototype.configureElements = function ($timeout, proxy) {
                    var _this = this;
                    _super.prototype.configureElements.call(this, $timeout, proxy);
                    this.element.addClass(HorizontalSplitterDelegate.HORIZONTAL_SPLITTER_STYLE);
                    // Warning: wait until DOM is completely loaded to notify parent.
                    $timeout(function () {
                        _this.parentContainer.notifyLoaded();
                    }, 0);
                };
                /*
                 * Check constraint before move splitter.
                 * @param event mouse event
                 * @param splitter
                 * @returns {boolean} the ability to move or not.
                 */
                HorizontalSplitterDelegate.prototype.checkMoveConstraints = function (event) {
                    // Check if mouse is inside the movable area (between prev and next element)
                    var boundMax = this.parentContainer.getLayoutClientRect().left + this.next[0].offsetLeft +
                        this.next[0].offsetWidth;
                    var boundMin = this.parentContainer.getLayoutClientRect().left + this.prev[0].offsetLeft;
                    return event.pageX < boundMax && event.pageX > boundMin;
                };
                /*
                 * @function Compute and draw container after a resize event
                 * @param event The event raised when mouse move/click
                 * @param quantity quantity of move/resize
                 */
                HorizontalSplitterDelegate.prototype.resize = function (event, quantity) {
                    // Last check before resize => avoid to resize element which size is already 0.
                    if (this.prev[0].offsetWidth > 0 && quantity < 0 || this.next[0].offsetWidth > 0 && quantity > 0) {
                        var pW = this.prev[0].offsetWidth + quantity;
                        var nW = this.next[0].offsetWidth - quantity;
                        // New prev width
                        this.prev.width(((pW / this.parentContainer.getLayoutClientRect().width) * 100) + "%");
                        this.next.width(((nW / this.parentContainer.getLayoutClientRect().width) * 100) + "%");
                    }
                };
                /*
                 * @function Retrieve the horizontal (following x axis) quantity of move in pixel relative to the last mouse position.
                 * @param event The event raised when mouse move/click
                 * @returns {number} The quantity of move in pixel
                 */
                HorizontalSplitterDelegate.prototype.quantity = function (event) {
                    return event.pageX - this.mousePos.x;
                };
                /*
                 * Store the current position of the mouse.
                 * @param event The event raised on mouse click/move
                 */
                HorizontalSplitterDelegate.prototype.refreshMousePos = function (event) {
                    this.mousePos.x = event.pageX;
                };
                /*
                 * {@inherit}
                 */
                HorizontalSplitterDelegate.prototype.getSplitterSize = function () {
                    return this.delegate.element[0].offsetWidth; // Splitter width
                };
                /*
                 * {@inherit}
                 */
                HorizontalSplitterDelegate.prototype.getSplitterPosition = function () {
                    return this.delegate.element[0].offsetLeft;
                };
                /*
                 * {@inherit}
                 */
                HorizontalSplitterDelegate.prototype.setSplitterPosition = function (value) {
                    // Check position and display splitter between [minPos, maxPos]
                    var posMax = this.next[0].offsetLeft + this.next[0].offsetWidth - this.getSplitterSize();
                    var posMin = this.prev[0].offsetLeft;
                    var position = Math.max(Math.min(value, posMax), posMin);
                    this.delegate.element.css("left", position);
                };
                /*
                 * {@inherit}
                 */
                HorizontalSplitterDelegate.prototype.splitterStyle = function () {
                    return HorizontalSplitterDelegate.HORIZONTAL_PROXY_SPLITTER_STYLE;
                };
                /* Horizontal splitter CSS definition */
                HorizontalSplitterDelegate.HORIZONTAL_SPLITTER_STYLE = "ers-splitter-horizontal";
                HorizontalSplitterDelegate.HORIZONTAL_PROXY_SPLITTER_STYLE = "ers-proxy-splitter-h";
                return HorizontalSplitterDelegate;
            })(layout.SplitterDelegate);
            layout.HorizontalSplitterDelegate = HorizontalSplitterDelegate;
        })(layout = components.layout || (components.layout = {}));
    })(components = ers.components || (ers.components = {}));
})(ers || (ers = {}));

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var ers;
(function (ers) {
    var components;
    (function (components) {
        var layout;
        (function (layout) {
            var BaseController = ers.components.core.BaseController;
                        /**
             * @-ngdoc directive
             * @name ersLayoutSummary
             * @restrict A
             * @module ers.components.layout
             *
             *
             *
             * @description `ers-layout-summary` is not a standalone component. It must be used with `ers-layout` and
             * displays a text string on a splitter when the layout is fully collapsed.
             *
             * <!--[Layout](#/components/ersLayout/documentation)-->
             *
             *  <div style="width:400px;height:200px">
             *  <ers-layout direction="horizontal" ers-resize="" ers-collapse="horizontal">
             *  <div style="height:100%;width:100%;#D1D0CE" ers-layout-summary="Vertical Content 1 is fully collapsed">
             *  Vertical Content 1
             *  </div>
             *  <div style="height:100%;width:100%;background:#C7A395" ers-layout-summary="Vertical Content 2 is fully collapsed">
             *  Vertical Content 2
             *  </div>
             *   </ers-layout>
             *   </div>
             *
             * <div style="position:relative;width:400px;height:200px">
             * <ers-layout direction="horizontal" ers-resize ers-collapse="horizontal">
             * <div style="height:100%;width:100%;background:#D1D0CE" ers-layout-summary="horizontal collapse">
             * Horizontal Content 1
             * </div>
             * <ers-layout direction="vertical" ers-resize  ers-collapse="vertical">
             * <div  style="height:100%;width:100%;background:#DBDAD" ers-layout-summary="Fully Collapsed.">
             * Vertical Collapse Content 1
             * </div>
             * <div  style="height:100%;width:100%;background:#fdfdfd">
             * Vertical Content 2
             * </div>
             * </ers-layout>
             * </ers-layout>
             * </div>
             *
             *
             *
             *
             * ##### Styles
             *
             * `ers-layout-summary` uses a default style or can be styled with standard CSS.
             *
             * #### Restriction
             *
             * `ers-layout-summary` is an attribute used with an `ers-layout` component in an HTML structure.
             *
             *
             * #### Example
             *
             * This following code sample illustrates the description example:
             *
             * ```xml
             *  <div style="width:400px;height:200px">
             *  <ers-layout direction="horizontal" ers-resize ers-collapse="vertical">
             *    <div style="height:100%;width:100%"
             *         ers-layout-summary="Vertical content 1 is fully collapsed">
             *     Vertical Content 1
             *    </div>
             *    <div style="height:100%;width:100%"
             *         ers-layout-summary="Vertical content 2 is fully collapsed">>
             *     Vertical Content 2
             *    </div>
             *   </ers-layout>
             *   </div>
             * ```
             */
            var layoutSummaryDirective = function () {
                return {
                    restrict: "A",
                    require: ["ersLayoutSummary", "^ersLayout"],
                    controller: LayoutSummary,
                    bindToController: true,
                    link: function ($scope, $element, $attributes, controllers) {
                        var summary = controllers[0];
                        if (summary) {
                            summary.link();
                        }
                    }
                };
            };
            /**
             * Basic controller to store and retrieve summary link toan element.
             */
            var LayoutSummary = (function (_super) {
                __extends(LayoutSummary, _super);
                /*
                 * Constructor
                 */
                function LayoutSummary($scope, $element, $attrs) {
                    _super.call(this, $scope, $element, $attrs);
                }
                /*
                 * add class and manage summary behavior.
                 */
                LayoutSummary.prototype.link = function () {
                    var _this = this;
                    this.$element.addClass("ers-summary");
                    this.$attrs.$observe("ersLayoutSummary", function () {
                        _this.text = _this.$attrs["ersLayoutSummary"];
                    });
                };
                LayoutSummary.$inject = ["$scope", "$element", "$attrs"];
                return LayoutSummary;
            })(BaseController);
            layout.LayoutSummary = LayoutSummary;
            // Define the module
            angular.module("ers.components.layout").directive("ersLayoutSummary", layoutSummaryDirective);
        })(layout = components.layout || (components.layout = {}));
    })(components = ers.components || (ers.components = {}));
})(ers || (ers = {}));



var ers;
(function (ers) {
    var components;
    (function (components) {
        var layout;
        (function (layout_1) {
                        /*
             * CollapseHelper class
             * @class
             */
            var LayoutHelper = (function () {
                /*
                 * @constructor
                 * @param delegate the collapsible object
                 * @param prevButton previous DOM element (from splitter DOM element)
                 * @param nextButton next DOM element (from splitter DOM element)
                 */
                function LayoutHelper(delegate) {
                    this.state = LayoutHelper.EXPAND_STATE;
                    /* To store the size of element before it was collapsed. */
                    this.collapsedLayoutSize = 0;
                    /* The collapsed DOM element (if exists). */
                    this.collapsed = null;
                    /* The expanded DOM element (if exists). */
                    this.expanded = null;
                    this.delegate = delegate;
                }
                /*
                 * Append the DOM representation of a collapse element.
                 * @param element the element on which append the collapsed node.
                 */
                LayoutHelper.prototype.appendCollapse = function (element) {
                    /* Collapsed DOM node. */
                    var collapse = angular.element("<div class=\"ers-collapsed-layout\">" +
                        "  <div class=\"ers-collapsed-text\">" + "  </div>" +
                        "</div>");
                    if (!element.hasClass("collapse-node")) {
                        element.append(collapse);
                        element.addClass("collapse-node");
                        // Default: hide collapse node
                        collapse.hide(true);
                    }
                };
                /*
                 * Action to perform on 'click' event.
                 * @param button the element on which action click occures
                 * @param collapsed the collpased element when 'click' occures
                 * @param displayed the expanded element when 'click' occures
                 */
                LayoutHelper.prototype.setCallback = function (button, collapsed, displayed) {
                    var _this = this;
                    if (button) {
                        button.on("click", function (event) {
                            _this.onButtonClick(event, collapsed, displayed);
                        });
                    }
                };
                /*
                 * @function the action to perform on click button, depending on the button click (left/top, right/bottom).
                 * @param event The event raised on button click.
                 * @param collapsed the collapsed DOM element (graphical container)
                 * @param expanded the expanded DOM element (graphical container)
                 */
                LayoutHelper.prototype.onButtonClick = function (event, collapsed, expanded) {
                    // Stop event propagation
                    //event.stopImmediatePropagation();
                    //event.preventDefault();
                    // If helper state and "collapsed" DOM element are not collapsed then force collapse.
                    // Else expand.
                    if (!this.isCollapsedLayout(collapsed)) {
                        if (!this.isCollapsedLayout(expanded)) {
                            this.forceCollapse(event, collapsed, expanded);
                        }
                        else {
                            this.delegate.doExpandAuto(event);
                        }
                    }
                };
                /*
                 * @function To force a graphical container, which is collapsed, to expand.
                 * @param event The event raised when expand was asked
                 * @param collapsed the collapsed DOM element (graphical container)
                 * @param expanded the expanded DOM element (graphical container)
                 * @param compute if true, the size of each element (collapsed, expanded) is computed and redrawn.
                 */
                LayoutHelper.prototype.forceExpand = function (event, collapsed, expanded, compute) {
                    if (compute === void 0) { compute = true; }
                    this.delegate.beginProcessing();
                    this.toggleState(LayoutHelper.EXPAND_STATE);
                    this.collapsed = collapsed;
                    this.expanded = expanded;
                    this.delegate.doExpand(event, compute);
                    // At the end of treatment , remove the state information
                    this.removeState();
                    this.delegate.endProcessing();
                };
                /*
                 * @function To force a graphical container, which is expanded, to collapse.
                 * @param event The event raised when expand was asked
                 * @param collapsed the collapsed DOM element (graphical container)
                 * @param expanded the expanded DOM element (graphical container)
                 * @param compute if true, the size of each element (collapsed, expanded) is computed and redrawn.
                 */
                LayoutHelper.prototype.forceCollapse = function (event, collapsed, expanded, compute) {
                    if (compute === void 0) { compute = true; }
                    this.delegate.beginProcessing();
                    this.toggleState(LayoutHelper.COLLAPSE_STATE);
                    this.collapsed = collapsed;
                    this.expanded = expanded;
                    this.addState();
                    this.delegate.doCollapse(event, compute);
                    this.delegate.endProcessing();
                };
                /*
                 * Retrieve if exists the summary linked to the collapsed element.
                 * @returns {string} the summary as text.
                 */
                LayoutHelper.prototype.getSummary = function () {
                    if (this.collapsed) {
                        var summary = this.collapsed.hasClass("ers-summary") ? this.collapsed : this.collapsed.find(".ers-summary");
                        if (summary) {
                            var summaryCtrl = summary.controller("ersLayoutSummary");
                            if (summaryCtrl) {
                                return summaryCtrl.text;
                            }
                        }
                    }
                    return "";
                };
                /*
                 * A trick to store important information on the current state of the helper using DOM class attribute,
                 * and know which element is collapsed and which element is expandeded.
                 */
                LayoutHelper.prototype.addState = function () {
                    this.collapsed.addClass("state-collapsed");
                    if (this.delegate.prev.hasClass("state-collapsed")) {
                        this.collapsed.addClass("state-prev-collapsed");
                    }
                    else {
                        this.collapsed.addClass("state-next-collapsed");
                    }
                };
                /*
                 * A trick to remove useless information set by `addState`.
                 */
                LayoutHelper.prototype.removeState = function () {
                    this.collapsed.removeClass("state-prev-collapsed");
                    this.collapsed.removeClass("state-next-collapsed");
                    this.collapsed.removeClass("state-collapsed");
                };
                /*
                 * @function switch between the allowed states of the helper.
                 * @param state The new state (EXPAND/COLLAPSE) if set
                 */
                LayoutHelper.prototype.toggleState = function (state) {
                    if (state === void 0) { state = null; }
                    // Change state
                    if (!state) {
                        // Toggle state
                        this.state = this.isCollapsed() ? LayoutHelper.EXPAND_STATE : LayoutHelper.COLLAPSE_STATE;
                    }
                    else {
                        // force state
                        this.state = state;
                    }
                };
                /*
                 * State of the left/top element is collapsed
                 * @returns {boolean} true if collapsed
                 */
                LayoutHelper.prototype.isPrevCollapsed = function () {
                    return this.delegate.prev.hasClass("state-prev-collapsed");
                };
                /*
                 * State of the right/bottom element is collapsed
                 * @returns {boolean} true if collapsed
                 */
                LayoutHelper.prototype.isNextCollapsed = function () {
                    return this.delegate.next.hasClass("state-next-collapsed");
                };
                /*
                 * State of a given element.
                 * @param layout the requested element
                 * @returns {boolean} true if collapsed.
                 */
                LayoutHelper.prototype.isCollapsedLayout = function (layout) {
                    return (layout.hasClass("state-prev-collapsed") || layout.hasClass("state-next-collapsed"));
                };
                LayoutHelper.prototype.isCollapsed = function () {
                    return this.state === LayoutHelper.COLLAPSE_STATE;
                };
                LayoutHelper.COLLAPSE_STATE = 1000;
                LayoutHelper.EXPAND_STATE = 1001;
                return LayoutHelper;
            })();
            layout_1.LayoutHelper = LayoutHelper;
        })(layout = components.layout || (components.layout = {}));
    })(components = ers.components || (ers.components = {}));
})(ers || (ers = {}));




var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var ers;
(function (ers) {
    var components;
    (function (components) {
        var layout;
        (function (layout) {
                        /*
             * HorizontalCollapsibleDelegate class
             * @class
             */
            var HorizontalCollapsibleDelegate = (function (_super) {
                __extends(HorizontalCollapsibleDelegate, _super);
                /*
                 * @constructor
                 * @param element The DOM element (splitter representation).
                 * @param useProxy define or not a proxy for the splitter.
                 */
                function HorizontalCollapsibleDelegate(element, $timeout, useProxy) {
                    if (useProxy === void 0) { useProxy = false; }
                    _super.call(this, element, $timeout, useProxy);
                    /* Default size to apply when element is collapsed. */
                    this.collapsedSize = layout.Constants.COLLAPSIBLE_DEFAULT_SIZE;
                }
                /*
                 * @function configure object
                 */
                HorizontalCollapsibleDelegate.prototype.configureElements = function ($timeout, proxy) {
                    _super.prototype.configureElements.call(this, $timeout, proxy);
                    // Add button to DOM
                    var options = this.element.controller("ersSplitter").ersCollapse;
                    // Build collapsible helper
                    this.helper = new layout.LayoutHelper(this);
                    // Build button and draggable area on splitter
                    this.buildSplittersOptions(options);
                    // Build collapsible element (helper has to be build)
                    this.buildCollapse(options);
                };
                /*
                 * Build splitter depending on selected options.
                 * @param options splitter options.
                 */
                HorizontalCollapsibleDelegate.prototype.buildSplittersOptions = function (options) {
                    // Get prev/next collapsed button image
                    var onBothSide = options === "onBothSide";
                    var onLeft = options === "onLeft";
                    if (onLeft || onBothSide) {
                        var prevButton = this.element.find(".ers-prev-button-area");
                        prevButton.show();
                        this.helper.setCallback(prevButton, this.prev, this.next);
                    }
                    var onRight = options === "onRight";
                    if (onRight || onBothSide) {
                        var nextButton = this.element.find(".ers-next-button-area");
                        nextButton.show();
                        this.helper.setCallback(nextButton, this.next, this.prev);
                    }
                };
                /*
                 * Build the DOM element which is in charge of the collapsible display.
                 * @param options splitter options.
                 */
                HorizontalCollapsibleDelegate.prototype.buildCollapse = function (options) {
                    // Set style to each element
                    var onBothSide = options === "onBothSide";
                    // Add css class to inform about button presence.
                    this.element.addClass((!onBothSide) ? "ers-single-side" : "ers-both-side");
                    // Build collapsed
                    if (options === layout.Constants.ON_COLLAPSE_LEFT || layout.Constants.ON_COLLAPSE_BOTH) {
                        this.helper.appendCollapse(this.prev);
                    }
                    if (options === layout.Constants.ON_COLLAPSE_RIGHT || layout.Constants.ON_COLLAPSE_BOTH) {
                        this.helper.appendCollapse(this.next);
                    }
                };
                /*
                 * @function Collapse the appropriate container.
                 * @param event The event raised when container collapse.
                 * @param needResize compute size of expanded container if true.
                 */
                HorizontalCollapsibleDelegate.prototype.doCollapse = function (event, needResize) {
                    if (needResize === void 0) { needResize = true; }
                    // Prepare and add collapsed element
                    this.collapsedNode(true);
                    // Collapse layout
                    if (needResize) {
                        // Widths compute after the deletion of the collapsed layout
                        this.computeCollapsed();
                    }
                    // Notify resize
                    this.controller.callTriggerResizeEvent();
                };
                /*
                 * @function Expand the appropriate container.
                 * @param event The event raised when container expands
                 * @param needResize compute size of expanded container if true.
                 */
                HorizontalCollapsibleDelegate.prototype.doExpand = function (event, needResize) {
                    if (needResize === void 0) { needResize = true; }
                    // Remove collapsed
                    this.collapsedNode(false);
                    // Retrieve size and expand layout
                    if (needResize) {
                        // Resizing has to be done after the deletion of the collapsed layout
                        this.computeExpanded();
                    }
                    // Notify resize
                    this.controller.callTriggerResizeEvent();
                };
                /*
                 * Automatically expand the appropriate wrapper element on mouse click.
                 * @param event mouse event
                 */
                HorizontalCollapsibleDelegate.prototype.doExpandAuto = function (event) {
                    if (this.helper.isCollapsedLayout(this.prev)) {
                        this.prevExpandOnMove(event);
                    }
                    // Case 2: When splitter can move on the left, and next layout (right) is collapsed.
                    // next layout (right) has to be expand.
                    if (this.helper.isCollapsedLayout(this.next)) {
                        this.nextExpandOnMove(event);
                    }
                };
                /*
                 * @function Check if constraints relative to splitter move are respected.
                 * If constraints are reached the appropriate container has to be collapsed/expand
                 * @param event The event raised when mouse move/click
                 * @param quantity The quantity of move (following x axis)
                 * @returns {boolean} true if constraints are respected.
                 */
                HorizontalCollapsibleDelegate.prototype.checkResize = function (event, quantity) {
                    // Treat specific collapsible cases.
                    // Case 1: when splitter reach the min width on the left => collapse the left side
                    if (this.prev[0].offsetWidth + quantity <= this.delegate.sensibility) {
                        this.prev.addClass("w-p-to-collapse");
                        return true;
                    }
                    // Case 2: when splitter reach the min width on the right side => collapse the right side
                    if (this.next[0].offsetWidth - quantity <= this.delegate.sensibility) {
                        this.next.addClass("w-n-to-collapse");
                        return true;
                    }
                };
                /*
                 * {@inherit}
                 */
                HorizontalCollapsibleDelegate.prototype.resize = function (event, quantity) {
                    // Check move => collapse/expand neighbour ?
                    this.checkResize(event, quantity);
                    // Case 1: When splitter can move on the right, and prev layout (left) is collapsed.
                    // prev layout (left) has to be expand
                    if (this.helper.isCollapsedLayout(this.prev)) {
                        this.prevExpandOnMove(event);
                    }
                    // Case 2: When splitter can move on the left, and next layout (right) is collapsed.
                    // next layout (right) has to be expand.
                    if (this.helper.isCollapsedLayout(this.next)) {
                        this.nextExpandOnMove(event);
                    }
                    // Case 3: when splitter reach the min width on the left => collapse the left side
                    if (this.prev.hasClass("w-p-to-collapse")) {
                        this.prev.removeClass("w-p-to-collapse");
                        this.helper.forceCollapse(event, this.prev, this.next);
                        return; // stop treatment here (don't call resize)
                    }
                    // Case 4: when splitter reach the min width on the right side => collapse the right side
                    if (this.next.hasClass("w-n-to-collapse")) {
                        this.next.removeClass("w-n-to-collapse");
                        this.helper.forceCollapse(event, this.next, this.prev);
                        return; // stop treatment here (don't call resize)
                    }
                    // Default: use the super.resize method
                    _super.prototype.resize.call(this, event, quantity);
                };
                /*
                 * @function Access the first right neighbor of the splitter.
                 * @returns {HorizontalCollapsibleDelegate} The first right neighbor container.
                 */
                HorizontalCollapsibleDelegate.prototype.getSplitterDelegateFrom = function (from) {
                    var splitter = angular.element(angular.element(from.first()));
                    var comp = splitter.controller("ersSplitter");
                    return comp.delegate;
                };
                /*
                 * @function If splitter moves and its left container is collapsed, force the container to expand.
                 * @param event The raised event.
                 */
                HorizontalCollapsibleDelegate.prototype.nextExpandOnMove = function (event) {
                    if (this.helper.isNextCollapsed()) {
                        this.helper.forceExpand(event, this.next, this.prev, false);
                    }
                    else {
                        var delegate = this.getSplitterDelegateFrom(this.element.nextAll("ers-splitter"));
                        delegate.helper.forceExpand(event, delegate.prev, delegate.next, false);
                    }
                };
                /*
                 * @function If splitter moves and its right container is collapsed, force the container to expand.
                 * @param event The raised event.
                 */
                HorizontalCollapsibleDelegate.prototype.prevExpandOnMove = function (event) {
                    // Check if prev layout is collapsed and expand it.
                    if (this.helper.isPrevCollapsed()) {
                        this.helper.forceExpand(event, this.prev, this.next, false);
                    }
                    else {
                        var delegate = this.getSplitterDelegateFrom(this.element.prevAll("ers-splitter"));
                        delegate.helper.forceExpand(event, delegate.next, delegate.prev, false);
                    }
                };
                /*
                 *  Compute widths (next and prev element) when node expands.
                 */
                HorizontalCollapsibleDelegate.prototype.computeExpanded = function () {
                    // Retrieve original size (on collapsed node)
                    var collapsePct = layout.layoutUtils.attr2Number(this.helper.collapsed, "before-collapsed-size-percent");
                    this.helper.collapsed.removeAttr("before-collapsed-size-percent");
                    // Compute new sizes.
                    var parentW = this.parentContainer.getLayoutClientRect().width;
                    var expandPct = ((this.helper.expanded[0].offsetWidth + this.collapsedSize) * 100) / parentW;
                    if (collapsePct > expandPct) {
                        collapsePct = expandPct = expandPct * .5; // here can not restore original size => equal size, the small / 2
                    }
                    else {
                        expandPct = expandPct - collapsePct;
                    }
                    // Apply computed width
                    this.switchFlexbox(this.helper.collapsed);
                    this.helper.collapsed.width(collapsePct + "%");
                    this.helper.expanded.width(expandPct + "%");
                };
                /*
                 * Compute widths (next and prev element) when node become collapsed.
                 */
                HorizontalCollapsibleDelegate.prototype.computeCollapsed = function () {
                    // Apply computed width
                    var parentW = this.parentContainer.getLayoutClientRect().width;
                    var collapsedW = this.helper.collapsed[0].offsetWidth;
                    var expandedW = this.helper.expanded[0].offsetWidth;
                    // Collapsed part has to be in px and always fixed
                    this.helper.collapsed.attr("before-collapsed-size-percent", (collapsedW * 100) / parentW);
                    this.helper.expanded.width((((expandedW + collapsedW - this.collapsedSize) * 100) / parentW) + "%");
                    this.helper.collapsed.width(this.collapsedSize + "px");
                    this.switchFixed(this.helper.collapsed);
                    this.switchFlexbox(this.helper.expanded);
                };
                /*
                 * The DOM representation of the collapsed container.
                 * @returns {ng.IAugmentedJQuery} The collapsed DOM element which will replace the collapsed container.
                 */
                HorizontalCollapsibleDelegate.prototype.collapsedNode = function (show) {
                    if (show) {
                        this.computeCollapsedStyles();
                    }
                    else {
                        this.computeExpandedStyles();
                    }
                };
                /*
                 * Add style to splitter when collapsed.
                 */
                HorizontalCollapsibleDelegate.prototype.computeCollapsedStyles = function () {
                    // Switch to display collapsed node.
                    var content = this.helper.collapsed.children(":not(.ers-collapsed-layout)");
                    content.hide();
                    var collapsed = this.helper.collapsed.children(".ers-collapsed-layout");
                    this.prepareCollapseNode(collapsed);
                    this.buildSummary(collapsed, content);
                    // Hide splitters' buttons
                    this.element.find(".ers-prev-button-area").hide();
                    this.element.find(".ers-next-button-area").hide();
                    if (this.helper.isPrevCollapsed()) {
                        this.element.addClass(HorizontalCollapsibleDelegate.LEFT_COLLAPSED_STYLE);
                    }
                    else {
                        this.element.addClass(HorizontalCollapsibleDelegate.RIGHT_COLLAPSED_STYLE);
                    }
                };
                /*
                 * Add style to splitter when expanded.
                 */
                HorizontalCollapsibleDelegate.prototype.computeExpandedStyles = function () {
                    // Switch to display collapsed node.
                    var collapsed = this.helper.collapsed.children(".ers-collapsed-layout");
                    var content = this.helper.collapsed.children(":not(.ers-collapsed-layout)");
                    collapsed.hide();
                    content.show();
                    // Show buttons on collapse
                    this.element.find(".ers-prev-button-area").show();
                    this.element.find(".ers-next-button-area").show();
                    // remove collapsed class
                    if (this.helper.isCollapsedLayout(this.prev)) {
                        this.element.removeClass(HorizontalCollapsibleDelegate.LEFT_COLLAPSED_STYLE);
                    }
                    else {
                        this.element.removeClass(HorizontalCollapsibleDelegate.RIGHT_COLLAPSED_STYLE);
                    }
                };
                /*
                 * Some initialisation on the collapsed node.
                 * @param collapsed the collapsed node
                 */
                HorizontalCollapsibleDelegate.prototype.prepareCollapseNode = function (collapsed) {
                    var _this = this;
                    collapsed.show();
                    collapsed.addClass(HorizontalCollapsibleDelegate.HORIZONTAL_COLLAPSE_STYLE);
                    collapsed.addClass("ers-fill");
                    // Add Trigger on 'click' event => expand collapsed node.
                    collapsed.on("click", function () {
                        if (!_this.helper.isCollapsed()) {
                            collapsed.off("click"); // no more action
                            return;
                        }
                        // Expand only if collapsed panel is not collapsed on another collapsed panel (case with 3 or more layout)
                        if (!_this.helper.isCollapsedLayout(_this.helper.expanded)) {
                            _this.helper.forceExpand(null, _this.helper.collapsed, _this.helper.expanded);
                            collapsed.off("click"); // no more action after expand
                        }
                    });
                };
                /*
                 * Build message to display when element is collapsed.
                 * @param collapsed the collapsed element
                 * @param content the element not collapsed
                 */
                HorizontalCollapsibleDelegate.prototype.buildSummary = function (collapsed, content) {
                    var summary = $("<div>" + this.helper.getSummary() + "</div>");
                    // Remove old content
                    collapsed.children().remove();
                    // Inverse height/width for the rotation. obtain the appropriate size for the text before its rotation
                    summary.css("height", collapsed[0].offsetWidth + "px");
                    summary.css("width", collapsed[0].offsetHeight + "px");
                    // Rotate the text
                    summary.addClass(HorizontalCollapsibleDelegate.COLLAPSED_TEXT_STYLE);
                    collapsed.append(summary);
                };
                /* Horizontal splitter CSS definition */
                HorizontalCollapsibleDelegate.HORIZONTAL_COLLAPSE_STYLE = "ers-collapsed-horizontal";
                HorizontalCollapsibleDelegate.LEFT_COLLAPSED_STYLE = "ers-collapsed-left";
                HorizontalCollapsibleDelegate.RIGHT_COLLAPSED_STYLE = "ers-collapsed-right";
                HorizontalCollapsibleDelegate.COLLAPSED_TEXT_STYLE = "ers-collapsed-text";
                return HorizontalCollapsibleDelegate;
            })(layout.HorizontalSplitterDelegate);
            layout.HorizontalCollapsibleDelegate = HorizontalCollapsibleDelegate;
        })(layout = components.layout || (components.layout = {}));
    })(components = ers.components || (ers.components = {}));
})(ers || (ers = {}));

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var ers;
(function (ers) {
    var components;
    (function (components) {
        var layout;
        (function (layout) {
                        /*
             * VerticalSplitterDelegate class
             * @class
             */
            var VerticalSplitterDelegate = (function (_super) {
                __extends(VerticalSplitterDelegate, _super);
                /*
                 * @constructor
                 * @param element The DOM element (splitter representation).
                 */
                function VerticalSplitterDelegate(element, $timeout, useProxy) {
                    if (useProxy === void 0) { useProxy = false; }
                    _super.call(this, element, $timeout, useProxy);
                }
                /*
                 * @function configure object
                 */
                VerticalSplitterDelegate.prototype.configureElements = function ($timeout, proxy) {
                    var _this = this;
                    _super.prototype.configureElements.call(this, $timeout, proxy);
                    this.element.addClass(VerticalSplitterDelegate.VERTICAL_SPLITTER_STYLE);
                    // Warning: wait until DOM is completely loaded to notify parent.
                    $timeout(function () {
                        _this.parentContainer.notifyLoaded();
                    }, 0);
                };
                /*
                 * Check constraint before move splitter.
                 * @param event mouse event.
                 * @returns {boolean} the ability to move or not.
                 */
                VerticalSplitterDelegate.prototype.checkMoveConstraints = function (event) {
                    // Check if mouse is inside the movable area (between prev and next element)
                    var boundMax = this.parentContainer.getLayoutClientRect().top + this.next[0].offsetTop + this.next[0].offsetHeight;
                    var boundMin = this.parentContainer.getLayoutClientRect().top + this.prev[0].offsetTop;
                    return event.pageY <= boundMax && event.pageY >= boundMin;
                };
                /*
                 * @function Compute and draw container after a resize event
                 * @param event The event raised when mouse move/click
                 * @param quantity quantity of move/resize
                 */
                VerticalSplitterDelegate.prototype.resize = function (event, quantity) {
                    // Last check before resize => avoid to resize element which size is already 0.
                    if (this.prev[0].offsetHeight > 0 && quantity < 0 ||
                        this.next[0].offsetHeight > 0 && quantity > 0) {
                        var pH = this.prev[0].offsetHeight + quantity;
                        var nH = this.next[0].offsetHeight - quantity;
                        this.prev.height((pH / (this.parentContainer.getLayoutClientRect().height)) * 100 + "%");
                        this.next.height((nH / (this.parentContainer.getLayoutClientRect().height)) * 100 + "%");
                    }
                };
                /*
                 * @function Retrieve the vertical (following y axis) quantity of move in pixel relative to the last mouse position.
                 * @param event The event raised when mouse move/click
                 * @returns {number} The quantity of move in pixel
                 */
                VerticalSplitterDelegate.prototype.quantity = function (event) {
                    return event.pageY - this.mousePos.y;
                };
                /*
                 * Store the current position of the mouse.
                 * @param event The event raised on mouse click/move
                 */
                VerticalSplitterDelegate.prototype.refreshMousePos = function (event) {
                    this.mousePos.y = event.pageY;
                };
                /*
                 * {@inherit}
                 */
                VerticalSplitterDelegate.prototype.getSplitterSize = function () {
                    return this.delegate.element[0].offsetHeight;
                };
                /*
                 * {@inherit}
                 */
                VerticalSplitterDelegate.prototype.getSplitterPosition = function () {
                    return this.delegate.element[0].offsetTop;
                };
                /*
                 * {@inherit}
                 */
                VerticalSplitterDelegate.prototype.setSplitterPosition = function (value) {
                    // Check position and display splitter between [minPos, maxPos]
                    var posMax = this.next[0].offsetTop + this.next[0].offsetHeight - this.getSplitterSize();
                    var posMin = this.prev[0].offsetTop;
                    var position = Math.max(Math.min(value, posMax), posMin);
                    this.delegate.element.css("top", position);
                };
                /*
                 * {@inherit}
                 */
                VerticalSplitterDelegate.prototype.splitterStyle = function () {
                    return VerticalSplitterDelegate.VERTICAL_PROXY_SPLITTER_STYLE;
                };
                /* Vertical splitter CSS definition */
                VerticalSplitterDelegate.VERTICAL_SPLITTER_STYLE = "ers-splitter-vertical";
                VerticalSplitterDelegate.VERTICAL_PROXY_SPLITTER_STYLE = "ers-proxy-splitter-v";
                return VerticalSplitterDelegate;
            })(layout.SplitterDelegate);
            layout.VerticalSplitterDelegate = VerticalSplitterDelegate;
        })(layout = components.layout || (components.layout = {}));
    })(components = ers.components || (ers.components = {}));
})(ers || (ers = {}));



var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var ers;
(function (ers) {
    var components;
    (function (components) {
        var layout;
        (function (layout) {
                        /*
             * VerticalCollapsibleDelegate class
             * @class
             */
            var VerticalCollapsibleDelegate = (function (_super) {
                __extends(VerticalCollapsibleDelegate, _super);
                /*
                 * @constructor
                 * @param element The DOM element (splitter representation).
                 * @param useProxy define or not a proxy for the splitter.
                 */
                function VerticalCollapsibleDelegate(element, $timeout, useProxy) {
                    if (useProxy === void 0) { useProxy = false; }
                    _super.call(this, element, $timeout, useProxy);
                    /* Default size to apply when element is collapsed. */
                    this.collapsedSize = layout.Constants.COLLAPSIBLE_DEFAULT_SIZE;
                }
                /*
                 * @function configure object
                 */
                VerticalCollapsibleDelegate.prototype.configureElements = function ($timeout, proxy) {
                    _super.prototype.configureElements.call(this, $timeout, proxy);
                    // Add button to DOM
                    var options = this.element.controller("ersSplitter").ersCollapse;
                    // Build collapsible helper
                    this.helper = new layout.LayoutHelper(this);
                    // Build button and draggable area on splitter
                    this.buildSplittersOptions(options);
                    // Build collapsible element (helper has to be build)
                    this.buildCollapse(options);
                };
                /*
                 * Build splitter depending on selected options.
                 * @param options splitter options.
                 */
                VerticalCollapsibleDelegate.prototype.buildSplittersOptions = function (options) {
                    // Get prev/next collapsed button image
                    var onBothSide = options === "onBothSide";
                    var onTop = options === "onTop";
                    if (onTop || onBothSide) {
                        var prevButton = this.element.find(".ers-prev-button-area");
                        prevButton.show();
                        this.helper.setCallback(prevButton, this.prev, this.next);
                    }
                    var onBottom = options === "onBottom";
                    if (onBottom || onBothSide) {
                        var nextButton = this.element.find(".ers-next-button-area");
                        nextButton.show();
                        this.helper.setCallback(nextButton, this.next, this.prev);
                    }
                };
                /*
                 * Build the DOM element which is in charge of the collapsible display.
                 * @param options splitter options.
                 */
                VerticalCollapsibleDelegate.prototype.buildCollapse = function (options) {
                    // Set style to each element
                    var onBothSide = options === "onBothSide";
                    // Add css class to inform about button presence.
                    this.element.addClass((!onBothSide) ? "ers-single-side" : "ers-both-side");
                    // Build collapsed
                    if (options === layout.Constants.ON_COLLAPSE_LEFT || layout.Constants.ON_COLLAPSE_BOTH) {
                        this.helper.appendCollapse(this.prev);
                    }
                    if (options === layout.Constants.ON_COLLAPSE_RIGHT || layout.Constants.ON_COLLAPSE_BOTH) {
                        this.helper.appendCollapse(this.next);
                    }
                };
                /*
                 * @function Collapse the appropriate container.
                 * @param event The event raised when container collapse.
                 * @param needResize compute size of expanded container if true.
                 */
                VerticalCollapsibleDelegate.prototype.doCollapse = function (event, needResize) {
                    if (needResize === void 0) { needResize = true; }
                    // Prepare and add collapsed element
                    this.collapsedNode(true);
                    // Collapse layout
                    if (needResize) {
                        // Widths compute after the deletion of the collapsed layout
                        this.computeCollapsed();
                    }
                    // Notify resize
                    this.controller.callTriggerResizeEvent();
                };
                /*
                 * @function Expand the appropriate container.
                 * @param event The event raised when container expands
                 * @param needResize compute size of expanded container if true.
                 */
                VerticalCollapsibleDelegate.prototype.doExpand = function (event, needResize) {
                    if (needResize === void 0) { needResize = true; }
                    // Remove collapsed
                    this.collapsedNode(false);
                    // Retrieve size and expand layout
                    if (needResize) {
                        // Resizing has to be done after the deletion of the collapsed layout
                        this.computeExpanded();
                    }
                    // Notify resize
                    this.controller.callTriggerResizeEvent();
                };
                /*
                 * Automatically expand the appropriate wrapper element on mouse click.
                 * @param event mouse event
                 */
                VerticalCollapsibleDelegate.prototype.doExpandAuto = function (event) {
                    if (this.helper.isCollapsedLayout(this.prev)) {
                        this.prevExpandOnMove(event);
                    }
                    // Case 2: When splitter can move on the left, and next layout (right) is collapsed.
                    // next layout (right) has to be expand.
                    if (this.helper.isCollapsedLayout(this.next)) {
                        this.nextExpandOnMove(event);
                    }
                };
                /*
                 * @function Check if constraints relative to splitter move are respected.
                 * If constraints are reached the appropriate container has to be collapsed/expand
                 * @param event The event raised when mouse move/click
                 * @param quantity The quantity of move (following y axis)
                 * @returns {boolean} true if constraints are respected.
                 */
                VerticalCollapsibleDelegate.prototype.checkResize = function (event, quantity) {
                    // Case 1: when splitter reach the min width on the left => collapse the left side
                    if (this.prev[0].offsetHeight + quantity <= this.delegate.sensibility) {
                        this.prev.addClass("h-p-to-collapse");
                        return;
                    }
                    // Case 2: when splitter reach the min width on the right side => collapse the right side
                    if (this.next[0].offsetHeight - quantity <= this.delegate.sensibility) {
                        this.next.addClass("h-n-to-collapse");
                        return;
                    }
                };
                /*
                 * {@inherit}
                 */
                VerticalCollapsibleDelegate.prototype.resize = function (event, quantity) {
                    // Check move => collapse/expand neighbour ?
                    this.checkResize(event, quantity);
                    // Case 1: When splitter can move on the right, and prev layout (left) is collapsed.
                    // prev layout (left) has to be expand
                    if (this.helper.isCollapsedLayout(this.prev)) {
                        this.prevExpandOnMove(event);
                    }
                    // Case 2: When splitter can move on the left, and next layout (right) is collapsed.
                    // next layout (right) has to be expand.
                    if (this.helper.isCollapsedLayout(this.next)) {
                        this.nextExpandOnMove(event);
                    }
                    // Case 3: when splitter reach the min width on the left => collapse the left side
                    if (this.prev.hasClass("h-p-to-collapse")) {
                        this.prev.removeClass("h-p-to-collapse");
                        this.helper.forceCollapse(event, this.prev, this.next);
                        return; // stop treatment here (don't call resize)
                    }
                    // Case 4: when splitter reach the min width on the right side => collapse the right side
                    if (this.next.hasClass("h-n-to-collapse")) {
                        this.next.removeClass("h-n-to-collapse");
                        this.helper.forceCollapse(event, this.next, this.prev);
                        return; // stop treatment here (don't call resize)
                    }
                    // Default: use the super.resize method
                    _super.prototype.resize.call(this, event, quantity);
                };
                /*
                 * @function Access the first right neighbor of the splitter.
                 * @returns {HorizontalCollapsibleDelegate} The first right neighbor container.
                 */
                VerticalCollapsibleDelegate.prototype.getSplitterDelegateFrom = function (from) {
                    var splitter = angular.element(angular.element(from.first()));
                    var comp = splitter.controller("ersSplitter");
                    return comp.delegate;
                };
                /*
                 * @function If splitter moves and its left container is collapsed, force the container to expand.
                 * @param event The raised event.
                 */
                VerticalCollapsibleDelegate.prototype.nextExpandOnMove = function (event) {
                    if (this.helper.isNextCollapsed()) {
                        this.helper.forceExpand(event, this.next, this.prev, false);
                    }
                    else {
                        var delegate = this.getSplitterDelegateFrom(this.element.nextAll("ers-splitter"));
                        delegate.helper.forceExpand(event, delegate.prev, delegate.next, false);
                    }
                };
                /*
                 * @function If splitter moves and its right container is collapsed, force the container to expand.
                 * @param event The raised event.
                 */
                VerticalCollapsibleDelegate.prototype.prevExpandOnMove = function (event) {
                    // Check if prev layout is collapsed and expand it.
                    if (this.helper.isPrevCollapsed()) {
                        this.helper.forceExpand(event, this.prev, this.next, false);
                    }
                    else {
                        var delegate = this.getSplitterDelegateFrom(this.element.prevAll("ers-splitter"));
                        delegate.helper.forceExpand(event, delegate.next, delegate.prev, false);
                    }
                };
                /*
                 *  Compute widths (next and prev element) when node expands.
                 */
                VerticalCollapsibleDelegate.prototype.computeExpanded = function () {
                    // Retrieve original size (on collapsed node)
                    var collapsePct = layout.layoutUtils.attr2Number(this.helper.collapsed, "before-collapsed-size-percent");
                    this.helper.collapsed.removeAttr("before-collapsed-size-percent");
                    // Compute new sizes.
                    var parentH = this.parentContainer.getLayoutClientRect().height;
                    var expandPct = ((this.helper.expanded[0].offsetHeight + this.collapsedSize) * 100) / parentH;
                    if (collapsePct > expandPct) {
                        collapsePct = expandPct = expandPct * .5; // here can not restore original size => equal size, the small / 2
                    }
                    else {
                        expandPct = expandPct - collapsePct;
                    }
                    // Apply computed width
                    this.switchFlexbox(this.helper.collapsed);
                    this.helper.collapsed.height(collapsePct + "%");
                    this.helper.expanded.height(expandPct + "%");
                };
                /*
                 * Compute widths (next and prev element) when node become collapsed.
                 */
                VerticalCollapsibleDelegate.prototype.computeCollapsed = function () {
                    // Apply computed width
                    var parentH = this.parentContainer.getLayoutClientRect().height;
                    var collapsedH = this.helper.collapsed[0].offsetHeight;
                    var expandedH = this.helper.expanded[0].offsetHeight;
                    // Collapsed part has to be in px and always fixed
                    this.helper.collapsed.attr("before-collapsed-size-percent", (collapsedH * 100) / parentH);
                    this.helper.expanded.height((((expandedH + collapsedH - this.collapsedSize) * 100) / parentH) + "%");
                    this.helper.collapsed.height(this.collapsedSize + "px");
                    this.switchFixed(this.helper.collapsed);
                    this.switchFlexbox(this.helper.expanded);
                };
                /*
                 * The DOM representation of the collapsed container.
                 * @returns {ng.IAugmentedJQuery} The collapsed DOM element which will replace the collapsed container.
                 */
                VerticalCollapsibleDelegate.prototype.collapsedNode = function (show) {
                    if (show) {
                        this.computeCollapsedStyles();
                    }
                    else {
                        this.computeExpandedStyles();
                    }
                };
                /*
                 * Add style to splitter when collapsed.
                 */
                VerticalCollapsibleDelegate.prototype.computeCollapsedStyles = function () {
                    // Switch to display collapsed node.
                    var content = this.helper.collapsed.children(":not(.ers-collapsed-layout)");
                    content.hide();
                    var collapsed = this.helper.collapsed.children(".ers-collapsed-layout");
                    this.prepareCollapseNode(collapsed);
                    this.buildSummary(collapsed, content);
                    // Hide splitters' buttons
                    this.element.find(".ers-prev-button-area").hide();
                    this.element.find(".ers-next-button-area").hide();
                    if (this.helper.isPrevCollapsed()) {
                        this.element.addClass(VerticalCollapsibleDelegate.UP_COLLAPSED_STYLE);
                    }
                    else {
                        this.element.addClass(VerticalCollapsibleDelegate.DOWN_COLLAPSED_STYLE);
                    }
                };
                /*
                 * Add style to splitter when expanded.
                 */
                VerticalCollapsibleDelegate.prototype.computeExpandedStyles = function () {
                    // Switch to display collapsed node.
                    var collapsed = this.helper.collapsed.children(".ers-collapsed-layout");
                    var content = this.helper.collapsed.children(":not(.ers-collapsed-layout)");
                    collapsed.hide();
                    content.show();
                    // Show buttons on collapse
                    this.element.find(".ers-prev-button-area").show();
                    this.element.find(".ers-next-button-area").show();
                    // remove collapsed class
                    if (this.helper.isCollapsedLayout(this.prev)) {
                        this.element.removeClass(VerticalCollapsibleDelegate.UP_COLLAPSED_STYLE);
                    }
                    else {
                        this.element.removeClass(VerticalCollapsibleDelegate.DOWN_COLLAPSED_STYLE);
                    }
                };
                /*
                 * Some initialisation on the collapsed node.
                 * @param collapsed the collapsed node
                 */
                VerticalCollapsibleDelegate.prototype.prepareCollapseNode = function (collapsed) {
                    var _this = this;
                    collapsed.show();
                    collapsed.addClass(VerticalCollapsibleDelegate.VERTICAL_COLLAPSE_STYLE);
                    collapsed.addClass("ers-fill");
                    // Add Trigger on 'click' event => expand collapsed node.
                    collapsed.on("click", function () {
                        if (!_this.helper.isCollapsed()) {
                            collapsed.off("click"); // no more action
                            return;
                        }
                        // Expand only if collapsed panel is not collapsed on another collapsed panel (case with 3 or more layout)
                        if (!_this.helper.isCollapsedLayout(_this.helper.expanded)) {
                            _this.helper.forceExpand(null, _this.helper.collapsed, _this.helper.expanded);
                            collapsed.off("click"); // no more action after expand
                        }
                    });
                };
                /*
                 * Build message to display when element is collapsed.
                 * @param collapsed the collapsed element
                 * @param content the element not collapsed
                 */
                VerticalCollapsibleDelegate.prototype.buildSummary = function (collapsed, content) {
                    var summary = $("<div>" + this.helper.getSummary() + "</div>");
                    // Remove old content
                    collapsed.children().remove();
                    // Inverse height/width for the rotation. obtain the appropriate size for the text before its rotation
                    summary.css("height", collapsed[0].offsetWidth + "px");
                    summary.css("width", collapsed[0].offsetHeight + "px");
                    // Rotate the text
                    summary.addClass(VerticalCollapsibleDelegate.VERTICAL_COLLAPSE_TEXT_STYLE);
                    collapsed.append(summary);
                };
                /** Horizontal splitter CSS definition */
                VerticalCollapsibleDelegate.VERTICAL_COLLAPSE_STYLE = "ers-collapsed-vertical";
                VerticalCollapsibleDelegate.UP_COLLAPSED_STYLE = "ers-collapsed-up";
                VerticalCollapsibleDelegate.DOWN_COLLAPSED_STYLE = "ers-collapsed-down";
                VerticalCollapsibleDelegate.VERTICAL_COLLAPSE_TEXT_STYLE = "ers-collapsed-text";
                return VerticalCollapsibleDelegate;
            })(layout.VerticalSplitterDelegate);
            layout.VerticalCollapsibleDelegate = VerticalCollapsibleDelegate;
        })(layout = components.layout || (components.layout = {}));
    })(components = ers.components || (ers.components = {}));
})(ers || (ers = {}));








var ers;
(function (ers) {
    var components;
    (function (components) {
        var layout;
        (function (layout) {
                        /*
             * DelegateFactory class
             * @class
             */
            var DelegateFactory = (function () {
                function DelegateFactory() {
                }
                /*
                 * @function Builds the splitter based on the selected options.
                 * @param element The DOM element (splitter)
                 * @param ctrl The splitter controller
                 * @param $timeout The Angular timer service
                 * @returns {any} The splitter object.
                 */
                DelegateFactory.buildDelegate = function (element, direction, resize, collapse, $timeout) {
                    var proxy = (resize === layout.Constants.PROXY_SPLITTER);
                    if (direction === layout.Constants.DIRECTION_VERTICAL) {
                        if (collapse !== layout.Constants.NONE) {
                            return new layout.VerticalCollapsibleDelegate(element, $timeout, proxy);
                        }
                        else {
                            return new layout.VerticalSplitterDelegate(element, $timeout, proxy);
                        }
                    }
                    else {
                        if (collapse !== layout.Constants.NONE) {
                            return new layout.HorizontalCollapsibleDelegate(element, $timeout, proxy);
                        }
                        else {
                            return new layout.HorizontalSplitterDelegate(element, $timeout, proxy);
                        }
                    }
                };
                return DelegateFactory;
            })();
            layout.DelegateFactory = DelegateFactory;
        })(layout = components.layout || (components.layout = {}));
    })(components = ers.components || (ers.components = {}));
})(ers || (ers = {}));








var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var ers;
(function (ers) {
    var components;
    (function (components) {
        var layout;
        (function (layout) {
                        var factory = ers.components.layout.DelegateFactory;
            var BaseComponent = ers.components.core.BaseComponent;
            /**
             * SplitterComponent class
             * @class
             */
            var SplitterComponent = (function (_super) {
                __extends(SplitterComponent, _super);
                /**
                 * @constructor
                 * @param $scope The isolate scope
                 * @param $element The directive DOM representation.
                 * @param $document The DOM document Angular service.
                 * @param $compile The directive compilation Angular service.
                 */
                function SplitterComponent($scope, $element, $attributes, $document, $timeout) {
                    _super.call(this, $scope, $element, $attributes, $timeout);
                    /** manage splitter behavior. */
                    this.delegate = null;
                    this.document = $document;
                    // Some init.
                    this.direction = this.direction || layout.Constants.DIRECTION_HORIZONTAL;
                    this.ersResize = this.ersResize || layout.Constants.NO_SPLITTER;
                    this.ersCollapse = this.ersCollapse || layout.Constants.NONE;
                    this.$element.addClass("ers-splitter");
                    // Build splitter delegate
                    this.buildSplitter();
                }
                /*
                 * Builds the delegate according to the splitter options.
                 */
                SplitterComponent.prototype.buildSplitter = function () {
                    this.delegate = factory.buildDelegate(this.$element, this.direction, this.ersResize, this.ersCollapse, this.$timeout);
                    // Draggable capabilities
                    this.addListeners();
                };
                /*
                 * Set the resize as draggable and captures the mouse events.
                 */
                SplitterComponent.prototype.addListeners = function () {
                    var _this = this;
                    var draggableArea = this.delegate.element.find(".ers-draggable-area");
                    draggableArea.on("mousedown", function (event) {
                        _this.onMouseDown(event);
                        // Prepare resize listeners
                        _this.document.on("mouseup", function (event) {
                            _this.onMouseUp(event);
                        });
                        _this.document.on("mousemove", function (event) {
                            _this.onMouseMove(event);
                        });
                    });
                };
                /*
                 * The action when the mouse button is down.
                 * @param event The mouse button down event.
                 */
                SplitterComponent.prototype.onMouseDown = function (event) {
                    // splitter is ready to move
                    this.delegate.onMouseDown(event);
                };
                /*
                 * The action when the mouse button is up.
                 * @param event The mouse button up event.
                 */
                SplitterComponent.prototype.onMouseUp = function (event) {
                    // Set style and stop drag action
                    this.delegate.onMouseUp(event);
                    this.document.off("mousemove");
                    this.document.off("mouseup");
                };
                /*
                 * The action when the mouse moves.
                 * @param event The mouse move event.
                 */
                SplitterComponent.prototype.onMouseMove = function (event) {
                    // Delegate call
                    this.delegate.onMouseMove(event);
                };
                /*
                 * The resize event callback.
                 */
                SplitterComponent.prototype.callTriggerResizeEvent = function () {
                    if (this._onResize) {
                        this._onResize();
                    }
                };
                /*
                 * Adds a listener trigger notification of when the splitter is moved.
                 * @param listener listener
                 */
                SplitterComponent.prototype.onResize = function (listener) {
                    this._onResize = listener;
                };
                /**
                 * External resources that can inject into the controller.
                 * @type {string[]}
                 */
                SplitterComponent.$inject = ["$scope", "$element", "$attrs", "$document", "$timeout"];
                return SplitterComponent;
            })(BaseComponent);
            layout.SplitterComponent = SplitterComponent;
        })(layout = components.layout || (components.layout = {}));
    })(components = ers.components || (ers.components = {}));
})(ers || (ers = {}));







var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var ers;
(function (ers) {
    var components;
    (function (components) {
        var layout;
        (function (layout) {
                        var EVENT = ers.components.core.event.EVENT;
            var BaseComponent = ers.components.core.BaseComponent;
            /**
             * LayoutComponent class
             * @class
             */
            var LayoutComponent = (function (_super) {
                __extends(LayoutComponent, _super);
                /**
                 * @constrcutor
                 * @param $scope The isolate scope
                 * @param $element The DOM element directive
                 * @param $compile Angular service for compiling utility
                 * @param containerEventService event resize manager
                 */
                function LayoutComponent($scope, $element, $attributes, $q, $compile, $timeout, containerEventService) {
                    var _this = this;
                    _super.call(this, $scope, $element, $attributes, $timeout);
                    /* Angular compilation service. */
                    this.$compile = null;
                    /* Layout DOM container (contains layout's element). */
                    this.divContainer = null;
                    /* Use as watch dog, to know when all splitters have been initialized. (cf checkLoaded()) */
                    this.waitingQueued = 0;
                    /* Store current layout's width and height.  */
                    this.layoutClientRect = {};
                    /* Flag to indicate that the layout is ready. */
                    this.loaded = false;
                    /** the gap between 2 direct children of the layout. Non effective if ersResize or ersCollapse. */
                    this.gap = 0;
                    this.direction = this.direction || layout.Constants.DIRECTION_HORIZONTAL;
                    this.ersResize = this.ersResize || layout.Constants.NO_SPLITTER;
                    this.ersCollapse = this.ersCollapse || layout.Constants.NONE;
                    // Init service
                    this.$promise = $q;
                    this.$compile = $compile;
                    this.divContainer = this.$element.children(".ers-layout-container");
                    this.containerEventService = containerEventService;
                    containerEventService.registerDispatcher(EVENT.RESIZE, $scope);
                    containerEventService.on(EVENT.RESIZE, $scope, function () { return _this.onResize(); });
                    $scope.$on("child-resided", function ($event, data) {
                        $event.stopPropagation();
                        _this.resizeTarget($event, data);
                    });
                    // Set DOM observers and event listeners
                    this.setObservers();
                }
                /**
                 * Resize closest parent container.
                 * @param $event resize event
                 * @param data new data size
                 */
                LayoutComponent.prototype.resizeTarget = function ($event, data) {
                    var parent = data.source.closest(".ers-layout-wrapper").first();
                    if (angular.isDefined(parent)) {
                        var value = data.value;
                        if ((data.property === "height" && this.direction === layout.Constants.DIRECTION_VERTICAL)
                            || data.property === "width" && this.direction === layout.Constants.DIRECTION_HORIZONTAL) {
                            if (angular.isDefined(value) && value.indexOf("px") > 0) {
                                layout.layoutUtils.switchClass(parent, "ers-flex-grow", "ers-flex-fixed");
                            }
                            else {
                                layout.layoutUtils.switchClass(parent, "ers-flex-fixed", "ers-flex-grow");
                            }
                        }
                        parent.css(data.property, data.value);
                    }
                };
                /*
                 * Set observers on layout attributes.
                 */
                LayoutComponent.prototype.setObservers = function () {
                    var _this = this;
                    // Observe if splitter change and then update layout.
                    // Only splitter's type can change
                    this.$attrs.$observe("ersResize", function (value) {
                        // Check if splitter is requested
                        if (value != null && angular.isDefined(value) && value !== layout.Constants.NO_SPLITTER) {
                            // check if requested splitter is available
                            var allowedValues = new RegExp(layout.Constants.PROXY_SPLITTER + "|" + layout.Constants.DIRECT_SPLITTER + "|", "ig");
                            var values = value.match(allowedValues) || [layout.Constants.DIRECTION_HORIZONTAL];
                            if (values.length > 0) {
                                _this.buildSplitters();
                            }
                        }
                        else {
                            _this.resetSplitters();
                            angular.forEach(_this.divContainer.children(".ers-layout-wrapper"), function (element) {
                                angular.element(element).removeClass("ers-flex-fixed").addClass("ers-flex-grow");
                            });
                        }
                    });
                };
                /**
                 * @function Angular link procedure. Add DOM elements depending on options set.
                 * @param $scope the isolate scope
                 * @param $element the directive 's DOM element
                 * @param $attributes the attribute of the directive
                 */
                LayoutComponent.prototype.link = function ($scope, $element, $attributes) {
                    var _this = this;
                    _super.prototype.link.call(this, $scope, $element, $attributes);
                    // Add main css class component
                    $element.addClass(LayoutComponent.CSS_NAME_CLASS);
                    // Build wrappers: Warning, wait until DOM completely loaded, to be sure to catch transcluded element or
                    // delayed DOM element (not yet in DOM). Here we need all children to be built to set properly the splitter(s)
                    this.$timeout(function () {
                        // initialize layout [width, height]
                        _this.setLayoutClientRect();
                        // Build elements
                        _this.buildWrappers();
                    }, 0);
                };
                /*
                 * Access the size of the global layout : width and height.
                 * @returns {CSize} the couple [width, height]
                 */
                LayoutComponent.prototype.getLayoutClientRect = function () {
                    this.setLayoutClientRect(); // live update
                    return this.layoutClientRect;
                };
                /*
                 * Compute the new width and height of the layout based on DOM information.
                 */
                LayoutComponent.prototype.setLayoutClientRect = function () {
                    var clientRect = this.divContainer[0].getBoundingClientRect();
                    this.layoutClientRect = {
                        width: this.$element[0].offsetWidth,
                        height: this.$element[0].offsetHeight,
                        top: clientRect.top,
                        left: clientRect.left,
                        wAvailable: this.$element[0].offsetWidth,
                        hAvailable: this.$element[0].offsetHeight
                    };
                };
                /*
                 * Wait until all layout's splitters are completely initialized and then compute sizing
                 * for each layout's elements.
                 */
                LayoutComponent.prototype.notifyLoaded = function () {
                    var _this = this;
                    var splitterPromise = this.checkLoaded();
                    splitterPromise.then(function () {
                        // Splitters ready then compute constraints.
                        _this.checkLayoutContent();
                    });
                };
                /*
                 * Resolve the promise if splitters are completely initialized (watch dog).
                 */
                LayoutComponent.prototype.checkLoaded = function () {
                    var deferred = (this.$promise ? this.$promise.defer() : null);
                    this.waitingQueued--;
                    if (this.waitingQueued === 0 && deferred != null) {
                        this.loaded = true;
                        deferred.resolve();
                    }
                    return deferred.promise;
                };
                /*
                 * Action to perform when IResizableController is starting to process.
                 */
                LayoutComponent.prototype.beginProcessing = function () {
                    this.$element.addClass("layout-processing");
                };
                /*
                 * Action to perform when IResizableController is ending to process.
                 */
                LayoutComponent.prototype.endProcessing = function () {
                    if (this.$element.hasClass("layout-processing")) {
                        this.$element.removeClass("layout-processing");
                    }
                };
                /*
                 * Compute layout content element depending on available space (width and height).
                 */
                LayoutComponent.prototype.checkLayoutContent = function () {
                    if (this.loaded) {
                        // Compute displayed content depending on layout direction
                        var style = (this.direction === layout.Constants.DIRECTION_HORIZONTAL ? layout.wStyle : layout.hStyle);
                        this.checkContent(style);
                        // Adapt percentage to the appropriate value depending on real layout size
                        this.adaptWrapperPercentage(".ers-layout-wrapper.ers-flex-grow");
                    }
                };
                /*
                 * Set layout content according to available free space in layout
                 * Warning:
                 * @param element layout's content
                 * @param style horizontal / vertical set of properties
                 * @param offset
                 */
                LayoutComponent.prototype.checkContent = function (style) {
                    var _this = this;
                    // Be sure available size (proeprties) is up to date
                    this.setLayoutClientRect();
                    var isPreviousContentFlex = false;
                    // Get all layout contents (splitter, wrapper)
                    _.forEach(this.divContainer.children(), function (el) {
                        var element = $(el);
                        var sizeElement = element[0][style.offsetProperty];
                        var max = Math.min(_this.layoutClientRect[style.maxAvailable], sizeElement);
                        if (_this.layoutClientRect[style.maxAvailable] > 0) {
                            _this.layoutClientRect[style.maxAvailable] -= max;
                            element.show();
                            // Content is not a splitter and its size is fixed
                            if (element.hasClass("ers-flex-fixed") && !element.hasClass("ers-splitter")) {
                                // Size element should be greater than the available => set overflow hidden
                                if (max < sizeElement) {
                                    element.css("overflow", "hidden");
                                }
                                else {
                                    element.css("overflow", "");
                                }
                            }
                            else {
                                isPreviousContentFlex = true; // content is flex, let know the future contents that they can display
                            }
                        }
                        else {
                            // Here, check if previous content and force current content to visible if previous is flex.
                            if (isPreviousContentFlex) {
                                element.show();
                            }
                            else {
                                element.hide();
                            }
                        }
                    });
                };
                /*
                 * Return the direction that can impact the property.
                 * @param property given property
                 * @returns {string} apropriate direction
                 */
                LayoutComponent.prototype.propertyDirection = function (property) {
                    if (property === "minWidth" || property === "width") {
                        return layout.Constants.DIRECTION_HORIZONTAL;
                    }
                    if (property === "minHeight" || property === "height") {
                        return layout.Constants.DIRECTION_VERTICAL;
                    }
                    return "";
                };
                /*
                 * Apply on each concerned element the appropriate percentage depending on its real size inside the layout.
                 * @param selector expression to retrive DOM element(s)
                 */
                LayoutComponent.prototype.adaptWrapperPercentage = function (selector) {
                    var _this = this;
                    // Each layout's element is sized with its corresponding percentage
                    // 1) compute percentage for each layout's element
                    var elements = _.map(this.divContainer.children(selector), function (element) {
                        if (_this.direction === layout.Constants.DIRECTION_VERTICAL) {
                            return {
                                "element": $(element),
                                "property": "height",
                                "value": (element.offsetHeight / _this.getLayoutClientRect().height) * 100
                            };
                        }
                        else {
                            return {
                                "element": $(element),
                                "property": "width",
                                "value": (element.offsetWidth / _this.getLayoutClientRect().width) * 100
                            };
                        }
                    });
                    // 2) Update DOM.
                    _.forEach(elements, function (data) {
                        data.element.css(data.property, data.value + "%");
                    });
                };
                /*
                 * Splitter was moved : compute size (apply % if necessary) and notify impacted layouts.
                 */
                LayoutComponent.prototype.splitterMoved = function () {
                    // Layout resized, change wrapper to flex box except collapsed wrapper.
                    this.adaptWrapperPercentage(".ers-layout-wrapper:not(.state-collapsed)");
                    // Propagate resize event to registered layout.
                    this.containerEventService.dispatch(EVENT.RESIZE, this.$scope);
                };
                /*
                 * Callback executed when resize event is triggered
                 */
                LayoutComponent.prototype.onResize = function () {
                    if (this.loaded) {
                        // Change state to process
                        this.beginProcessing();
                        // Update layout size (global width, height)
                        this.setLayoutClientRect();
                        // Compute displayed contents
                        this.checkLayoutContent();
                        // Change state to finish
                        this.endProcessing();
                    }
                };
                /*
                 * Add new DOM element which wraps each layout children element.
                 * Note: At this step splitters aren't yet built.
                 */
                LayoutComponent.prototype.buildWrappers = function () {
                    // Set layout direction
                    this.divContainer.addClass(this.direction);
                    // Filling behavior
                    this.divContainer.addClass("ers-fill");
                    // Wrap each child
                    var start = angular.element(this.divContainer.children(":not(ers-splitter)").first());
                    this.wrapChildrenRec(start);
                    // Gap...
                    if (this.gap > 0 && this.ersResize === layout.Constants.NO_SPLITTER) {
                        this.buildGap();
                    }
                };
                LayoutComponent.prototype.buildGap = function () {
                    var gapDiv = $("<div class='ers-flex-fixed'></div>");
                    gapDiv.css(this.direction === layout.Constants.DIRECTION_HORIZONTAL
                        ? "width" : "height", this.gap + "px");
                    gapDiv.css(this.direction === layout.Constants.DIRECTION_HORIZONTAL
                        ? "height" : "width", "100%");
                    var siblings = angular.element(gapDiv).insertAfter(this.divContainer.children());
                    siblings.last().remove(); // last inserted is useless
                };
                /*
                 * Loop on layout children recursively.
                 * Note: For tanscluded element, a dedicated treatment is done which append transcluded content to the
                 * main layout container and then loop inside.
                 * @param element current layout children
                 */
                LayoutComponent.prototype.wrapChildrenRec = function (element) {
                    // There is element to parse
                    if (element.length > 0) {
                        // Element is a transclude
                        if (element[0].tagName.toLowerCase() === LayoutComponent.TRANSCLUDE_DIR) {
                            // Extract all children and append them to "previous" element
                            $(element[0].children).insertAfter(element);
                            element.remove(); // remove transclude element after moving its content just after it
                            this.wrapChildrenRec(this.divContainer.children().first());
                        }
                        else {
                            // Prepare next element before treating the current one.
                            var nextElement = element.next(":not(ers-splitter)");
                            // Apply treatment on current element (be careful element will be wrapped)
                            this.parseElement(element);
                            // Go to the next sibling element
                            if (nextElement.length > 0) {
                                this.wrapChildrenRec(nextElement);
                            }
                        }
                    }
                };
                /*
                 * Build the wrapper and set properties.
                 * @param el Layout element
                 */
                LayoutComponent.prototype.parseElement = function (element) {
                    // Set container for the current element
                    if (layout.layoutUtils.isLayoutElement(element[0])) {
                        element.addClass("ers-layout-wrapper"); // set element as wrapper container
                        this.setWrapperStyle(element, element, layout.wStyle); // width
                        this.setWrapperStyle(element, element, layout.hStyle); // height
                        element.css("position", "relative"); // Important for layout container change position absolute to relative
                    }
                    else {
                        var wrapper = $("<div class=\"ers-layout-wrapper\"></div>");
                        this.setWrapperStyle(wrapper, element, layout.wStyle); // width
                        this.setWrapperStyle(wrapper, element, layout.hStyle); // height
                        element.css("position", "absolute");
                        element.wrap(wrapper); // wrap element
                    }
                };
                /*
                 * Apply wrapper style (Horizontal/vertical)
                 * @param wrapper future container
                 * @param element wrapper content
                 * @param style horizontal/vertical properties
                 */
                LayoutComponent.prototype.setWrapperStyle = function (wrapper, element, style) {
                    // Set min property on wrapper if  exists
                    wrapper.css(style.minProperty, layout.layoutUtils.getRawStyle(element[0], style.minProperty));
                    var isDirection = this.propertyDirection(style.property) === this.direction;
                    // Check original style size and apply flex box constraints (element shouldn't be a layout).
                    if (!layout.layoutUtils.isPercentBasis(element[0], style.property) ||
                        (layout.layoutUtils.isPercentBasis(element[0], style.property) &&
                            layout.layoutUtils.rawStyle2Number(element[0], style.property) !== 100)) {
                        // Check element and set size on wrapper (width/height depending on layout direction)
                        wrapper.css(style.property, layout.layoutUtils.getRawStyle(element[0], style.property));
                        if (isDirection) {
                            wrapper.addClass("ers-flex-fixed");
                        } // fixed size
                    }
                    else {
                        if (isDirection) {
                            wrapper.addClass("ers-flex-grow");
                        } // stretch size element
                    }
                    // Check if element is a layout else fit to content.
                    if (!layout.layoutUtils.isLayoutElement(element[0])) {
                        element.css(style.property, "100%");
                    }
                };
                /*
                 * Update DOM and add/compile ers-splitter directive
                 * This method is called only if splitter exist and is "proxy" or "direct".
                 */
                LayoutComponent.prototype.buildSplitters = function () {
                    var _this = this;
                    // Clean previous ers-splitter content (if exists)
                    this.resetSplitters();
                    // Build new splitters
                    this.$timeout(function () {
                        // Build the splitter directive and add it between each children.
                        var directive = _this.buildSplitterDirective();
                        var siblings = angular.element(directive).insertAfter(_this.divContainer.children());
                        siblings.last().remove(); // last inserted is useless
                        // Compile each splitter directive
                        var splitters = _this.divContainer.children("ers-splitter");
                        _this.waitingQueued = splitters.length; // number of splitter attempted to be added into layout
                        angular.forEach(splitters, function (element) {
                            _this.$compile(angular.element(element))(_this.$scope);
                        });
                    }, 0);
                };
                /*
                 * Reset layout's splitter(s). remove DOM element and reset flag and properties.
                 */
                LayoutComponent.prototype.resetSplitters = function () {
                    // Clean ers-splitter content (if exists)
                    this.divContainer.children("ers-splitter").remove();
                };
                /*
                 * Build the splitter directive.
                 * @returns {string} the well formed `ers-splitter` directive
                 */
                LayoutComponent.prototype.buildSplitterDirective = function () {
                    var directive = "<ers-splitter ";
                    // Set options
                    directive += "direction=\"" + this.direction + "\" ";
                    directive += "ers-resize=\"" + this.ersResize + "\" ";
                    directive += "ers-collapse=\"" + this.ersCollapse + "\" ";
                    directive += " />";
                    return directive;
                };
                /* keyword for transclude angular directive. */
                LayoutComponent.TRANSCLUDE_DIR = "ng-transclude";
                /* Main layout CSS name. */
                LayoutComponent.CSS_NAME_CLASS = "ers-layout";
                /**
                 * List of resources to inject into the controller by Angular
                 * @type {string[]}
                 */
                LayoutComponent.$inject = ["$scope", "$element", "$attrs", "$q", "$compile", "$timeout", "containerEventService"];
                return LayoutComponent;
            })(BaseComponent);
            layout.LayoutComponent = LayoutComponent;
        })(layout = components.layout || (components.layout = {}));
    })(components = ers.components || (ers.components = {}));
})(ers || (ers = {}));


var ers;
(function (ers) {
    var components;
    (function (components) {
        var layout;
        (function (layout_1) {
                        /**
             * @ngdoc directive
             * @name ersLayout
             *
             *
             * @restrict E
             * @module ers.components.layout
             * @scope
             * @transclude
             *
             * @description
             *
             * Use the `ers-layout` component to organize the layout of your HTML content. Create your
             * content horizontally or vertically, or nest this component for complex designs.
             *
             * ### Usage
             *
             * - `ers-layout`&#151;The basic container providing the HTML container and display direction for the container.
             * - `ers-splitter`&#151;Provides the visible splitter for `ers-layout`.
             * - `ers-resize`&#151;Provides a splitter resize option
             * allowing you to specify whether the HTML container resize is dynamic (as you drag the splitter with the mouse) or
             * delayed until you release the mouse.
             * - `ers-collapse`&#151;Provides directional arrows to collapse, or expand the HTML container.
             * - `ers-layout-summary`&#151;Allows you to create a display message for the collapsed component.
             *
             * ### Examples
             *
             * #### Basic usage
             * You can `ers-resize` attribute to resize the sections.
             *
             * <code-editor identifier="example1" data-title="Layout" html-content-url="demos/ersLayout/basicUsage/index.html"
             * js-content-url="demos/ersLayout/basicUsage/script.js" css-content-url="demos/ersLayout/basicUsage/styles.css"
             * content-mode="html"></code-editor>
             *
             * #### Other usage
             * You can also use `ers-collapse` and `ers-layout-summary` attributes.
             *
             * <code-editor identifier="example1" data-title="Layout" html-content-url="demos/ersLayout/otherUsage/index.html"
             * js-content-url="demos/ersLayout/otherUsage/script.js" css-content-url="demos/ersLayout/otherUsage/styles.css"
             * content-mode="html"></code-editor>
             *
             * ### Design Guidelines
             *
             * Use the `ers-layout` to arrange the display of your HTML page. The collapsible components can be stylized with CSS.
             *
             * #### Best Practices
             *
             * Resizing a section of the layout is done immediately, as the mouse moves. Depending on the size of the section,
             * extensive CPU use
             * is not unusual. To avoid excessive CPU use and visual slowdown, consider using the `ers-resize="proxy"`option,
             * which delays the resize until the mouse button is released.
             *
             * ### Accessibility Guidelines
             *
             * No accessibility guidelines
             *
             *
             * @param {string} [direction="horizontal"] {@?}
             *
             * (ers-layout) Sets the direction of the `ers-layout` content display.
             * - Vertical&#151;Displays the content as a row.
             * - Horizontal (default)&#151;Displays the content as a column.
             *
             * @param {string} [ers-collapse="onBothSide"]
             * (ers-collapse) Sets the direction in which the HTML container collapses.
             * - onBothSide&#151;Ability to collapse or expand a portion of an HTML container. The default setting.
             * - onTop&#151;Collapse or expand an HTML container to or from the Top.
             * - onBottom&#151;Collapse or expand an HTML container to or from the Bottom.
             * - onLeft&#151;Collapse or expand an HTML container to or from the left.
             * - onRight&#151;Collapse or expand an HTML container to or from the right.
             *
             */
            var layoutDirective = function () {
                return {
                    restrict: "E",
                    templateUrl: "layout/template/layout-template.html",
                    require: ["ersLayout", "?^^ersLayout"],
                    transclude: true,
                    scope: {
                        gap: "@?",
                        direction: "@?",
                        ersResize: "@?"
                    },
                    priority: 100,
                    bindToController: true,
                    controller: layout_1.LayoutComponent,
                    controllerAs: "layoutController",
                    link: function ($scope, $element, $attributes, controllers) {
                        var layout = controllers[0];
                        if (layout) {
                            layout.link($scope, $element, $attributes);
                        }
                    }
                };
            };
            // Define the module
            angular.module("ers.components.layout").directive("ersLayout", layoutDirective);
        })(layout = components.layout || (components.layout = {}));
    })(components = ers.components || (ers.components = {}));
})(ers || (ers = {}));


var ers;
(function (ers) {
    var components;
    (function (components) {
        var layout;
        (function (layout_1) {
                        /**
             * @-ngdoc directive
             *
             * @name ersSplitter
             * @module ers.components.layout
             * @restrict E
             *
             * @description
             *
             * `ers-splitter` is not a standalone component. It is always used between &lt;ers-layout&gt;&lt;/ers-layout&gt; tags.
             * It is a visible divider between two HTML containers or sections inside of the
             * [ers-layout](#components/ersLayout/documentation) tags.
             *
             *
             * Clicking the divider bar allows you to resize the HTML container. `ers-splitter` is
             * often used with [ers-collapse](#components/ersCollapse/documentation), allowing you to also collapse
             * a specific section using the `ers-collapse` directional arrows.
             *
             *
             *
             * For more information, see [ers-layout examples](#components/ersLayout/examples).
             *
             *
             *
             * <div style="width:400px; height:300px">
             *  <ers-layout direction="horizontal" style="width: 100$; height:100%; background: #adc8e6">
             *    <div style="height:50%; width: 50%">
             *     Horizontal Content 1</div>
             *    <ers-splitter></ers-splitter>
             *    <div style="height:50%; width: 50%" style="background: #c5e3ed">
             *     Horizontal Content 2</div>
             *    <ers-layout direction="vertical" style="background: #c5e3ed">
             *      <div style="height:50%; width:50%" ers-layout-summary="Vertical Content 1 collapsed message">
             *      Vertical Content 1</div>
             *      <ers-splitter></ers-splitter>
             *        <div style="height:50%; width:50%; background: #d6ebf2" >
             *          Vertical Content 2</div>
             *    </ers-layout>
             *   </ers-layout>
             * </div>
             *
             * <br>
             *
             * For more information, see  [Examples](#/components/ersLayout/examples).
             *
             * #### Visual Design Guidelines
             *
             * `ers-splitter` has its own style, or can be themed using standard CSS.
             *
             * #### Example
             *
             * The following example displays the code from the description display.
             *
             * ```xml
             * <div style="width:400px; height:300px">
             *  <ers-layout direction="horizontal" style="width: 100$; height:100%; background: #adc8e6">
             *    <div style="height:50%; width: 50%">
             *     Horizontal Content 1</div>
             *    <ers-splitter></ers-splitter>
             *    <div style="height:50%; width: 50%" style="background: #d5e3ed">
             *     Horizontal Content 2</div>
             *    <ers-layout direction="vertical" style="background: #c5e3ed">
             *      <div style="height:50%; width:50%">
             *      Vertical Content 1</div>
             *      <ers-splitter></ers-splitter>
             *        <div style="height:50%; width:50%; background: #d6ebf2">
             *          Vertical Content 2</div>
             *    </ers-layout>
             *   </ers-layout>
             * </div>
             * ```
             *
             * @param {string} [direction]
             * Sets the direction of the `ers-splitter`.
             *
             * - Vertical&#151;Displays the splitter as a row.
             *
             * - Horizontal (default)&#151;Displays the content as a column.
             *
             *
             * <!--@param {string} [ers-resize] Displays a splitter between sections of the component.
             *
             * - direct&#151;The splitter resizes the section immediately. The default setting is direct.
             *
             * - proxy&#151;The splitter resize is delayed until the mouse button is released.
             *
             * - none&#151;No splitter.
             *
             *
             *
             * <!--@param {string} [ers-collapse] Allows the splitter to collapse or expand layout content.
             *
             * - onBothSide&#151;Collapses or expands a layout section in the direction of the selected arrow. This is the
             * default.
             *
             * - onTop&#151;Collapse or expand vertical content to or from the top.
             *
             * - onBottom&#151;Collapse or expand vertical content to or from the bottom.
             *
             * - onLeft&#151;Collapse or expand horizontal content to or from the left.
             *
             * - onRight&#151;Collapse or expand horizontal content to ro from the right.
             * //-->
             *
             */
            var ersSplitterDirective = function () {
                return {
                    restrict: "E",
                    require: ["ersSplitter", "?^ersLayout"],
                    templateUrl: "layout/template/splitter-template.html",
                    scope: {
                        direction: "@?", ersResize: "@?", ersCollapse: "@?"
                    },
                    priority: 100,
                    bindToController: true,
                    controller: layout_1.SplitterComponent,
                    controllerAs: "splitterController",
                    link: function ($scope, $element, $attributes, controllers) {
                        if (controllers != null && controllers.length > 1) {
                            var splitterComp = controllers[0];
                            var layout = controllers[1];
                            if (splitterComp.delegate != null) {
                                splitterComp.delegate.setParentContainer(layout);
                                splitterComp.onResize(function () {
                                    layout.splitterMoved();
                                });
                            }
                        }
                    }
                };
            };
            // Add Splitter directive
            angular.module("ers.components.layout").directive("ersSplitter", ersSplitterDirective);
        })(layout = components.layout || (components.layout = {}));
    })(components = ers.components || (ers.components = {}));
})(ers || (ers = {}));
var ers;
(function (ers) {
    var components;
    (function (components) {
        var login;
        (function (login) {
                    })(login = components.login || (components.login = {}));
    })(components = ers.components || (ers.components = {}));
})(ers || (ers = {}));

/**
 * The [[LoginDirective]] data scope.
 */
var ers;
(function (ers) {
    var components;
    (function (components) {
        var login;
        (function (login) {
                    })(login = components.login || (components.login = {}));
    })(components = ers.components || (ers.components = {}));
})(ers || (ers = {}));

// only declare angular module
angular.module("ers.components.modal", ["ers.components.core", "ui.bootstrap"]);

// only declare angular module
angular.module("ers.components.passwordManagement", ["ers.components.modal",
    "ers.components.textbox",
    "ers.components.button"]);

// only declare angular module
angular.module("ers.components.login", ["ers.components.modal",
    "ers.components.passwordManagement",
    "ers.components.textbox",
    "ers.components.button",
    "ers.components.combobox"]);




/// author BERTHETO
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
/**
 *
 * ERS Angular Controller: ModalController.
 */
var ers;
(function (ers) {
    var components;
    (function (components) {
        var modal;
        (function (modal) {
                        var BaseController = ers.components.core.BaseController;
            /**
             *
             *  This controller associated to the modal-template and can be used inside of
             *  another controller. It is the base controller used by the modal
             *  service, not the modal directive. A specific controller is not required to open the modal
             *  and display the template. This controller allows you to pass and return values, as described in
             *  modalVariables, and manages the standard before and on-close events.
             *
             *  More specific operations on resolved variables, or specific before and on-close actions, can be inherited
             *  from this controller.
             *
             *
             *
             *  The following are the methods available:
             *
             * ### Available Methods
             *
             * [compareNewPasswords](#comparenewpasswords), [callChangePasswordCallback](#callchangepasswordcallback),
             * [onCloseModal](#onclosemodal), [formIsValid](#formisvalid) , [disableAllButtons](#disableAllButtons)
             */
            var ModalController = (function (_super) {
                __extends(ModalController, _super);
                /**
                 * @constructor
                 * @param $scope The scope.
                 * @param $modal The ui.bootstrap Modal Service.
                 * @param $uibModalInstance The ui.bootstrap modal instance.
                 * @param options The modal options used to configure the modal.
                 * @param modalVariables The variables(properties) to be used by the modal content.
                 * These properties can be retrieved in both the main and functional modal templates by using{{ctrl.propertyName}},
                 * or by using {{ctrl.modalVariables.propertyName}}
                 */
                function ModalController($scope, $uibModalInstance, options, modalVariables) {
                    _super.call(this, $scope);
                    /**
                     * True if the cross button at the top right, is visible.
                     */
                    this.dismissCrossButtonVisible = true;
                    if ($uibModalInstance) {
                        this.uibModalInstance = $uibModalInstance;
                    }
                    // Iterate on modalVariables to create all the properties from modalVariables in our controller
                    // so that the properties can be retrieved in both the main and functional modal templates.
                    // Caution: To avoid property conflicts, we do not set the property if it already exists in ModalController.
                    // property if it already exists in the ModalController to avoid properties conflicts. note 2: these properties
                    // could be called in the templates by using{{ctrl.propertyName}}
                    // for example, but, also by using {{ctrl.modalVariables.propertyName}}
                    if (modalVariables) {
                        this._modalVariables = modalVariables;
                        for (var p in this._modalVariables) {
                            if (this._modalVariables.hasOwnProperty(p) && !this.hasOwnProperty(p)) {
                                this[p] = this._modalVariables[p];
                            }
                        }
                    }
                    // options initialization.
                    if (options) {
                        this.title = options.title || "Title";
                        this.icon = options.icon;
                        this.instanceTemplate = options.instanceTemplate || "";
                        this.buttons = options.buttons;
                        this.nullFieldsCheckedForFormValidity = options.nullFieldsCheckedForFormValidity;
                        this.dismissCrossButtonVisible = options.dismissCrossButtonVisible;
                        this.message = options.message;
                        this.onModalClose = options.onModalClose;
                        this.onModalDismiss = options.onModalDismiss;
                        this.onBeforeModalClose = options.onBeforeModalClose;
                        this.onBeforeModalDismiss = options.onBeforeModalDismiss;
                        this._resizable = options.resizable;
                        this._draggable = options.draggable;
                        this._modal = options.modal;
                        this.id = options.id;
                        this.focusPath = options.focusPath;
                    }
                }
                Object.defineProperty(ModalController.prototype, "draggable", {
                    /**
                     * @return True if the dialog is draggable.
                     */
                    get: function () {
                        return this._draggable === true || this._draggable === "true";
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ModalController.prototype, "resizable", {
                    /**
                     * @return True if the dialog is resizable.
                     */
                    get: function () {
                        return this._resizable === true || this._resizable === "true";
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ModalController.prototype, "modal", {
                    /**
                     * @return True if the dialog is modal, false if the dialog is modeless.
                     */
                    get: function () {
                        return this._modal === true || this._modal === "true";
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * Manage the the button keypress events.
                 * @param event The key event.
                 */
                ModalController.prototype.buttonEnter = function (event) {
                    $("#" + event.currentTarget["id"]).trigger("click");
                };
                /**
                 * Get the 'click' button value.
                 * @param $event The click event.
                 * @return {Object} The button value.
                 */
                ModalController.prototype.getButtonValue = function ($event) {
                    var buttonValue;
                    if ($event && this.buttons != null) {
                        for (var i = 0; i < this.buttons.length; i++) {
                            var button = this.buttons[i];
                            if (button.id === $event.currentTarget["id"]) {
                                buttonValue = button.value;
                            }
                        }
                    }
                    return buttonValue;
                };
                /**
                 *  Compute the return values for the close or dismiss.
                 * @return {Object} the return values object.
                 */
                ModalController.prototype.getReturnValues = function () {
                    var returnValues = null;
                    if (this._modalVariables) {
                        for (var p in this._modalVariables) {
                            if (this._modalVariables.hasOwnProperty(p) && this.hasOwnProperty(p)) {
                                if (returnValues === null) {
                                    returnValues = {};
                                }
                                returnValues[p] = this[p];
                            }
                        }
                    }
                    return returnValues;
                };
                /**
                 *  Call the before close functions and/or close the modal instance.
                 *  The onModalClose is executed at the close of the promise (see the service).
                 *  @param $event the click event.
                 */
                ModalController.prototype.onCloseModal = function ($event) {
                    var returnValues = this.getReturnValues();
                    if (returnValues === null) {
                        returnValues = this.getButtonValue($event);
                    }
                    if (this.onBeforeModalClose) {
                        this.onBeforeModalClose(returnValues);
                    }
                    else {
                        this.closeModal(returnValues);
                    }
                };
                ModalController.prototype.onDismissModal = function ($event) {
                    var buttonValue = this.getButtonValue($event);
                    if (this.onBeforeModalDismiss) {
                        this.onBeforeModalDismiss(buttonValue);
                    }
                    else {
                        this.dismissModal(buttonValue);
                    }
                };
                /**
                 * Close the modal instance and trigger the result promise (closed).
                 * @param closeModalResult result used by the result promise.
                 */
                ModalController.prototype.closeModal = function (closeModalResult) {
                    if (this.uibModalInstance) {
                        this.uibModalInstance.close(closeModalResult);
                        this.destroy();
                    }
                };
                /**
                 * Destroy all the injected properties and the modal instance.
                 */
                ModalController.prototype.destroy = function () {
                    for (var p in this._modalVariables) {
                        if (this.hasOwnProperty(p) === true) {
                            delete this[p];
                        }
                    }
                    delete this["_modalVariables"];
                    this.uibModalInstance = void 0;
                };
                /**
                 *
                 * Dismiss the modal instance and trigger the result promise (rejected).
                 * @param pResult result used by the result promise.
                 */
                ModalController.prototype.dismissModal = function (pResult) {
                    this.uibModalInstance.dismiss(pResult);
                    this.uibModalInstance = void 0;
                };
                /**
                 * Form validity test.
                 * @return {boolean} true if the modal content form (in the urlTemplate modal type, not the message modal type)
                 * is valid.
                 */
                ModalController.prototype.formIsValid = function () {
                    if (this.nullFieldsCheckedForFormValidity) {
                        for (var i = 0; i < this.nullFieldsCheckedForFormValidity.length; i++) {
                            var propName = this.nullFieldsCheckedForFormValidity[i];
                            if (this.hasOwnProperty(propName)
                                && (!angular.isDefined(this[propName])
                                    || this[propName] === null)) {
                                return false;
                            }
                        }
                    }
                    return this.$scope["modalForm"] ? !this.$scope["modalForm"].$invalid : true;
                };
                /**
                 * Form validity test.
                 * @return {boolean} true if the modal content form (in the urlTemplate modal type, not the message modal type)
                 * is valid.
                 */
                ModalController.prototype.disableAllButtons = function () {
                    return false;
                };
                Object.defineProperty(ModalController.prototype, "modalVariables", {
                    /**
                     * modalVariables getter.
                     * @return {Object} the functionnal variables resolved and injected from the caller.
                     */
                    get: function () {
                        return this._modalVariables;
                    },
                    enumerable: true,
                    configurable: true
                });
                ModalController.$inject = ["$scope", "$uibModalInstance", "options", "modalVariables"];
                return ModalController;
            })(BaseController);
            modal.ModalController = ModalController;
            angular.module("ers.components.modal").controller("ModalController", ["$scope",
                "$uibModalInstance",
                "options",
                "modalVariables",
                ModalController]);
        })(modal = components.modal || (components.modal = {}));
    })(components = ers.components || (ers.components = {}));
})(ers || (ers = {}));/*
 * Created by bertheto on 20/03/2015.
 *
 */




/**
 * IModalScope Interface representing the scope for the modal component.
 * Created by bertheto on 17/12/2014.
 */
//
// IError Interface
// Used to transmit error results.* Created by BerthetO on 15/12/2014
//

/**
 * ILoginError Interface
 * Used to transmit error results after login.* Created by BerthetO on 15/12/2014.
 */

/**
 * IChangePasswordError Interface
 * Used to transmit error results after change password submit.
 * Created by BerthetO on 15/12/2014.
 */

/**
 * ILoginInfo Interface
 * Used to transmit user informations during login.
 * Created by BerthetO on 10/12/2014
 */
/**
 * IChangePasswordResolvedVar Interface
 * Used to transmit resolved variables between modal controller and change password controller.
 * Created by BerthetO on 15/12/2014.
 */

// currently it is not enough to define a dependencies on angular modules as ChanegPassword depends on modal component.
// so we have to set a reference to the modal directives.






var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var ers;
(function (ers) {
    var components;
    (function (components) {
        var passwordManagement;
        (function (passwordManagement) {
            var ModalController = ers.components.modal.ModalController;
            /**
             * The controller associated to the password-management-template as a modal.
             *
             * When the password-management modal is open, the opener could pass a username and database information to the
             * modal using the modalVariables injected by the ModalService.
             *
             * By default, on the update click, the controller verifies that the new passwords are equal. If they are equal,
             * the controller call the [onChangePassword](#changepasswordfunction) callback function. On error,
             * the [changePasswordError](#changepassworderror) is updated, for no error,
             * the modal is closed.
             *
             *  passwordManagement supports the following methods:
             *
             * ### Available Methods
             *
             * * [compareNewPasswords](#comparenewpasswords), [callChangePasswordCallback](#callchangepasswordcallback),
             * [onCloseModal](#onclosemodal), [formIsValid](#formisvalid) , [disableAllButtons](#disableAllButtons)
             */
            var ChangePasswordModalController = (function (_super) {
                __extends(ChangePasswordModalController, _super);
                /**
                 * constructor
                 * @param $scope the scope.
                 * @param $modalInstance the modal instance.
                 * @param options the injected ersModalService options for the change password modal
                 * @param modalVariables the injected ersModalService specific variables for the change password modal.
                 */
                function ChangePasswordModalController($scope, $modalInstance, options, modalVariables) {
                    _super.call(this, $scope, $modalInstance, options, modalVariables);
                    /**
                     * True if the screen is 'computing' (calling the changePassword callback).
                     * @type {boolean}
                     */
                    this.computing = false;
                    // Resolved variables, from the modal service, are parsed.
                    if (modalVariables) {
                        this.username = modalVariables.username;
                        this.database = modalVariables.database;
                        this.onChangePassword = modalVariables.changePassword;
                    }
                    this.usernameInitialized = this.username ? true : false;
                }
                Object.defineProperty(ChangePasswordModalController.prototype, "changePasswordError", {
                    /**
                     *
                     * @param pChangePasswordError
                     */
                    get: function () {
                        return this._changePasswordError;
                    },
                    /**
                     *
                     * @param pChangePasswordError
                     */
                    set: function (pChangePasswordError) {
                        this._changePasswordError = pChangePasswordError;
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * verify the new and confirmation password equality.
                 * @return {boolean} true if the 2 passwords match.
                 */
                ChangePasswordModalController.prototype.compareNewPasswords = function () {
                    if (this.newPassword !== this.confirmNewPassword) {
                        this.changePasswordError = {
                            credentialsError: false, newPasswordError: true, message: "The passwords you entered did not match."
                        };
                        return false;
                    }
                    return true;
                };
                /**
                 * Call the change password callback and manage the error display.
                 */
                ChangePasswordModalController.prototype.callChangePasswordCallback = function () {
                    var _this = this;
                    var credentials = {
                        username: this.username, newPassword: this.newPassword, password: this.oldPassword, database: this.database
                    };
                    this.computing = true;
                    var promise = this.onChangePassword(credentials);
                    promise.then(function () {
                        _this.computing = false;
                        _super.prototype.closeModal.call(_this, credentials);
                    }, function (error) {
                        _this.changePasswordError = error;
                        _this.computing = false;
                    });
                };
                /**
                 * call the before/on close functions and close the modal instance.
                 */
                ChangePasswordModalController.prototype.onCloseModal = function () {
                    if (this.compareNewPasswords()) {
                        this.callChangePasswordCallback();
                    }
                };
                /**
                 * Form validity test.
                 * @return {boolean} true if the chang password form is valid.
                 */
                ChangePasswordModalController.prototype.formIsValid = function () {
                    return this.username !== undefined && this.newPassword !== undefined && this.oldPassword !== undefined &&
                        this.confirmNewPassword !== undefined && !this.computing;
                };
                /**
                 * Form validity test.
                 * @return {boolean} true if the modal content form (in the urlTemplate modal type, not the message modal type)
                 * is valid.
                 */
                ChangePasswordModalController.prototype.disableAllButtons = function () {
                    return this.computing;
                };
                ChangePasswordModalController.$inject = ["$scope", "$uibModalInstance", "options", "modalVariables"];
                return ChangePasswordModalController;
            })(ModalController);
            passwordManagement.ChangePasswordModalController = ChangePasswordModalController;
            angular.module("ers.components.passwordManagement").controller("ChangePasswordModalController", ["$scope",
                "$uibModalInstance",
                "options",
                "modalVariables",
                ChangePasswordModalController]);
        })(passwordManagement = components.passwordManagement || (components.passwordManagement = {}));
    })(components = ers.components || (ers.components = {}));
})(ers || (ers = {}));




// * author BERTHETO
/**
 *
 * ERS Angular Service : ersModalService.
 */
var ers;
(function (ers) {
    var components;
    (function (components) {
        var modal;
        (function (modal_1) {
                        angular.module("ers.components.modal").factory("ersModalService", ["$uibModal",
                function ($uibModal) {
                    return new ModalService($uibModal);
                }]);
            /**
             * @ngdoc service
             * @module ers.components.modal
             * @name ersModalService
             *
             * @description
             *
             * Use this service to create display dialogs with rich content (templates), simple messages, or
             * pre-configured content like help, information, confirmation, or error messages.
             *
             * ### Examples
             *
             * #### Information modal dialog
             *
             * <code-editor identifier="example1" data-title="Information dialog" html-content-url="demos/ersModal/basicUsage/index.html"
             * js-content-url="demos/ersModal/basicUsage/script.js" css-content-url="demos/ersModal/basicUsage/styles.css"
             * content-mode="html"></code-editor>
             *
             * #### Confirmation modal dialog
             *
             * <code-editor identifier="example2" data-title="Confirmation dialog" html-content-url="demos/ersModal/otherUsage/index.html"
             * js-content-url="demos/ersModal/otherUsage/script.js" css-content-url="demos/ersModal/otherUsage/styles.css"
             * content-mode="html"></code-editor>
             *
             * #### Custom modal dialog
             *
             * <code-editor identifier="example3" data-title="Custom dialog" html-content-url="demos/ersModal/customDialog/index.html"
             * js-content-url="demos/ersModal/customDialog/script.js" css-content-url="demos/ersModal/customDialog/styles.css"
             * content-mode="html"></code-editor>
             *
             * ### Design Guidelines
             *
             * No design guidelines
             *
             * ### Accessibility Guidelines
             *
             * No accessibility guidelines
             *
             *
             */
            var ModalService = (function () {
                /**
                 * Constructor.
                 *
                 * @param $uibModal The UI-Bootstrap modal service.
                 */
                function ModalService($uibModal) {
                    /**
                     * The number of the currently opened popup.
                     */
                    this.popupOpened = 0;
                    /**
                     * The current modal id incremented as popups are opened.
                     */
                    this.currentId = 0;
                    this.uiBstpModalService = $uibModal;
                }
                //The following documents the modal service and its associated methods.
                /**
                 * @ngdoc method
                 * @name ersModalService#informationDialog
                 *
                 * @description
                 *
                 * Displays an ***Informational*** modal window with a message, an  OK button, and an "x" to dismiss the dialog.
                 *
                 * @param {string} title The modal title.
                 * @param {string} message the information message.
                 * @param {Function} onClose is the callback function triggered by clicking the 'ok' button.
                 * This callback is the same
                 * one that uses the modalInstance to return and manage the result promise.
                 * If you specify this callback and at the same time manage the resolved state of the promise, the two
                 * methods are executed.
                 *
                 * @return {ng.ui.bootstrap.IModalServiceInstance} Returns an open `modalInstance`. This is object with the
                 * following properties:
                 *
                 * - **close** (result)&#151;The method used to pass a result and close the modal (window) with the OK button.
                 *
                 * - **dismiss** (reason)&#151;The method used to pass a reason and close the modal (window) with the 'x'.
                 *
                 * - **result**&#151;A promise that is *resolved* when the modal is "closed" (OK button) or *rejected*
                 * (closed with the 'x'). In both cases, the modal is dismissed.
                 *
                 * - **opened**&#151;A promise that is resolved when a modal is opened after downloading the
                 * content's template and resolving all of the variables.
                 *
                 *
                 */
                ModalService.prototype.informationDialog = function (title, message, onClose) {
                    var okButton = {
                        label: "Ok",
                        escapeChoice: false,
                        defaultChoice: true,
                        commitChoice: true,
                        id: "ok"
                    };
                    // modal options
                    var modalOptions = {
                        title: title || "Information",
                        message: message || "",
                        buttons: [okButton],
                        onModalClose: onClose,
                        modal: true,
                        instanceTemplate: "modal/template/information-modal-template.html",
                        icon: "information"
                    };
                    return this.openDialog(modalOptions);
                };
                /**
                 * @ngdoc method
                 * @name ersModalService#errorDialog
                 *
                 * @description
                 *
                 * Displays an ***Error*** modal window with a message, an  OK button, and an "x" to dismiss the dialog.
                 *
                 * @param {string} title the modal title.
                 * @param {string} message the error message.
                 * @param {Function} onClose is the callback function triggered by clicking the 'ok' button.
                 * This callback is the same
                 * one that uses the modalInstance to return and manage the result promise.
                 * If you specify this callback and at the same time manage the resolved state of the promise, the two
                 * methods are executed.
            
                 *
                 * @return {ng.ui.bootstrap.IModalServiceInstance} Returns an open `modalInstance`. This is object with the
                 * following
                 * properties:
                 *
                 * - **close** (result)&#151;The method used to pass a result and close the modal (window) with the OK button.
                 *
                 * - **dismiss** (reason)&#151;The method used to pass a reason and close the modal (window) with the 'x'.
                 *
                 * - **result**&#151;A promise that is *resolved* when the modal is "closed" (OK button) or *rejected*
                 * when the modal is dismissed (closed with the 'x').
                 *
                 * - **opened**&#151;A promise that is resolved when a modal is opened after downloading the
                 * content's template and resolving all of the variables.
                 *
                 *
                 */
                ModalService.prototype.errorDialog = function (title, message, choices, onClose) {
                    var okButton = {
                        label: "Ok",
                        escapeChoice: false,
                        defaultChoice: true,
                        commitChoice: true,
                        id: "ok"
                    };
                    var choicesArray = [okButton];
                    if (choices) {
                        choicesArray = choices.concat(choicesArray);
                    }
                    // modal options
                    var modalOptions = {
                        title: title || "Error",
                        message: message || "",
                        buttons: choicesArray,
                        onModalClose: onClose,
                        modal: true,
                        instanceTemplate: "modal/template/information-modal-template.html",
                        icon: "error"
                    };
                    return this.openDialog(modalOptions);
                };
                /**
                 * @ngdoc method
                 * @name ersModalService#questionDialog
                 *
                 * @description
                 *
                 * Displays a ***Question*** modal window containing a message and multiple buttons. Each button returns a
                 * unique value
                 * when the modal closes. All buttons are 'close' buttons.
                 *
                 * @param {string} Sets the modal window title.
                 * @param {string} Sets the question message.
                 * @param {IChoice[]} Defines the buttons.
                 * @param {Function} onClose is the callback function triggered by clicking the 'ok' button.
                 * This callback is the same
                 * one that uses the modalInstance to return and manage the result promise.
                 * If you specify this callback and at the same time manage the resolved state of the promise, the two
                 * methods are executed.
                 *
                 * @return {ng.ui.bootstrap.IModalServiceInstance} Returns an open `modalInstance`. This is object with the following
                 * properties:
                 *
                 *
                 * - **close** (result)&#151;The method used to pass a result and close the modal (window) with a button.
                 *
                 * - **dismiss** (reason)&#151;The method used to pass a reason and close the modal (window) with the 'x'.
                 *
                 * - **result**&#151;A promise that is *resolved* when the modal is "closed" (button) or *rejected*
                 * when the modal is dismissed (closed with the 'x').
                 *
                 * - **opened**&#151;A promise that is resolved when a modal is opened after downloading the
                 * content's template and resolving all variables.
                 *
                 */
                ModalService.prototype.questionDialog = function (title, message, choices, onClose) {
                    // modal options
                    var modalOptions = {
                        title: title || "Question",
                        message: message,
                        buttons: choices,
                        onModalClose: onClose,
                        dismissCrossButtonVisible: false,
                        keyboard: false,
                        modal: true,
                        instanceTemplate: "modal/template/information-modal-template.html",
                        icon: "help"
                    };
                    return this.openDialog(modalOptions);
                };
                /**
                 * @ngdoc method
                 * @name ersModalService#confirmationDialog
                 *
                 * @description
                 *
                 * Displays an ***Confirmation*** modal window consisting of a message and yes/no buttons. Each button returns
                 * a value when the modal closes. All buttons are 'close' buttons.
                 *
                 * @param {string} title The modal title.
                 * @param {string} message The confirmation message.
                 * @param {Function} onClose The callback function triggered by the buttons click. This callback is the same than
                 * use the modalInstance returned and manage the result promise. If you specify this callback and in the same time
                 * you managed the resolved state of the result promise, the 2 methods will be executed.
                 * @param {string} [yesValue='yes'] the 'yes' button value to be returned during the close.
                 * @param {string} [noValue='no'] the 'no' button value to be returned during the close.
                 *
                 * @return {ng.ui.bootstrap.IModalServiceInstance} Returns an open `modalInstance`. This is object with the following
                 * properties:
                 *
                 * - **close** (result)&#151;The method used to pass a result and close the modal (window) with a button.
                 *
                 * - **dismiss** (reason)&#151;The method used to pass a reason and close the modal (window) with the 'x'.
                 *
                 * - **result**&#151;A promise that is *resolved* when the modal is "closed" (button) or *rejected*
                 * when the modal is dismissed (closed with the 'x').
                 *
                 * - **opened**&#151;A promise that is resolved when a modal is opened after downloading the
                 * content's template and resolving all variables.
                 *
                 *
                 *
                 */
                ModalService.prototype.confirmationDialog = function (title, message, onClose, yesValue, noValue) {
                    var yesButton = {
                        label: "Yes",
                        escapeChoice: false,
                        defaultChoice: true,
                        id: "yes",
                        commitChoice: true,
                        value: yesValue || "yes"
                    };
                    var noButton = {
                        label: "No", escapeChoice: false, defaultChoice: false, id: "no", value: noValue || "no"
                    };
                    return this.questionDialog(title, message, [noButton, yesButton], onClose);
                };
                /**
                 * @ngdoc method
                 * @name ersModalService#customDialog
                 *
                 * @description
                 *
                 * Displays a ***Custom*** modal window providing either a simple message or complex content
                 * (html template). When passing variables with `customDialog`, a controller must exist
                 * inheriting values from `ModaController`. The template must define the controller name as 'ctrl', allowing you
                 * to override the `onBefore` close/dismiss methods and manage the form for the validity of the button status and
                 * error messages.
                 *
                 *
                 *
                 * <!-- For this dialog type, if you use a template for the content and you want to pass variables from the calling
                 * screen to the dialog, you must have a controller inheriting from `ModalController` and the controller name in
                 * your template must be `ctrl`. this inherited controller allows you to overide the onBefore close/dismiss methods,
                 * manage the form validity (for the buttons status and error messages), etc.//-->
                 *
                 * @param {IModalInstanceOptions} pModalOptions modal configuration options
                 * @param {object} modalVariables variables to be used by the modal content. (all the non configuration variables).
                 * These variables  will be resolved and passed to the controller as locals; it is equivalent of the resolve
                 * property for AngularJS routes. In the controller associated to your template, you must inject modalVariables
                 * to retrieve these variables.
                 *
                 * @return {ng.ui.bootstrap.IModalServiceInstance} Returns an open `modalInstance`. This is object with the following
                 * properties:
                 *
                 * - **close** (result)&#151;The method used to pass a result and close the modal (window) with a button.
                 *
                 * - **dismiss** (reason)&#151;The method used to pass a reason and close the modal (window) with the 'x'.
                 *
                 * - **result**&#151;A promise that is *resolved* when the modal is "closed" (button) or *rejected*
                 * when the modal is dismissed (closed with the 'x').
                 *
                 * - **opened**&#151;A promise that is resolved when a modal is opened after downloading the
                 * content's template and resolving all variables.
                 *
                 *
                 */
                ModalService.prototype.customDialog = function (pModalOptions, modalVariables) {
                    return this.openDialog(pModalOptions, modalVariables, "modal/template/modal-template.html");
                };
                /**
                 * @ngdoc method
                 * @name ersModalService#openDialog
                 *
                 * @description
                 *
                 * Displays an ***Open*** a modal window allowing you to display either a simple or complex (html template)
                 * message. When using `openDialog`, the variables are resolved and passed to the controller as local; the
                 * equivalent of the Angular ***resolve*** property. In the controller associated with the template, you must inject
                 * `modalVariables` to retrieve these variables.
                 *
                 *
                 * @param {IModalInstanceOptions} pModalOptions Modal configuration options
                 * @param {object} modalVariables Variables to be used by the modal content (all the non configuration variables).
                 *
                 * These variables  are resolved and passed to the controller as locals; it is equivalent of the resolve
                 * property for AngularJS routes. In the controller associated to your template, you must inject modalVariables
                 * to retrieve these variables.
                 *
                 * @param {string} pTemplateUrl A path to a template representing the modal's content. This is not the included
                 * functional content (template or message) but the base UI of the modal (i.e. the main div/forms, buttons and basic
                 * layout).
                 *
                 * @param {string} pTemplateControllerAs The `controllerAs` used by the modal template and the modal content
                 * template.
                 *
                 * @return {ng.ui.bootstrap.IModalServiceInstance} Returns an open `modalInstance`. This is object with the following
                 * properties:
                 *
                 * - **close** (result)&#151;The method used to pass a result and close the modal (window) with a button.
                 *
                 * - **dismiss** (reason)&#151;The method used to pass a reason and close the modal (window) with the 'x'.
                 *
                 * - **result**&#151;A promise that is *resolved* when the modal is "closed" (button) or *rejected*
                 * when the modal is dismissed (closed with the 'x').
                 *
                 * - **opened**&#151;A promise that is resolved when a modal is opened after downloading the
                 * content's template and resolving all variables.
                 *
                 */
                ModalService.prototype.openDialog = function (pModalOptions, modalVariables, pTemplateUrl, pTemplateControllerAs) {
                    var _this = this;
                    // compute different properties.
                    var modal = pModalOptions.modal === undefined || pModalOptions.modal ? true : false;
                    var backdrop = modal ? "static" : false;
                    this.currentId = this.currentId + 1;
                    var windowClass = pModalOptions.windowClass || "";
                    if (pModalOptions.resizable) {
                        windowClass = windowClass + " " + "ers-modal-resizable";
                    }
                    if (pModalOptions.draggable) {
                        windowClass = windowClass + " " + "ers-modal-draggable";
                    }
                    // dialog configuration  options
                    var modalOptions = {
                        // first, Ui Bootstrap modalService .
                        templateUrl: pTemplateUrl || "modal/template/modal-template.html",
                        controllerAs: pTemplateControllerAs || "ctrl",
                        controller: pModalOptions.templateController || modal_1.ModalController,
                        keyboard: angular.isDefined(pModalOptions.keyboard) ? pModalOptions.keyboard : true,
                        windowClass: windowClass,
                        size: pModalOptions.size,
                        backdrop: backdrop,
                        backdropClass: pModalOptions.draggable || pModalOptions.resizable ? "ers-modal-backdrop" : "",
                        resolve: {
                            // second, options used by the ModalController to configure the modal behaviors.
                            options: function () {
                                var options = {
                                    title: pModalOptions.title,
                                    icon: pModalOptions.icon,
                                    buttons: pModalOptions.buttons,
                                    nullFieldsCheckedForFormValidity: pModalOptions.nullFieldsCheckedForFormValidity,
                                    dismissCrossButtonVisible: angular.isUndefined(pModalOptions.dismissCrossButtonVisible)
                                        ? true
                                        : pModalOptions.dismissCrossButtonVisible,
                                    instanceTemplate: pModalOptions.instanceTemplate ? pModalOptions.instanceTemplate : (pModalOptions.message
                                        ? "modal/template/information-modal-template.html"
                                        : null),
                                    onModalDismiss: pModalOptions.onModalDismiss,
                                    onModalClose: pModalOptions.onModalClose,
                                    onBeforeModalClose: pModalOptions.onBeforeModalClose,
                                    onBeforeModalDismiss: pModalOptions.onBeforeModalDismiss,
                                    message: pModalOptions.message,
                                    draggable: pModalOptions.draggable,
                                    resizable: pModalOptions.resizable,
                                    focusPath: pModalOptions.focusPath,
                                    modal: modal,
                                    id: pModalOptions.id || "pop_" + _this.currentId
                                };
                                return options;
                                // Third, the functionnal variables used by the functionnal content template/controller .
                            }, modalVariables: function () {
                                return modalVariables;
                            }
                        }
                    };
                    // Now we can open the modal.
                    var modalInstance = this.uiBstpModalService.open(modalOptions);
                    // The opened promise
                    modalInstance.opened.then(function () {
                        // the opened number is updated.
                        _this.popupOpened = _this.currentId;
                        if (pModalOptions.onModalOpen) {
                            pModalOptions.onModalOpen();
                        }
                    });
                    // the result promise returned by the open action is used to manage the onModalClose and onModalDismiss callback methods
                    // if they exist.
                    var modalInstanceResult = modalInstance.result;
                    modalInstanceResult.then(function (closeModalResult) {
                        _this.popupOpened--;
                        if (pModalOptions.onModalClose) {
                            pModalOptions.onModalClose(closeModalResult);
                        }
                    }, function (closeModalResult) {
                        _this.popupOpened--;
                        if (pModalOptions.onModalDismiss) {
                            pModalOptions.onModalDismiss(closeModalResult);
                        }
                    });
                    // we return the modal instance to allow your own promise treatment.
                    return modalInstance;
                };
                /**
                 * Injector.
                 */
                ModalService.$inject = ["$uibModal"];
                return ModalService;
            })();
            modal_1.ModalService = ModalService;
        })(modal = components.modal || (components.modal = {}));
    })(components = ers.components || (ers.components = {}));
})(ers || (ers = {}));

// currently it is not enough to define a dependencies on angular modules as ChanegPassword depends on modal component.
// so we have to set a reference to the modal directives.






var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var ers;
(function (ers) {
    var components;
    (function (components) {
        var passwordManagement;
        (function (passwordManagement) {
            var ModalController = ers.components.modal.ModalController;
            /**
             * Controller associated to the password-management-template as a modal.
             *
             * When the password-management modal is open, the opener could pass username and database to the modal using
             * the modalVariables (injected by the ModalService).
             * By default, on the update click, the controller will check if the new passwords are equal and if it's the case,
             * call the [onChangePassword](#changepasswordfunction) callback function. If an error occur,
             * the [changePasswordError](#changepassworderror) is updated; if no error,
             * the modal is closed.
             *
             *  The following are the methods available:
             *
             * ### Available Methods
             *
             * * [compareNewPasswords](#comparenewpasswords), [callChangePasswordCallback](#callchangepasswordcallback),
             * [onCloseModal](#onclosemodal), [formIsValid](#formisvalid) , [disableAllButtons](#disableAllButtons)
             */
            var ResetPasswordModalController = (function (_super) {
                __extends(ResetPasswordModalController, _super);
                /**
                 * constructor
                 * @param $scope the scope.
                 * @param $modalInstance the modal instance.
                 * @param options the injected ersModalService options for the change password modal
                 * @param modalVariables the injected ersModalService specific variables for the change password modal.
                 */
                function ResetPasswordModalController($scope, $modalInstance, options, modalVariables) {
                    _super.call(this, $scope, $modalInstance, options, modalVariables);
                    // Resolved variables, from the modal service, are parsed.
                    this.email = modalVariables["email"];
                }
                /**
                 * Form validity test.
                 * @return {boolean} true if the chang password form is valid.
                 */
                ResetPasswordModalController.prototype.formIsValid = function () {
                    return this.email !== undefined;
                };
                ResetPasswordModalController.$inject = ["$scope", "$uibModalInstance", "options", "modalVariables"];
                return ResetPasswordModalController;
            })(ModalController);
            passwordManagement.ResetPasswordModalController = ResetPasswordModalController;
            angular.module("ers.components.passwordManagement").controller("ResetPasswordModalController", ["$scope",
                "$uibModalInstance",
                "options",
                "modalVariables",
                ResetPasswordModalController]);
        })(passwordManagement = components.passwordManagement || (components.passwordManagement = {}));
    })(components = ers.components || (ers.components = {}));
})(ers || (ers = {}));

/** Created by bertheto on 04/05/2015.
 */





/**
 * @author BERTHETO
 * ERS Angular Service: ersPasswordManagementService.
 */
var ers;
(function (ers) {
    var components;
    (function (components) {
        var passwordManagement;
        (function (passwordManagement) {
                        angular.module("ers.components.passwordManagement").factory("ersPasswordManagementService", ["ersModalService",
                function (ersModalService) {
                    return new PasswordManagementService(ersModalService);
                }]);
            /**
             * @ngdoc service
             * @module ers.components.passwordManagement
             * @name ersPasswordManagementService
             *
             * @description
             *
             * Use this service to manage the passwords used in the [ersLogin](#/components/ersLogin/documentation). It offers
             * two services:
             *
             *  - changePassword service&#151;Opens a modal to change the current password.
             *  - resetPassword service&#151;Opens a modal to reset the current password. This modal requests an
             *  email address and emails the reset password instructions.
             *
             */
            var PasswordManagementService = (function () {
                /**
                 * Constructor.
                 *
                 * @param $modal The UI-Bootstrap modal service.
                 */
                function PasswordManagementService(pErsModalService) {
                    this.modalService = pErsModalService;
                }
                /**
                 *  Configure and open the password-management modal to change the current password.
                 * @param pUsername The username.
                 * @param pDatabase The current database.
                 * @param pChangePasswordError The error to resolve in case of failure.
                 * @param pOnChangePassword The promise callback triggered when the change password button is clicked.
                 * @param pOnChangePasswordSuccess The promise callback triggered when the change password succeeds and after
                 * the modal is closed.
                 * @returns {ng.ui.bootstrap.IModalServiceInstance} The modal instance.
                 */
                PasswordManagementService.prototype.changePassword = function (pUsername, pDatabase, pChangePasswordError, pOnChangePassword, pOnChangePasswordSuccess) {
                    var modalInstance;
                    // the modal options
                    var modalOptions = {
                        instanceTemplate: "password-management/template/change-password-template.html",
                        title: "Change Password",
                        onBeforeModalClose: null,
                        onBeforeModalDismiss: null,
                        onModalDismiss: null,
                        message: null,
                        focusPath: "input[name='username']",
                        id: "changePasswordPop",
                        buttons: [{
                                label: "Cancel",
                                escapeChoice: true,
                                defaultChoice: false,
                                commitChoice: false,
                                id: "Cancel",
                                value: "Cancel"
                            },
                            {
                                label: "Update",
                                escapeChoice: false,
                                defaultChoice: true,
                                commitChoice: true,
                                id: "Update",
                                value: "Update"
                            }],
                        templateController: "ChangePasswordModalController"
                    };
                    // open the modal
                    modalInstance = this.modalService.customDialog(modalOptions, {
                        username: pUsername,
                        database: pDatabase,
                        changePassword: function (credentials) {
                            return pOnChangePassword(credentials);
                        },
                        changePasswordError: pChangePasswordError,
                        changePasswordSuccess: null
                    });
                    // promise results.
                    modalInstance.result.then(function (closeModalResult) {
                        pOnChangePasswordSuccess(closeModalResult);
                    }, function (closeModalResult) {
                        //nothing
                    });
                    return modalInstance;
                };
                /**
                 * Configure and open the reset password modal to display the email entry dialog for the email address
                 * to which the password reset instructions are sent.
                 *
                 * @param pOnResetPassword The promise callback triggered when the modal is closed after the 'send' button click.
                 * @param pOnResetPasswordCancel The promise callback triggered when the modal is closed after the cancel
                 * click.
                 * @returns {ng.ui.bootstrap.IModalServiceInstance} The modal instance.
                 */
                PasswordManagementService.prototype.resetPassword = function (pOnResetPassword, pOnResetPasswordCancel) {
                    var modalInstance;
                    // the modal options
                    var modalOptions = {
                        instanceTemplate: "password-management/template/reset-password-template.html",
                        title: "Reset Password",
                        onBeforeModalClose: null,
                        onBeforeModalDismiss: null,
                        message: null,
                        id: "resetPasswordPop",
                        focusPath: "input[name='email']",
                        buttons: [
                            {
                                label: "Send",
                                escapeChoice: false,
                                defaultChoice: true,
                                commitChoice: true,
                                id: "Send",
                                value: "Send"
                            }], dismissCrossButtonVisible: true, nullFieldsCheckedForFormValidity: ["email"]
                    };
                    // open the modal
                    modalInstance = this.modalService.customDialog(modalOptions, { email: null });
                    // promise results.
                    modalInstance.result.then(function (closeModalResult) {
                        pOnResetPassword(closeModalResult["email"]);
                    }, function () {
                        pOnResetPasswordCancel();
                    });
                    return modalInstance;
                };
                /**
                 * Injector.
                 */
                PasswordManagementService.$inject = ["ersModalService"];
                return PasswordManagementService;
            })();
            passwordManagement.PasswordManagementService = PasswordManagementService;
        })(passwordManagement = components.passwordManagement || (components.passwordManagement = {}));
    })(components = ers.components || (ers.components = {}));
})(ers || (ers = {}));/** Created by BerthetO on 16/12/2014.
 */



/**
 * ChangePasswordError
 * Used to transmit user informations during change Password.
 * Created by BerthetO on 15/12/2014.
 */
var ers;
(function (ers) {
    var components;
    (function (components) {
        var passwordManagement;
        (function (passwordManagement) {
            var ChangePasswordResolvedVar = (function () {
                /**
                 * constructor
                 * @param pUsername the username
                 * @param pDatabase the database
                 * @param pChangePassword the change password function
                 */
                function ChangePasswordResolvedVar(pUsername, pDatabase, pChangePassword) {
                    this.username = pUsername;
                    this.database = pDatabase;
                    this.changePassword = pChangePassword;
                }
                return ChangePasswordResolvedVar;
            })();
            passwordManagement.ChangePasswordResolvedVar = ChangePasswordResolvedVar;
        })(passwordManagement = components.passwordManagement || (components.passwordManagement = {}));
    })(components = ers.components || (ers.components = {}));
})(ers || (ers = {}));

/** Created by bertheto on 04/05/2015.
 *//*
 * Created by bertheto on 06/04/2015.
 */



// currently it is not enough to define a dependencies on angular modules as login depends on change password component.
// so we have to set a reference to the password directive.


var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};









var ers;
(function (ers) {
    var components;
    (function (components) {
        var login;
        (function (login) {
                        var BaseComponent = ers.components.core.BaseComponent;
            angular.module("ers.components.login").directive("ersLogin", function () {
                return {
                    restrict: "E",
                    templateUrl: "login/template/login-template.html",
                    controller: LoginComponent,
                    controllerAs: "ctrl",
                    bindToController: true,
                    scope: {
                        "productName": "@",
                        "databases": "=",
                        "onLogin": "&",
                        "resetPasswordOptions": "=",
                        "changePasswordOptions": "="
                    }
                };
            });
            /**
            *
            * @ngdoc directive
            * @name ersLogin
            * @restrict E
            *
            * @module ers.components.login
            *
            *
            * @scope
            * @description
            *
            * Use `ers-login` component to display a login screen and, optionally, change or reset password screens.
            *
            * ### Usage
            *
            * - Traditionally, `ers-login` is used on a stand-alone page. You can, however, use it as a component
            * on a page with other components, or launch it as a modal dialog.
            * - The `ers-login` component controller does not manage the log in and change password operations,
            * it only allows the user to fill in user information and launch login/change/reset password commands.
            * - The functions associated with this controller are triggered by the login click
            * [onLogin](http://galileo/typedoc/classes/ers.components.login.logincomponent.html#onlogin)
            * and the change password request
            * [onChangePassword](http://galileo/typedoc/interfaces/ers.components.changepassword.ichangepasswordoptions.html).
            *
            *
            * ### Examples
            *
            * The following example displays the basic login UI:
            *
            * <code-editor identifier="example1" data-title="Login" html-content-url="demos/ersLogin/basicUsage/index.html"
            * js-content-url="demos/ersLogin/basicUsage/script.js" css-content-url="demos/ersLogin/basicUsage/styles.css"
            * content-mode="html"></code-editor>
            *
            * ### Design Guidelines
            *
            * - Login and Change Password components provide the customer-facing user-interface that runs the commands
             * to securely log in, change, or reset the password of your application.
            * - Consider the following:
            *  - Ensure that stand-alone login pages are clean and uncluttered.
            *  - Consider a login link that displays a modal login.
            *  - If Change Password is not part of the login screen, consider how to handle instances where a password must
             *  be changed.
            *  - Consider situations where a password must be reset.
            *
            * ### Accessibility Guidelines
            *
            * No accessibility guidelines
            *
            *
            * @param {string} [product-name] {@} Sets the name of the product.
            * ```xml
            *  <ers-login  product-name="{{myCtrl.productName}}"></ers-login>
            *  ```
            *
            * @param {boolean} [change-password-options] {=?} Calls the change password dialog and provides two options:
            *
            * - onChangePassword - Sets the action to perform when a user clicks 'update' to verify the new password.
            * - onChangePasswordSuccess - Sets the action to perform at the end of the change password process. If no error
            * has occurred, it displays the change password success message.
            *```xml
            *  <ers-login change-password-options="myCtrl.changePasswordOptions"></ers-login>
            *  ```
            * @param {string} [on-login] {&} Sets the action performed when a user logs in. This function must return a promise.
            * When an error occurs during the login, the promise must update the error attribute to display the error message
            * on the login screen. For example:
            *
            *
            * ```xml
            *  promise.reject({credentialsError: true, message: "bad password or username"})
            *  ```
            *
            * The callback function must use the following format:
            *
            * ```xml
            * functionName(loginInfo:ILoginInfo):ng.IPromise {
            * }
            * ```
            *
            * The attribute tag must use the following format:
            *
            * ```xml
            * <ers-login on-login="myCtrl.verifyLoginInfo(loginInfo)"></ers-login>
            *
            * ```
            *
            * @param {string} [databases] {=} Sets the appropriate database.
            * ```xml
            *  <ers-login databases="myCtrl.databases"></ers-login>
            *  ```
            */
            var LoginComponent = (function (_super) {
                __extends(LoginComponent, _super);
                /**
                 * @constructor
                 * @param $scope The isolated scope.
                 * @param ersModalService The modal service that displays the password-management modal.
                 */
                function LoginComponent($scope, passwordManagementService) {
                    _super.call(this, $scope);
                    /**
                     * The selected database.
                     */
                    this.selectedDbIndex = 0;
                    /**
                     * True when the screen is 'computing', or waiting for a response from the onLogin callback.
                     * @type {boolean}
                     */
                    this.computing = false;
                    this.passwordService = passwordManagementService;
                }
                /**
                 * Select the database entry by its index.
                 * @param pIndex database index to select.
                 */
                LoginComponent.prototype.selectDb = function (pIndex) {
                    this.selectedDbIndex = pIndex;
                };
                /**
                 * The selected database getter.
                 * @return {string} the selected database name.
                 */
                LoginComponent.prototype.getSelectedDb = function () {
                    return this.databases[this.selectedDbIndex];
                };
                /**
                 *
                 * Where the login function calls the onLogin callback function and passes the ILoginInfo parameters.
                 *
                 */
                LoginComponent.prototype.login = function () {
                    var _this = this;
                    this.computing = true;
                    var loginInfo = {
                        username: this.username,
                        password: this.password,
                        database: this.databases && this.databases.length > 0 ? this.getSelectedDb() : null
                    };
                    var promise = this.onLogin({ loginInfo: loginInfo });
                    promise.then(function () {
                        _this.computing = false;
                        _this.loginError = null;
                    }, function (error) {
                        _this.loginError = error;
                        _this.computing = false;
                    });
                };
                /**
                 * Tests the database drop down visibility.
                 * @return {boolean} True if the database drop down is visible.
                 *
                 */
                LoginComponent.prototype.isDatabaseDdwVisible = function () {
                    return this.databases !== undefined && this.databases.length > 1;
                };
                /**
                 * The login error getter.
                 * @return {string} The login error message
                 */
                LoginComponent.prototype.getErrorMessage = function () {
                    return this.loginError ? this.loginError.message : undefined;
                };
                /**
                 *
                 * Configure and open the password-management modal for changing the password.
                 *
                 */
                LoginComponent.prototype.openChangePassword = function () {
                    return this.passwordService.changePassword(this.username, this.getSelectedDb(), this.changePasswordOptions.changePasswordError, this.changePasswordOptions.onChangePassword, this.changePasswordOptions.onChangePasswordSuccess);
                };
                /**
                 *
                 * Configure and open the password-management modal for resetting the password.
                 *
                 */
                LoginComponent.prototype.openResetPassword = function () {
                    return this.passwordService.resetPassword(this.resetPasswordOptions.onResetPassword, this.resetPasswordOptions.onResetPasswordCancel);
                };
                LoginComponent.$inject = ["$scope", "ersPasswordManagementService"];
                return LoginComponent;
            })(BaseComponent);
            login.LoginComponent = LoginComponent;
        })(login = components.login || (components.login = {}));
    })(components = ers.components || (ers.components = {}));
})(ers || (ers = {}));/*
 * Created by bertheto on 13/04/2015.
 */

/**
 * The interface representing the data scope for the [[modalScriptDirective]].
 */
var ers;
(function (ers) {
    var components;
    (function (components) {
        var modal;
        (function (modal) {
                    })(modal = components.modal || (components.modal = {}));
    })(components = ers.components || (ers.components = {}));
})(ers || (ers = {}));


/**
 *
 * This component generates the JavaScript to manage resizable, draggable, and mode-less dialogs.
 * The ModalService is a set of services, templates and a controller. The only way to manipulate the popup dom is to
 * use this component or JavaScript from modalTemplate.html.
 *
 *
 *
 *
 */
var ers;
(function (ers) {
    var components;
    (function (components) {
        var modal;
        (function (modal) {
                        angular.module("ers.components.modal").directive("ersModalScript", modalScriptDirective);
            /**
             *
             * @returns {{restrict: string, scope: {modalId: string, modal: string, resizable: string, draggable: string,
             * focusPath: string}, link: (function(IModalScriptScope, ng.IAugmentedJQuery): undefined)}}
             */
            function modalScriptDirective() {
                return {
                    restrict: "E", scope: {
                        "modalId": "@", modal: "=", resizable: "=", draggable: "=", focusPath: "="
                    },
                    /**
                     * Link function.
                     * @param $scope {IModalScriptScope} The modal script scope.
                     * @param element {ng.IAugmentedJQuery} The element.
                     *
                     *
                     *
                     *
                     */
                    link: function ($scope, element) {
                        // Modal elements Constants
                        var MODAL_DIALOG = ".modal-dialog";
                        var MODAL_CONTENT = ".modal-content";
                        var MODAL = ".modal";
                        var MODAL_BODY = ".modal-body";
                        var MODAL_HEADER = ".modal-header";
                        var MODAL_BACKDROP = ".modal-backdrop";
                        var FORM_INPUT = ".form-input";
                        var FORM_MODAL_FORM = "#modalForm_" + $scope.modalId;
                        var DIV_MODAL_FORM = ".modal-form";
                        var modalDialog = $($(element.parents(MODAL_DIALOG))[0]);
                        var modalDiv = $($(modalDialog.parents(MODAL))[0]);
                        var elementToResize;
                        /**
                         * extract and return the modal-content boxshadow width.
                         * @return the boxshadow width.
                         */
                        function getBoxShadowWidth() {
                            var boxshadow = modalDialog.find(MODAL_CONTENT).css("box-shadow");
                            // Remove all possible color definitions
                            boxshadow = boxshadow.replace(/rgba?\([^\)]+\)/gi, "");
                            boxshadow = boxshadow.replace(/#[0-9a-f]+/gi, "");
                            // Remove any alpha characters
                            boxshadow = $.trim(boxshadow.replace(/[a-z]+/gi, ""));
                            // Split and get 3-rd element, which is box shadow length
                            var boxshadowWidth = parseInt(boxshadow.split(" ")[2], 10);
                            return boxshadowWidth;
                        }
                        ;
                        /**
                         * The bootstrap modal is composed of a visible modal dialog and a transparent modal div. The
                         * transparent modal div comprises the entire screen. It is, however, not a backdrop, but a place
                         * holder that used to position the visible modal dialog. The modal div acts like a mode-less dialog
                         * that will resize so the visible modal does not lose its position. The position and resize are
                         * completed automatically when you click on the transparent modal background.
                         *
                         * @param event {JQueryEventObject} The click event.
                         */
                        function clickModal(event) {
                            // if the event source is not the modal div , return.
                            if (event != null && event.srcElement === $(MODAL_DIALOG)[0]) {
                                return;
                            }
                            // first, calculate  boxshadow and offsets
                            var boxshadowWidth = getBoxShadowWidth();
                            var topDialog = modalDialog.offset().top - parseInt(modalDiv.css("margin-top"), 10);
                            var bottomDialog = ($(window).height() - (modalDialog.offset().top + modalDialog.outerHeight())) -
                                parseInt(modalDialog.css("margin-bottom"), 10) - boxshadowWidth;
                            // second, set the modal top, bottom, left and right positions.
                            modalDiv.css("top", topDialog);
                            modalDiv.css("bottom", bottomDialog);
                            if (event != null) {
                                // the left/right positions are only set in the case of a real click event (and not in the direct call
                                // of this method)
                                // because there is some alignement/position problems during resize for example.
                                fixWidth();
                            }
                            // third, set the modal width/height.
                            modalDiv.css("height", modalDialog.height());
                            modalDiv.css("width", "auto");
                            //fourth, reset the modalDialog margin-bottom
                            modalDialog.css("margin-bottom", 0);
                            // fifth, remove the click listener because now the modal transparent background has the same size and
                            // position than the modal dialog
                            modalDiv.off("click", clickModal);
                        }
                        /**
                         * When the modal launches it must be resized and the size and current height stored.
                         *
                         */
                        function resizeStart() {
                            modalDialog.find(MODAL_BODY + ", iframe").each(function () {
                                elementToResize = $(this);
                                elementToResize.data("resizeoriginalheight", elementToResize.height());
                            });
                        }
                        /**
                         * The modal div must recalculate the modal div left/right position to
                         * so that it matches the same width and horizontal position as
                         * modal-dialog
                         */
                        function fixWidth() {
                            var boxshadowWidth = getBoxShadowWidth();
                            var leftDialog = modalDialog.offset().left - boxshadowWidth;
                            var rightDialog = ($(window).width() - (modalDialog.offset().left + modalDialog.outerWidth())) -
                                boxshadowWidth;
                            modalDiv.css("left", leftDialog);
                            modalDiv.css("right", rightDialog);
                        }
                        /**
                         * Resizing the modal.
                         * @param event {Event} The resize event.
                         * @param ui {JQueryUI.ResizableUIParams} The Resizable UI Params.
                         */
                        function resize(event, ui) {
                            // first, fix the min-height.
                            $(this).css("min-height", elementToResize.data("resizeoriginalheight") + ui.size.height - ui.originalSize.height);
                            $(ui.element).css("min-height", elementToResize.data("resizeoriginalheight") + ui.size.height - ui.originalSize.height);
                            // second, get various additional sizes.
                            var boxshadowWidth = getBoxShadowWidth();
                            var headerSize = $(ui.element).find(MODAL_HEADER).height();
                            var buttonSize = $(ui.element).find(FORM_INPUT).height();
                            // third, set the modal_form div/form heights
                            $(ui.element).find(FORM_MODAL_FORM).css("height", elementToResize.data("resizeoriginalheight") + ui.size.height - ui.originalSize.height - headerSize +
                                boxshadowWidth);
                            $(ui.element).find(DIV_MODAL_FORM).css("height", elementToResize.data("resizeoriginalheight") + ui.size.height - ui.originalSize.height - headerSize -
                                buttonSize + boxshadowWidth);
                            // fourth, set modal width/height to auto.
                            $(ui.element).css("height", "auto");
                            modalDiv.css("height", "auto");
                            modalDiv.css("width", "auto");
                            // fifth, call the clickModal function to adjust the modal transparent div size/position
                            // to the modal-dialog size/position.
                            clickModal();
                        }
                        /**
                         *
                         * @return {JQuery} The focus element configured, or the transparent background.
                         */
                        var getFocusElement = function () {
                            var focusElement = $scope.focusPath && $(FORM_MODAL_FORM).find($scope.focusPath)
                                ? $(FORM_MODAL_FORM).find($scope.focusPath)
                                : $(FORM_MODAL_FORM).find("#fake");
                            return focusElement;
                        };
                        if ($scope.draggable || $scope.resizable || !$scope.modal) {
                            // Initiate first click on the invisible modal background to resize it at the modal-dialog size.
                            $(modalDiv).on("click", clickModal);
                            // manage the 3 cases : draggable, resizable, modaless
                            if (!$scope.modal) {
                                $($(modalDiv.parents(MODAL_BACKDROP))[0]).remove();
                                // to trigger the resize of the modalDiv after the modal's opening.
                                setTimeout(function () {
                                    getFocusElement().bind("focus", function (event) {
                                        clickModal(event);
                                    });
                                }, 200);
                            }
                            if ($scope.draggable) {
                                $(modalDiv).draggable({ handle: MODAL_HEADER });
                            }
                            if ($scope.resizable) {
                                $(modalDialog).on("resizestart", resizeStart);
                                $(modalDialog).on("resize", resize);
                                $(modalDialog).on("resizestop", fixWidth);
                                $(modalDialog).resizable();
                            }
                        }
                        setTimeout(function () {
                            // focus on the 'fake' invisible input to allow the form submit behaviour.
                            // $($(FORM_MODAL_FORM).find("#fake")).focus();
                            getFocusElement().focus();
                            // 'enter' management on the modal div to simulate the 'submit' button click.
                            $(modalDiv).bind("keypress", function (event) {
                                if (event.which === ers.components.utility.KEY.ENTER) {
                                    var buttonSubmit = $(modalDiv).find("button[name='commit']");
                                    if (!buttonSubmit.is("[disabled=disabled]")) {
                                        buttonSubmit.trigger("click");
                                    }
                                    event.preventDefault();
                                    event.stopPropagation();
                                }
                            });
                        }, 500);
                        // Destroy.
                        $scope.$on("$destroy", function () {
                            $(modalDiv).unbind();
                            $(modalDiv).off("click", clickModal);
                            if ($scope.resizable) {
                                $(modalDialog).off("resizestart", resizeStart);
                                $(modalDialog).off("resize", resize);
                                $(modalDialog).off("resizestop", fixWidth);
                                if ($(modalDialog).resizable("instance")) {
                                    $(modalDialog).resizable("destroy");
                                }
                            }
                            if ($scope.draggable) {
                                if ($(modalDialog).resizable("instance")) {
                                    $(modalDiv).draggable("destroy");
                                }
                            }
                            if (!$scope.modal) {
                                $(FORM_MODAL_FORM).find("#fake").unbind();
                            }
                        });
                    }
                };
            }
        })(modal = components.modal || (components.modal = {}));
    })(components = ers.components || (ers.components = {}));
})(ers || (ers = {}));

// Declare only the Angular module.
angular.module("ers.components.navigation", ["ers.components.core", "ui.bootstrap"]);/*
 * Created by fangiot on 2/18/2015.
 */
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};




/**
 * @-ngdoc directive
 * @module ers.components.navigation
 * @name ersNavigationItem
 * @restrict E
 * @scope
 * @transclude
 *
 * @description
 *
 * Use the `ers-nav-item` component to show a single navigation item or to group similar navigation items under a
 * common heading. When selected, the group expands to show any child navigation items.
 *
 * Add optional HTML to the `ers-nav-heading` element. Only text can be used in the `ers-nav-item`. Both are displayed
 * in the navigation menu.
 *
 * See [Navigation Component](#/components/ersNavigation/documentation) for more information.
 *
 * #### Visual Design Guidelines
 *
 * See [Navigation Component](#/components/ersNavigation/documentation) for more information.
 *
 * #### Example
 *
 * See the [Navigation Component](#/components/ersNavigation/documentation) for more information.
 *
 * @param {string} [heading] {@?}
 *
 * Sets the user supplied heading which is displayed for the item. In an attribute form, use only plain text. Use
 * `ers-nav-heading` to enter HTML headings or icons.
 *
 * ```xml
 * <ers-nav>
 *   <ers-nav-item heading="Item 1"></ers-nav-item>
 *
 *   <ers-nav-item>
 *     <ers-nav-heading>
 *       <i class="fa fa-home"></i> Home
 *     </ers-nav-heading>
 *   </ers-nav-item>
 * </ers-nav>
 * ```
 *
 * @param {boolean} [is-active] {=?}
 *
 * Use to bind data to the isActive property.
 *
 * **Note** The component is considered active after being selected using either the mouse or the keyboard.
 * When active, the group displays any child navigation items.
 *
 *
 * @param {boolean} [is-group = true] {=?}
 *
 * Sets the navigation item to display, or not, any children as a group.
 *
 */
var ers;
(function (ers) {
    var components;
    (function (components) {
        var navigation;
        (function (navigation) {
                        // Define our module and attach the directives
            angular.module("ers.components.navigation")
                .directive("ersNavItem", function NavigationItemDirective() {
                return {
                    restrict: "E",
                    templateUrl: "navigation/template/navigation-item-template.html",
                    transclude: true,
                    bindToController: true,
                    controller: NavigationItemComponent,
                    controllerAs: "vm",
                    scope: {
                        heading: "@?",
                        isActive: "=?",
                        isGroup: "=?"
                    }
                };
            })
                .directive("ersNavHeading", function NavigationHeadingDirective() {
                return {
                    restrict: "E",
                    transclude: "element",
                    scope: {},
                    link: function (scope, element, attrs, ctrl, transclude) {
                        transclude(function (clone, scope) {
                            var heading = element.closest("ers-nav-item").find("> .ers-nav-heading");
                            heading.empty();
                            heading.append(clone);
                        });
                    }
                };
            });
            // Import our relevant dependencies
            var BaseController = ers.components.core.BaseController;
            /**
             * The controlling class for the navigation item component.
             */
            var NavigationItemComponent = (function (_super) {
                __extends(NavigationItemComponent, _super);
                /**
                 * Creates an instance of this component which is automatically called by Angular.
                 *
                 * @param $scope The scope to which this component is bound.
                 * @param $element The element to which this component is bound.
                 * @param $timeout The Angular timeout service used for animations.
                 */
                function NavigationItemComponent($scope, $element, $timeout) {
                    var _this = this;
                    _super.call(this, $scope, $element);
                    this.$timeout = $timeout;
                    // Basic setup
                    this.setupDefaults();
                    this.setupBasicClasses();
                    this.setupParentNavigation();
                    // DOM setup
                    this.setupEvents();
                    this.setupWatchers();
                    // Update the layout or classes after the watchers have finished.
                    this.$timeout(function () {
                        _this.layout();
                    }, 0);
                }
                /**
                 *
                 * Called when an item is clicked or selected to notify the parent menu.
                 *
                 */
                NavigationItemComponent.prototype.wantsActivation = function () {
                    this.parentNav.activateChild(this);
                };
                /**
                 * Activate this navigation item.
                 */
                NavigationItemComponent.prototype.activate = function () {
                    if (!this.isActive) {
                        this.isActive = true;
                        // Update our layout/classes
                        this.layout();
                    }
                };
                /**
                 * Deactivates this navigation item.
                 *
                 * Called by the parent navigation when another item is activated.
                 */
                NavigationItemComponent.prototype.deactivate = function () {
                    if (this.isActive) {
                        this.isActive = false;
                        // Update our layout/classes
                        this.layout();
                    }
                };
                /**
                 * Checks for the parent of the requested child.
                 *
                 * @returns True if this is the of the child.
                 */
                NavigationItemComponent.prototype.isAncestorOf = function (child) {
                    var _this = this;
                    var parentElements = child.$element.parents("ers-nav-item");
                    var isParent = false, parent;
                    _.each(parentElements, function (parentElement) {
                        parent = angular.element(parentElement).controller("ersNavItem");
                        if (parent === _this) {
                            isParent = true;
                        }
                    });
                    return isParent;
                };
                /**
                 * Setup default values for scope objects.
                 */
                NavigationItemComponent.prototype.setupDefaults = function () {
                    // Use a blank heading if none was provided
                    this.heading = this.heading || "";
                    // Set the default to be inactive
                    this.isActive = this.isActive || false;
                    // Set the default to be a plain item
                    this.isGroup = this.isGroup || false;
                };
                /**
                 *
                 * Add a class to target this in the CSS.
                 *
                 */
                NavigationItemComponent.prototype.setupBasicClasses = function () {
                    // Add our basic type
                    this.$element.addClass(this.isGroup ? "ers-nav-group" : "ers-nav-item");
                    // Add an extra class if we are a sub-item of a group so we can target it in the CSS :not() pseudo-selector
                    if (this.$element.parents(".ers-nav-group").length > 0) {
                        this.$element.addClass("ers-nav-group-item");
                    }
                };
                /**
                 *
                 * Stores a reference to the parent navigation element and registers it so it can send notifications.
                 *
                 */
                NavigationItemComponent.prototype.setupParentNavigation = function () {
                    this.parentNav = angular.element(this.$element.closest("ers-nav")).controller("ersNav");
                    this.parentNav.registerChild(this);
                };
                /**
                 * Setup the necessary event listeners.
                 */
                NavigationItemComponent.prototype.setupEvents = function () {
                    var _this = this;
                    var heading = this.$element.find(".ers-nav-heading");
                    // Setup an event listener to activate ourselves upon clicking
                    heading.on("click", function (event) {
                        // If they clicked the heading (i.e. not a sub-heading in the content area)
                        if (_this.isActive) {
                            // If we are already active, and we are a group, deactivate/close
                            if (_this.isGroup) {
                                _this.deactivate();
                            }
                        }
                        else {
                            _this.wantsActivation();
                        }
                        // Run a digest cycle (activates the watchers and evaluates the scope for changes)
                        // since this happened outside of Angular (i.e. from jQuery events)
                        _this.$scope.$apply();
                    });
                    // De-register the listener on destruction
                    this.$scope.$on("destroy", function () {
                        heading.off("click");
                    });
                };
                /**
                 *
                 * Setup necessary DOM watchers.
                 *
                 */
                NavigationItemComponent.prototype.setupWatchers = function () {
                    var _this = this;
                    // Watch for outside changes to the isActive property and update our layout
                    this.$scope.$watch("vm.isActive", function (event, newActive) {
                        _this.layout();
                    });
                    // Remove the child when the scope is destroyed
                    this.$scope.$on("$destroy", function () {
                        _this.parentNav.deregisterChild(_this);
                    });
                };
                /**
                 *
                 * Set the maximum height property of the element to use as much space as available.
                 *
                 */
                NavigationItemComponent.prototype.layout = function () {
                    // If we should show active classes, set it
                    if (this.parentNav.showActive) {
                        this.$element.toggleClass("active", this.isActive);
                    }
                    // Nothing to animate unless we are a group
                    if (!this.isGroup) {
                        return;
                    }
                    // Grab our variables
                    var menu = this.$element.closest(".menu");
                    var content = this.$element.find(".ers-nav-content");
                    // If we are active, we must open
                    if (this.isActive) {
                        // Grab the item and group elements
                        var groups = menu.find(".ers-nav-group .ers-nav-content");
                        var items = menu.find("> ers-nav-item");
                        // Grab our heights
                        var menuHeight = this.$element.closest("ers-nav").height();
                        var itemsHeight = this.sumElementHeights(items);
                        var groupsHeight = this.sumElementHeights(groups);
                        var footerHeight = this.$element.closest("ers-nav").find(".footer").outerHeight();
                        // Calculate the height (the items.length subtracts 1px per item for the bottom borders)
                        var maxHeight = menuHeight - (itemsHeight - groupsHeight) - footerHeight - items.length, animationDuration = 500, actualHeight;
                        // Note: We have to quickly show/hide the element to calculate the actual height or we get 0
                        content.css({ maxHeight: maxHeight, overflow: "auto", transition: "none" });
                        actualHeight = content.height();
                        content.css({ maxHeight: "0", overflow: "hidden" });
                        // Force jQuery to update the styles below instead of optimizing the calls and replacing them
                        content.height();
                        // Set our real properties
                        content.css({
                            maxHeight: Math.min(actualHeight, maxHeight),
                            transition: "max-height " + animationDuration + "ms ease-in-out"
                        });
                        // Set the overflow from hidden back to auto after the animation completes so it shows a scroll bar if necessary
                        this.$timeout(function () {
                            menu.css("overflow", "auto");
                            content.css("overflow", "auto");
                        }, animationDuration, false);
                    }
                    else {
                        // Set the overflow to hidden to prevent a scroll bar from appearing on the menu during the animation and set
                        // the max-height to 0 to close the element
                        menu.css({ overflow: "hidden" });
                        content.css({ overflow: "hidden", maxHeight: "0" });
                    }
                };
                /**
                 * Get the total height of multiple elements.
                 *
                 * @param elements The elements whose total height is needed.
                 *
                 * @returns The total height of all of the elements.
                 */
                NavigationItemComponent.prototype.sumElementHeights = function (elements) {
                    return _.reduce(elements, function (totalHeight, element) {
                        var height = $(element).outerHeight();
                        return totalHeight + height;
                    }, 0);
                };
                // Notify Angular of the resources we need
                NavigationItemComponent.$inject = ["$scope", "$element", "$timeout"];
                return NavigationItemComponent;
            })(BaseController);
            navigation.NavigationItemComponent = NavigationItemComponent;
        })(navigation = components.navigation || (components.navigation = {}));
    })(components = ers.components || (ers.components = {}));
})(ers || (ers = {}));/*
 * Created by fangiot on 2/18/2015.
 */
//




var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
/**
 * @ngdoc directive
 * @name ersNavigation
 * @restrict E (element)
 * @module ers.components.navigation
 * @scope
 * @transclude
 *
 * @description
 *
 * Use the `ers.components.navigation` to create a left-hand navigation menu for your application.  You can create
 * both first and second-level
 * navigation items, as well as secondary and grouped navigation items. The navigation menu also includes the Moody's
 * approved copyright information.
 *
 * ### Usage
 *
 * `ers.components.navigation` contains three components:
 *
 *  - `ers-nav`&#151;Responsible for housing all of the other directives and providing a
 *    wrapper for the navigation menu.
 *  - `ers-nav-item`&#151;Shows menu and group items in the menu.
 *  - `ers-nav-heading`&#151;Provides custom HTML for your item or
 *  group headings.
 *
 * ### Examples
 *
 * <code-editor identifier="example3" data-title="Navigation"
 * html-content-url="demos/ersNavigation/basicUsage/index.html"
 * js-content-url="demos/ersNavigation/basicUsage/script.js"
 * css-content-url="demos/ersNavigation/basicUsage/styles.css" content-mode="html"></code-editor>
 *
 * ### Design Guidelines
 *
 *  Consider the following visual design guidelines when creating your navigation menu:
 *
 *  - Keep it simple.
 *  - You can apply standard HTML and CSS formatting and styles to the label.
 *  - Be cautious when combining with other components, like Tooltips.
 *  - Be cautious when creating sub-navigation menus.
 *
 * #### Styling
 *
 * The navigation component takes the full space of its containing element and uses absolute positioning. This
 * means that the containing element should also use absolute positioning. Where the containing element is
 * using relative positioning, the height and width must be properly calculated.
 *
 *
 * <doc-note>The containing element should allow a minimum width of 160px and a maximum width of 330px.</doc-note>
 *
 * ### Accessibility Guidelines
 *
 * No accessibility guidelines.
 *
 * @param {boolean} [show-active=false] {=?}
 *
 * (ers-navigation) Sets whether or not the `active` class is applied to the elements for styling purposes.
 *
 * @param {string} [heading] {@?}
 *
 * (ers-navigation-item) Sets the user supplied heading which is displayed for the item. In an attribute form, use only plain text. Use
 * `ers-nav-heading` to enter HTML headings or icons.
 *
 * ```xml
 * <ers-nav>
 *   <ers-nav-item heading="Item 1"></ers-nav-item>
 *
 *   <ers-nav-item>
 *     <ers-nav-heading>
 *       <i class="fa fa-home"></i> Home
 *     </ers-nav-heading>
 *   </ers-nav-item>
 * </ers-nav>
 * ```
 *
 * @param {boolean} [is-active] {=?}
 *
 * (ers-navigation-item) Use to bind data to the isActive property.
 *
 * **Note** The component is considered active after being selected using either the mouse or the keyboard.
 * When active, the group displays any child navigation items.
 *
 *
 * @param {boolean} [is-group = true] {=?}
 *
 * (ers-navigation-item) Sets the navigation item to display, or not, any children as a group.
 *
 */
var ers;
(function (ers) {
    var components;
    (function (components) {
        var navigation;
        (function (navigation) {
                        // Define our module and attach the directive
            angular.module("ers.components.navigation").directive("ersNav", function NavigationDirective() {
                return {
                    restrict: "E",
                    templateUrl: "navigation/template/navigation-template.html",
                    transclude: true,
                    bindToController: true,
                    controller: NavigationComponent,
                    controllerAs: "vm",
                    scope: {
                        showActive: "=?"
                    }
                };
            });
            // Import the relevant dependencies.
            var BaseComponent = ers.components.core.BaseComponent;
            /**
             * The controlling class for the Navigation Component.
             */
            var NavigationComponent = (function (_super) {
                __extends(NavigationComponent, _super);
                /**
                 * Creates an instance of this component which is automatically called by Angular.
                 *
                 * @param $scope The scope to which this component is bound.
                 * @param $element The element to which this component is bound.
                 * @param $timeout The Angular $timeout service used for synchronizing window timeout events.
                 */
                function NavigationComponent($scope, $element, $timeout) {
                    _super.call(this, $scope, $element);
                    // An array of our children; each child registers with us upon creation
                    this.children = new Array();
                    // Basic setup
                    this.setupDefaults();
                    this.setupBasicClass();
                    this.setupFirstItemClass($timeout);
                    // DOM setup
                    this.setMenuBottom();
                }
                /**
                 * Allows a child to register with this navigation component.
                 *
                 * @param child The child to be registered.
                 */
                NavigationComponent.prototype.registerChild = function (child) {
                    // Add the child to our array
                    this.children.push(child);
                };
                /**
                 * Deregisters a child so it no longer receives notifications.
                 *
                 * @param child The child to be deregistered.
                 */
                NavigationComponent.prototype.deregisterChild = function (child) {
                    this.children.splice(this.children.indexOf(child), 1);
                };
                /**
                 * All children of the navigation component call this method to activate themselves and let the component
                 * de-activate the other children.
                 */
                NavigationComponent.prototype.activateChild = function (activeChild) {
                    var toActivate = [], toDeactivate = [], self = this;
                    // Loop through all child items and see which ones should be active/inactive; coalesce for timing purposes rather
                    // than running animations in-line since this could be an expensive forEach loop
                    angular.forEach(this.children, function (item) {
                        if (item === activeChild || item.isAncestorOf(activeChild)) {
                            toActivate.push(item);
                        }
                        else {
                            toDeactivate.push(item);
                        }
                    });
                    // First, deactivate everything that should not be active
                    angular.forEach(toDeactivate, function (item) {
                        item.deactivate();
                    });
                    // Now, activate everything that should be active
                    angular.forEach(toActivate, function (item) {
                        item.activate();
                    });
                    self.$scope.$apply();
                };
                /**
                 * Setup our default variables.
                 */
                NavigationComponent.prototype.setupDefaults = function () {
                    // Set the default to not show active CSS (i.e. assume a regulatory product)
                    this.showActive = this.showActive || false;
                };
                /**
                 * Add a class so we can target this in the CSS.
                 */
                NavigationComponent.prototype.setupBasicClass = function () {
                    this.$element.addClass("ers-nav");
                };
                /**
                 * Add the first-item class to the first nav item in each group. This is necessary because the CSS first-child might
                 * be the nav-heading element. It also might not.
                 */
                NavigationComponent.prototype.setupFirstItemClass = function ($timeout) {
                    var _this = this;
                    // We run this in a $timeout with no wait so that it happens at the end of the run loop after the transclusion has
                    // finished. However, we do not need to run the digest loop, so we set it to false.
                    $timeout(function () {
                        _this.$element.find("ers-nav-group").each(function (i, group) {
                            $(group).find("ers-nav-item").first().addClass("first-item");
                        });
                    }, 0, false);
                };
                /**
                 * Set the menu's bottom property to equal the height of the footer so the entire menu is visible.
                 */
                NavigationComponent.prototype.setMenuBottom = function () {
                    var menu = this.$element.find(".menu");
                    var footer = this.$element.find(".footer");
                    menu.css({ "bottom": footer.outerHeight() });
                };
                /* Notify Angular of the resources we need */
                NavigationComponent.$inject = ["$scope", "$element", "$timeout"];
                return NavigationComponent;
            })(BaseComponent);
            navigation.NavigationComponent = NavigationComponent;
        })(navigation = components.navigation || (components.navigation = {}));
    })(components = ers.components || (ers.components = {}));
})(ers || (ers = {}));
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};





var ers;
(function (ers) {
    var components;
    (function (components) {
        var core;
        (function (core) {
            var DEFAULT_VALIDATION_RULES = ers.components.utility.DEFAULT_VALIDATION_RULES;
            /**
             * Component class which contains the commons behaviours between the form input (textbox, number, etc.).
             */
            var InputComponent = (function (_super) {
                __extends(InputComponent, _super);
                /**
                 * Constructor of the base input component.
                 *
                 * @param $element The component element.
                 * @param $timeout Angular timeout service. Currently used to execute a function when the model controller is fully loaded.
                 */
                function InputComponent($scope, $element, $attrs, $timeout, vm, $exceptionHandler) {
                    _super.call(this, $scope, $element, $attrs, $timeout, vm);
                    this.$exceptionHandler = $exceptionHandler;
                }
                /**
                 * Link function.
                 */
                InputComponent.prototype.link = function () {
                    this.inputComponent = this.$element.find("input");
                    this.setNgModelController(this.$element.controller("ngModel"));
                };
                /**
                 * Method used to configure specifics rendering. Can be override by sub components.
                 */
                InputComponent.prototype.configureRender = function () {
                    // Currently, nothing to do. Sub component can override this function to implements theirs own rendering.
                };
                /**
                 * Method used to configure specifics validators. Can be override by sub components.
                 */
                InputComponent.prototype.configParsers = function () {
                    // Currently, nothing to do. Sub component can override this function to implements theirs own $validators.
                };
                /**
                 * Method used to configure specifics event listeners. Can be override by sub components.
                 */
                InputComponent.prototype.configEventListeners = function () {
                    // Currently, nothing to do. Sub component can override this function to implements theirs own event listeners.
                };
                /**
                 * @Override from EditComponent#onNgModelCtrlLoaded.
                 * Method used to configure how to do when the the model controller is fully loaded.
                 */
                InputComponent.prototype.onNgModelCtrlLoaded = function () {
                    var _this = this;
                    _super.prototype.onNgModelCtrlLoaded.call(this);
                    // Sub component can override this function to implements all it need when the model controller is fully loaded
                    // ($modelValue and $viewValue).
                    // We must to link the input value (real time) change with the ngModel of the directive.
                    this.inputComponent.on("input", function () {
                        _this.ngModelController.$setViewValue(_this.inputComponent.val());
                    });
                    this._inputComponent.scope().$watch(function () { return _this.ngModelController.$error; }, function (newErrors, oldErrors) {
                        if (newErrors === oldErrors) {
                            return;
                        }
                        // check validators:
                        for (var name in _this.ngModelController.$validators) {
                            if (angular.isDefined(newErrors[name])) {
                                _this.ngModelController.$setValidity(name, !newErrors[name]);
                            }
                            else {
                                _this.ngModelController.$setValidity(name, true);
                            }
                        }
                    }, true);
                    // run validation to be sure that max, min... are taken into account first time
                    this.ngModelController.$validate();
                };
                /**
                 * Set the model controller.
                 * @param value The model controller.
                 */
                InputComponent.prototype.setNgModelController = function (value) {
                    _super.prototype.setNgModelController.call(this, value);
                    this.configParsers();
                    this.configureRender();
                };
                Object.defineProperty(InputComponent.prototype, "inputComponent", {
                    /**
                     * Get the input component.
                     * @returns {ng.IAugmentedJQuery} Returns the input component.
                     */
                    get: function () {
                        return this._inputComponent;
                    },
                    /**
                     * Set the new input component.
                     * @param value the new input component.
                     */
                    set: function (value) {
                        this._inputComponent = value;
                        this.configEventListeners();
                        // if inputComponent is set after textAlign property, updates the value.
                        this.applyTextAlign(this.textAlign);
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(InputComponent.prototype, "textAlign", {
                    /**
                     * Get the chosen alignment.
                     * @returns {string} Returns the chosen alignment (left, center or right).
                     */
                    get: function () {
                        return this._textAlign;
                    },
                    /**
                     * Set the chosen alignment, or left by default if the value is different than center or right.
                     * @param newTextAlign the chosen alignment.
                     */
                    set: function (newTextAlign) {
                        this.applyTextAlign(newTextAlign);
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * Apply text align to the underlyng input component.
                 * @param newTextAlign Text Align value.
                 */
                InputComponent.prototype.applyTextAlign = function (newTextAlign) {
                    if (this.inputComponent) {
                        this.inputComponent.removeClass("text-" + this.textAlign);
                    }
                    this._textAlign = newTextAlign;
                    if (InputComponent.TEXT_ALIGN_VALUES.indexOf(this.textAlign) !== -1) {
                        if (this.inputComponent) {
                            this.inputComponent.addClass("text-" + this.textAlign);
                        }
                    }
                    else {
                        // Default alignment.
                        this.setDefaultTextAlign();
                    }
                };
                /**
                 * This method was created in addition to the "set textAlign" setter in order to give the ability to override the
                 * default text align behaviours.
                 * Set the chosen alignment, or left by default if the value is different than center or right.
                 */
                InputComponent.prototype.setDefaultTextAlign = function () {
                    if (this.inputComponent) {
                        this.inputComponent.addClass("text-left");
                    }
                    this._textAlign = "left";
                };
                Object.defineProperty(InputComponent.prototype, "ngDisabled", {
                    /**
                     * This function is used to compute the disabled property depending of the read-only property.
                     * @returns Returns the computed disabled.
                     */
                    get: function () {
                        var isDisabled = true;
                        if (this.readOnly || !this._disabled) {
                            isDisabled = false;
                        }
                        return isDisabled;
                    },
                    /**
                     * Set the ng-disabled property with the user value.
                     * @param disabled The ng-disabled value to set.
                     */
                    set: function (disabled) {
                        this._disabled = disabled;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(InputComponent.prototype, "textPattern", {
                    /**
                     * Retrieves the text pattern constraint value.
                     * @returns {string} Returns the text pattern constraint value.
                     */
                    get: function () {
                        return this._textPattern;
                    },
                    /**
                     * Update the text pattern constraint value.
                     * @param value The text pattern constraint.
                     */
                    set: function (value) {
                        this._textPattern = value;
                        if (angular.isDefined(this.ngModelController)) {
                            this.ngModelController.$validate();
                            this.vm.reloadMessage(this);
                        }
                    },
                    enumerable: true,
                    configurable: true
                });
                // EditComponent override implementation begins
                InputComponent.prototype.focusedElement = function () {
                    return this.$element.find("input");
                };
                /**
                 * (@inherit)
                 */
                InputComponent.prototype.getTooltipDelegate = function (type) {
                    if (type === void 0) { type = ""; }
                    switch (type) {
                        case "focus":
                            return this.focusedElement();
                        default:
                            return this.$element;
                    }
                };
                /**
                 * @Override super method
                 */
                InputComponent.prototype.validationRules = function () {
                    var _this = this;
                    var inputRules = [];
                    // ngRequired validator.
                    inputRules.push(DEFAULT_VALIDATION_RULES.REQUIRED());
                    // ngPattern validator.
                    var patternRule = DEFAULT_VALIDATION_RULES.PATTERN(this.textPattern);
                    patternRule.validator = function (modelValue) {
                        var isValid = true;
                        if (angular.isDefined(_this.textPattern)) {
                            var patternRegExp = new RegExp("^" + _this.textPattern + "$");
                            isValid = patternRegExp.test(modelValue);
                        }
                        return isValid;
                    };
                    inputRules.push(patternRule);
                    return inputRules;
                };
                /** The authorized values for the text alignment. */
                InputComponent.TEXT_ALIGN_VALUES = ["left", "center", "right"];
                return InputComponent;
            })(core.EditComponent);
            core.InputComponent = InputComponent;
        })(core = components.core || (components.core = {}));
    })(components = ers.components || (ers.components = {}));
})(ers || (ers = {}));
var ers;
(function (ers) {
    var components;
    (function (components) {
        var core;
        (function (core) {
            var filters;
            (function (filters) {
                            })(filters = core.filters || (core.filters = {}));
        })(core = components.core || (components.core = {}));
    })(components = ers.components || (ers.components = {}));
})(ers || (ers = {}));

/**
 *
 * This module contains all of the ERS filters available for the all components.
 *
 */
var ers;
(function (ers) {
    var components;
    (function (components) {
        var core;
        (function (core) {
            var filters;
            (function (filters) {
                /* Creation of the module. */
                var filtersMod = angular.module("ers.components.core.filters", ["ers.components.core"]);
                /**
                 * Class which contains all the defaults settings and functions for formatting a number.
                 */
                var NumberFilters = (function () {
                    function NumberFilters() {
                    }
                    /**
                     * This function must be used to apply the user settings in this number filter in order to make accessible the
                     * default settings for the number.
                     */
                    NumberFilters.configureNumberSettings = function (settings) {
                        NumberFilters.DEFAULT_GROUP_SEP = settings.groupSep ? settings.groupSep : "";
                        NumberFilters.DEFAULT_DECIMAL_SEP = settings.decimalSep ? settings.decimalSep : "";
                        NumberFilters.DEFAULT_FRACTIONS_SIZE["amount"] = settings.amountFractionSize ? settings.amountFractionSize : 0;
                        NumberFilters.DEFAULT_FRACTIONS_SIZE["percentage"] = settings.percentageFractionSize ? settings.percentageFractionSize : 0;
                        NumberFilters.DEFAULT_FRACTIONS_SIZE["short_percentage"] =
                            settings.shortPercentageFractionSize ? settings.shortPercentageFractionSize : 0;
                        NumberFilters.DEFAULT_FRACTIONS_SIZE["basepoint"] = settings.bpFractionSize ? settings.bpFractionSize : 0;
                        NumberFilters.DEFAULT_FRACTIONS_SIZE["rate"] = settings.rateFractionSize ? settings.rateFractionSize : 0;
                    };
                    /**
                     *
                     * This function must be used to format the given number.
                     *
                     * @param toParsed The string number to format.
                     * @param groupSep The group separator (e.g.: 12,548,454.00).
                     * @param decimalSep The decimal separator.
                     * @returns {string} Returns a string number formatted if the 'toParsed' string can be converted into a number,
                     * undefined otherwise.
                     *
                     */
                    NumberFilters.formatNumber = function (toParsed, groupSep, decimalSep) {
                        var formatted;
                        var value = parseFloat(toParsed);
                        if (typeof value === "number" && !isNaN(value)) {
                            var begin = toParsed.indexOf("."); // Number decimal separator without formatting.
                            if (begin >= 0) {
                                // Below: (begin + 1) to replace the current decimal separator by the given one (decimalSep).
                                formatted = toParsed.substring(begin + 1, toParsed.length);
                                formatted = decimalSep + formatted;
                            }
                            else {
                                begin = toParsed.length;
                                formatted = "";
                            }
                            var nbElt = 0;
                            for (var i = begin - 1; i >= 0; i--) {
                                formatted = toParsed[i] + formatted;
                                nbElt++;
                                if (nbElt === 3 && (i - 1) >= 0) {
                                    nbElt = 0;
                                    formatted = groupSep + formatted;
                                }
                            }
                        }
                        return formatted;
                    };
                    /**
                     * Get the value with the chosen fraction size.
                     *
                     * @param value The value used to get the fraction.
                     *
                     * @param fractionSize The fraction size. The size can be less than zero, or, none.
                     *
                     * @param multiplier The multiplier applied to the value.
                     *
                     * @param numberType (Optional) Specify this parameter to allow a default fraction size
                     * to be configured in the user setting, if needed. The available settings are amount, percentage, basepoint and rate.
                     *
                     * @returns {string} Returns the fraction after having applied the multiplier and the fraction size.
                     * If fractionSize is less than 0 and no default value is configured, no fraction is calculated, and
                     * the (value * multiplier) is returned.
                     */
                    NumberFilters.getFraction = function (value, fractionSize, multiplier, numberType) {
                        if (numberType === void 0) { numberType = ""; }
                        var newValue = value * multiplier;
                        var defaultFractSize = NumberFilters.DEFAULT_FRACTIONS_SIZE[numberType];
                        if (angular.isDefined(fractionSize) && fractionSize >= 0) {
                            return newValue.toFixed(fractionSize);
                        }
                        else if (angular.isDefined(defaultFractSize) && defaultFractSize >= 0) {
                            return newValue.toFixed(defaultFractSize);
                        }
                        else {
                            return newValue.toString();
                        }
                    };
                    /**
                     *
                     * Get the decimal separator.
                     *
                     * @param decimalSep The proposed decimal separator.
                     * @returns {string} Returns the proposed decimal separator if valid, otherwise, the default separator.
                     *
                     */
                    NumberFilters.getDecimalSep = function (decimalSep) {
                        var decSep = decimalSep;
                        if (!decSep) {
                            decSep = NumberFilters.DEFAULT_DECIMAL_SEP;
                        }
                        return decSep;
                    };
                    /**
                     *
                     * Get the group separator.
                     *
                     * @param groupSep The proposed group separator.
                     *
                     * @returns {string} Returns the proposed group separator if valid, otherwise, the default separator.
                     *
                     */
                    NumberFilters.getGroupSep = function (groupSep) {
                        var gSep = groupSep;
                        if (!gSep) {
                            gSep = NumberFilters.DEFAULT_GROUP_SEP;
                        }
                        return gSep;
                    };
                    /** Default group separator. */
                    NumberFilters.DEFAULT_GROUP_SEP = ",";
                    /** Default decimal separator. */
                    NumberFilters.DEFAULT_DECIMAL_SEP = ".";
                    /** Array of the default fractions size. */
                    NumberFilters.DEFAULT_FRACTIONS_SIZE = {
                        "amount": 2, "percentage": 2, "short_percentage": 0, "basepoint": 7, "rate": 5
                    };
                    return NumberFilters;
                })();
                filters.NumberFilters = NumberFilters;
                /**
                 * Configuration of the NUmber Filter.
                 */
                filtersMod.filter("configureNumberFilters", function () {
                    return function (settings) {
                        NumberFilters.configureNumberSettings(settings);
                        return true;
                    };
                });
                /**
                 *
                 * The number of filters.
                 *
                 */
                filtersMod.filter("amount", function () {
                    return function (value, fractionSize, groupSep, decimalSep) {
                        return NumberFilters.formatNumber(NumberFilters.getFraction(value, fractionSize, 1, "amount"), NumberFilters.getGroupSep(groupSep), NumberFilters.getDecimalSep(decimalSep));
                    };
                });
                /**
                 *
                 * The percentage filter.
                 *
                 */
                filtersMod.filter("percentage", function () {
                    return function (value, fractionSize, groupSep, decimalSep) {
                        return NumberFilters.formatNumber(NumberFilters.getFraction(value, fractionSize, 100, "percentage"), NumberFilters.getGroupSep(groupSep), NumberFilters.getDecimalSep(decimalSep)) + " %";
                    };
                });
                /**
                 *
                 * The short percentage filter.
                 *
                 */
                filtersMod.filter("short_percentage", function () {
                    return function (value, fractionSize, groupSep, decimalSep) {
                        return NumberFilters.formatNumber(NumberFilters.getFraction(value, fractionSize, 100, "short_percentage"), NumberFilters.getGroupSep(groupSep), NumberFilters.getDecimalSep(decimalSep)) + " %";
                    };
                });
                /**
                 *
                 * The basepoint filter.
                 *
                 */
                filtersMod.filter("basepoint", function () {
                    return function (value, fractionSize, groupSep, decimalSep) {
                        return NumberFilters.formatNumber(NumberFilters.getFraction(value, fractionSize, 10000, "basepoint"), NumberFilters.getGroupSep(groupSep), NumberFilters.getDecimalSep(decimalSep)) + " bp";
                    };
                });
                /**
                 *
                 * The rate filter.
                 *
                 */
                filtersMod.filter("rate", function () {
                    return function (value, fractionSize, groupSep, decimalSep) {
                        return NumberFilters.formatNumber(NumberFilters.getFraction(value, fractionSize, 1, "rate"), NumberFilters.getGroupSep(groupSep), NumberFilters.getDecimalSep(decimalSep));
                    };
                });
            })(filters = core.filters || (core.filters = {}));
        })(core = components.core || (components.core = {}));
    })(components = ers.components || (ers.components = {}));
})(ers || (ers = {}));





var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var ers;
(function (ers) {
    var components;
    (function (components) {
        var numberbox;
        (function (numberbox) {
                        var KEY = ers.components.utility.KEY;
            var InputComponent = ers.components.core.InputComponent;
            var Checks = ers.components.utility.checks;
            angular.module("ers.components.numberbox", ["ers.components.core",
                "ers.components.core.filters",
                "ngMessages"]).directive("ersNumber", function () {
                return {
                    restrict: "E",
                    templateUrl: "numberbox/template/numberbox-template.html",
                    controller: NumberboxComponent,
                    controllerAs: "c",
                    bindToController: true,
                    scope: {
                        "name": "@",
                        "ngModel": "=",
                        "readOnly": "=?ngReadonly",
                        "ngDisabled": "=?",
                        "textAlign": "@?",
                        "min": "=?",
                        "max": "=?",
                        "exclusiveMin": "=?",
                        "exclusiveMax": "=?",
                        "minErrorMessage": "=?",
                        "maxErrorMessage": "=?",
                        "required": "=?ngRequired",
                        "format": "@?"
                    },
                    link: function ($scope, $element, $attrs, component) {
                        component.link();
                    }
                };
            });
            var DEFAULT_VALIDATION_RULES = ers.components.utility.DEFAULT_VALIDATION_RULES;
            /**
             *
             * @ngdoc directive
             * @name ersNumber
             * @restrict E
             * @module ers.components.numberbox
             * @scope
             *
             * @description
             *
             * Use the `ers-number` component to create a box accepting only numbers as input.
             *
             * ### Usage
             *
             * `ers-number` allows the following keyboard shortcuts for number formatting:
             *
             * - M or m for million
             * - B or b for billion
             * - K or k for thousand
             * - % for percentage
             * - BP, Bp, bP, or bp for basepoint
             *
             * ###  Examples
             *
             * #### Basic Usage
             *
             * <code-editor identifier="example1" data-title="Number" html-content-url="demos/ersNumber/basicUsage/index.html"
             * js-content-url="demos/ersNumber/basicUsage/script.js" css-content-url="demos/ersNumber/basicUsage/styles.css"
             * content-mode="html"></code-editor>
             *
             * #### Min-max value
             *
             * A numeric input field with demonstration of minimum and maximum values
             *
             * <code-editor identifier="example2" data-title="Min-max number"
             * html-content-url="demos/ersNumber/otherUsage/index.html"
             * js-content-url="demos/ersNumber/otherUsage/script.js" css-content-url="demos/ersNumber/otherUsage/styles.css"
             * content-mode="html"></code-editor>
             *
             * #### Formats
             *
             * Demonstration of different formats
             *
             * <code-editor identifier="example3" data-title="Min-max number"
             * html-content-url="demos/ersNumber/formatNumbers/index.html"
             * js-content-url="demos/ersNumber/formatNumbers/script.js"
             * css-content-url="demos/ersNumber/formatNumbers/styles.css"
             * content-mode="html"></code-editor>
             *
             * ###  Design Guidelines
             *
             * When designing the size of the numberbox, anticipate the end-user's maximum data input.
             *
             * ### Accessibility Guidelines
             *
             * No accessibility guidelines
             *
             * @param {expression} [ng-model] {=} Provides two-way data binding for changing the number value.
             *
             * @param {expression} [ng-change="expression"]{=?}
             *
             * Evaluates the number for user input changes and notifies scope immediately on change, unlike the JavaScript
             * onCharge event which only triggers at the end of a change.
             *
             * @param {boolean} [ng-disabled=false] {=?}
             *
             * Sets the disabled mode and is used in conjunction with the edit mode to prevent user entry in the specified
             * text box.
             *
             * @param {boolean} [ng-readonly=false] {=?} Sets the read-only mode.
             *
             * @param {boolean} [ng-required=false] {=?} Sets the numberbox value to required or not. The default is
             * not required.
             *
             * @param {number} [min] {=?} Defines the minimum value that the user can enter into the numberbox.
             *
             * @param {number} [max] {=?} Defines the maximum value that the user can enter into the numberbox.
             *
             * @param {boolean} [exclusive-min=false] {=?}  If set to true, MIN range constraint will be exclusive,
             * i.e. ]min, max]
             *
             * @param {boolean} [exclusive-max=false] {=?} If set to true, MAX range constraint will be exclusive,
             * i.e. [min, max[
             *
             * @param {string} [min-error-message=undefined] {=?} Overides default min error message.
             *
             * @param {string} [max-error-message=undefined] {=?} Overides default max error message.
             *
             * @param {string} [text-align=right] {@?} Sets the alignment of the text in the box. Available values
             * are right, left,
             * and center.
             * ```xml
             * <ers-number name="ersNumber" max="2025" min="1975"
             *             ng-model="ersNumber" text-align="center"> </ers-number>
             * ```
             *
             * @param {string} [format="amount"] {@?} Sets the number format attribute to either 'amount',
             * 'rate', 'short_percentage',
             * 'percentage' or 'basepoint'. The default value is "amount". Format shortcuts for the numberbox are:
             *
             * - M or m for million
             * - B or b for billion
             * - K or k for thousand
             * - % for percentage
             * - BP, Bp, bP, or bp for basepoint
             *
             */
            var NumberboxComponent = (function (_super) {
                __extends(NumberboxComponent, _super);
                /**
                 * Constructor.
                 * @param $element The component element.
                 * @param $filter The Angular filter service.
                 * @param $timeout The Angular timeout service. Currently used to execute a function when the model controller
                 * is fully loaded.
                 *
                 */
                function NumberboxComponent($scope, $element, $attrs, $filter, $timeout, vm, $exceptionHandler) {
                    _super.call(this, $scope, $element, $attrs, $timeout, vm, $exceptionHandler);
                    this.$filter = $filter;
                    // Set the numberbox CSS class.
                    $element.addClass("ers-number");
                }
                Object.defineProperty(NumberboxComponent.prototype, "ngModel", {
                    /**
                     *
                     * Get the ngModel directive, not the HTML input directive.
                     * @returns {number} Returns the ngModel directive.
                     *
                     */
                    get: function () {
                        return this._ngModelDirective;
                    },
                    /**
                     *
                     * Get the ngModel directive, not the HTML input directive.
                     * @param value The new value of the ngModel directive.
                     *
                     */
                    set: function (value) {
                        this._ngModelDirective = value;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(NumberboxComponent.prototype, "format", {
                    /**
                     *
                     * @returns {string} The current number format.
                     *
                     */
                    get: function () {
                        return this._format;
                    },
                    /**
                     *
                     *
                     * Set the current number format.
                     * @param value The format value. It takes its value among the following list:
                     * <li>rate</li>
                     * <li>amount</li>
                     * <li>percentage</li>
                     * <li>currency</li>
                     * <li>basepoint</li>
                     *
                     * If an unexpected value is provided, the default value "amount" will be used.
                     *
                     */
                    set: function (value) {
                        var indexOf = NumberboxComponent.AVAILABLE_FORMAT.indexOf(value);
                        if (indexOf < 0) {
                            // Configure the format with the default format.
                            this._format = NumberboxComponent.DEFAULT_FORMAT;
                        }
                        else {
                            // Configure the format with the given one.
                            this._format = value;
                        }
                        // Apply the configured format.
                        if (this.ngModelController && this.isNumber(this.ngModelController.$modelValue)) {
                            this.ngModelController.$render();
                        }
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 *
                 *
                 * This method was created to override
                 * of the default text align behavior. It is in addition to the "set textAlign" setter and sets the chosen
                 * alignment value if the value is not center or right.
                 *
                 *
                 *
                 */
                NumberboxComponent.prototype.setDefaultTextAlign = function () {
                    if (this.inputComponent) {
                        this.inputComponent.addClass("text-right");
                    }
                    this._textAlign = "right";
                };
                /**
                 * @Override from InputComponent#configParsers.
                 * The method used to configure specific parsers.
                 */
                NumberboxComponent.prototype.configParsers = function () {
                    var _this = this;
                    _super.prototype.configParsers.call(this);
                    this.ngModelController.$parsers.push(function (value) {
                        return value === null || value.length === 0 || angular.isUndefined(value)
                            ? ""
                            : parseFloat(_this.parseValue(value));
                    });
                };
                /**
                 * @Override from InputComponent#onNgModelCtrlLoaded.
                 * The method used to configure what to do when the the model controller is fully loaded.
                 */
                NumberboxComponent.prototype.onNgModelCtrlLoaded = function () {
                    _super.prototype.onNgModelCtrlLoaded.call(this);
                    this.ngModelController.$render();
                };
                /**
                 * @Override from InputComponent#configEventListeners.
                 * The method used to configure event listeners.
                 */
                NumberboxComponent.prototype.configEventListeners = function () {
                    var _this = this;
                    _super.prototype.configEventListeners.call(this);
                    this.inputComponent.on("keydown", function (event) {
                        if (event.keyCode === KEY.ESCAPE) {
                            // Resets to untouched
                            _this.ngModelController.$setUntouched();
                            _this.inputComponent.val(_this.storedModelValue);
                            _this.ngModelController.$setViewValue(_this.storedModelValue);
                            _this.ngModelController.$render();
                            event.preventDefault();
                            event.stopImmediatePropagation();
                        }
                        else if (event.keyCode === KEY.ENTER) {
                            _this.transformation();
                        }
                        else {
                            if (_this.ngModelController.$untouched) {
                                _this.ngModelController.$setTouched();
                            }
                        }
                    });
                    this.$element.bind("focusout", function () {
                        _this.hasFocus = false;
                        // focus is lost => displayed the formated value in the input
                        _this.ngModelController.$render();
                    });
                    this.$element.bind("focusin", function () {
                        _this.hasFocus = true;
                        if (_this.ngModelController.$touched) {
                            _this.ngModelController.$setUntouched();
                        }
                        // save current value to be able to restore it when pressing escape key
                        if (_this.ngModelController.$valid) {
                            // value is valid => we save the viewValue of the controller
                            // the value is parsed to avoid displaying a shortcut (ex: 10k) if the last value
                            // entered was a value with a shortcut
                            _this.ngModelController.$viewValue = _this.parseValue(_this.ngModelController.$viewValue);
                            _this.storedModelValue = _this.ngModelController.$viewValue;
                        }
                        else {
                            // value is not valid => we save the value of the input because the viewValue is empty
                            _this.storedModelValue = _this.inputComponent.val();
                        }
                        _this.ngModelController.$render();
                    });
                };
                /**
                 * This function transforms the number entered into the number entered plus any
                 * formatting (number type parsing and filtering, plus formatting).
                 *
                 */
                NumberboxComponent.prototype.transformation = function () {
                    if (angular.isDefined(this.ngModelController)) {
                        var md = this.ngModelController.$modelValue;
                        // Convert the viewValue into a "real" value that will be computed from the key facilities.
                        if (this.isNumber(md)) {
                            this.computeViewValue();
                            this.ngModelController.$render();
                        }
                    }
                };
                /**
                 *
                 * @Override from InputComponent#configureRender.
                 * The method used to configure specific rendering.
                 *
                 */
                NumberboxComponent.prototype.configureRender = function () {
                    var _this = this;
                    _super.prototype.configureRender.call(this);
                    this.ngModelController.$render = function () {
                        var display;
                        if (_this.hasFocus) {
                            // the component has the focus => the displayed value is the complete number without any format
                            // => display the view value (number in string representation)
                            display = _this.ngModelController.$viewValue;
                        }
                        else {
                            // the component does not have the focus => the displayed value should be formatted in the input
                            if (_this.isFormatable()) {
                                // value is a number => format it!
                                var format = _this.format ? _this.format : NumberboxComponent.DEFAULT_FORMAT;
                                display = _this.$filter(format)(parseFloat(_this.ngModelController.$modelValue));
                            }
                            else {
                                // value not a valid number => show value without formatting
                                display = _this.ngModelController.$viewValue;
                            }
                        }
                        // update the input value and not the viewValue
                        // why? because this value should not be taken into account by angular (ngModelController)
                        // to avoid error when submitting a form (a $commitViewValue is triggered and validation fails
                        // because the value is already formatted!
                        _this.inputComponent.val(display);
                    };
                };
                /**
                 *
                 * Update the model view value with the view value entered by the user and check to see if any shortcuts
                 * are available.
                 *
                 */
                NumberboxComponent.prototype.computeViewValue = function () {
                    this.ngModelController.$setViewValue(this.parseValue(this.ngModelController.$viewValue));
                };
                /**
                 *
                 * This function parses the given value.
                 * @param value {string} The value to parse.
                 * @returns {string} Returns the parsed value, null if the given value is invalid.
                 *
                 */
                NumberboxComponent.prototype.parseValue = function (value) {
                    if (value === null || angular.isUndefined(value) || value.length === 0) {
                        return null;
                    }
                    var groups = NumberboxComponent.NUMBER_REGEXP_BASE.exec(value);
                    if (groups === null) {
                        return null;
                    }
                    var sign = groups[1];
                    var shortcut = groups[5];
                    var parsedNumber;
                    if (angular.isDefined(shortcut)) {
                        parsedNumber = NumberboxComponent.AUTHORIZED_SHORTCUTS[shortcut](parseFloat(groups[2]));
                    }
                    else {
                        // There is no shortcuts: no conversion to do.
                        parsedNumber = groups[2];
                    }
                    if (sign === "-") {
                        parsedNumber = "-" + parsedNumber;
                    } // else (sign === "+"): nothing to do.
                    return parsedNumber;
                };
                /**
                 * Apply the "basepoint" format.
                 * @param value The value on which the format is applied.
                 * @returns {string} Returns the value formatted from the given value.
                 */
                NumberboxComponent.applyBasepointFormat = function (value) {
                    return (value !== 0 ? value / 10000 : 0).toString();
                };
                /**
                 * Apply the "percentage" format.
                 * @param value The value on which the format is applied.
                 * @returns {string} Returns the value formatted from the given value.
                 */
                NumberboxComponent.applyPercentageFormat = function (value) {
                    return (value !== 0 ? value / 100 : 0).toString();
                };
                /**
                 * Apply the "thousands" format.
                 * @param value The value on which the format is applied.
                 * @returns {string} Returns the value formatted from the given value.
                 */
                NumberboxComponent.applyThousandFormat = function (value) {
                    return (value * 1000).toString();
                };
                /**
                 * Apply the "millions" format.
                 * @param value The value on which the format is applied.
                 * @returns {string} Returns the value formatted from the given value.
                 */
                NumberboxComponent.applyMillionFormat = function (value) {
                    return (value * 1000000).toString();
                };
                /**
                 * Apply the "billions" format.
                 * @param value The value on which the format is applied.
                 * @returns {string} Returns the value formatted from the given value.
                 */
                NumberboxComponent.applyBillionFormat = function (value) {
                    return (value * 1000000000).toString();
                };
                /**
                 * This function test if the given string value is a number representation.
                 * @param value The value to test.
                 * @returns Returns `true` if the value is a string number representation, false otherwise.
                 */
                NumberboxComponent.prototype.isNumber = function (value) {
                    return NumberboxComponent.NUMBER_REGEXP_BASE.test(value);
                };
                /**
                 * This function verifies whether or not the modelValue can be formatted.
                 * @returns {boolean} Returns true if the model value can be formatted, otherwise false.
                 */
                NumberboxComponent.prototype.isFormatable = function () {
                    return angular.isDefined(this.ngModelController) && angular.isDefined(this.ngModelController.$modelValue)
                        && !isNaN(this.ngModelController.$modelValue) && this.ngModelController.$modelValue !== "";
                };
                /**
                 *
                 * @Override from InputComponent#validationRules.
                 * The method used to configure validation rules.
                 *
                 */
                NumberboxComponent.prototype.validationRules = function () {
                    var _this = this;
                    var numberRule = DEFAULT_VALIDATION_RULES.NUMBER();
                    numberRule.validator = function (modelValue, viewValue) {
                        // if user hasn't made any modification on the input, input is considered has valid.
                        if ((angular.isDefined(_this.ngModelController) && _this.ngModelController.$pristine) ||
                            Checks.isEmpty(modelValue)) {
                            return true;
                        }
                        var isNum = Checks.isNumber(modelValue);
                        var val = NaN;
                        if (!isNum) {
                            // Try to convert string to number if model coming as a string.
                            val = parseFloat(_this.parseValue(modelValue));
                        }
                        else {
                            val = modelValue;
                        }
                        return !isNaN(val);
                    };
                    var rangeRule = DEFAULT_VALIDATION_RULES.NUMBER_RANGE(this.min, this.max, this.exclusiveMin, this.exclusiveMax, this.minErrorMessage, this.maxErrorMessage);
                    rangeRule.validator = function (modelValue, viewValue) {
                        var valid = false;
                        if (angular.isUndefined(_this.ngModelController) || Checks.isEmpty(modelValue)) {
                            // If the modelValue is not provided, it's not necessary to validate the range constraint.
                            // In this case, the input must not be in error.
                            valid = true;
                        }
                        else {
                            // Model can be string or number depending on what is coming from ngmodel.
                            // When editing, through parsing, we also receive a number or NaN.
                            // Firstly check against number type.
                            var isNum = Checks.isNumber(modelValue);
                            var val = NaN;
                            if (!isNum) {
                                // Try to convert string to number if model coming as a string.
                                val = parseFloat(_this.parseValue(modelValue));
                            }
                            else {
                                val = modelValue;
                            }
                            if (!isNaN(val)) {
                                // value is a number, now we verify if this number respects the range constraint.
                                valid = _this.validator(val);
                            }
                        }
                        return valid;
                    };
                    return _super.prototype.validationRules.call(this).concat([numberRule, rangeRule]);
                };
                NumberboxComponent.prototype.validator = function (val) {
                    if (this.exclusiveMin) {
                        if (angular.isDefined(this.min) && (val <= this.min)) {
                            return false;
                        }
                    }
                    else {
                        if (angular.isDefined(this.min) && (val < this.min)) {
                            return false;
                        }
                    }
                    if (this.exclusiveMax) {
                        if (angular.isDefined(this.max) && (val >= this.max)) {
                            return false;
                        }
                    }
                    else {
                        if (angular.isDefined(this.max) && (val > this.max)) {
                            return false;
                        }
                    }
                    return true;
                };
                Object.defineProperty(NumberboxComponent.prototype, "min", {
                    /**
                     *
                     * @returns {number} Minimum value.
                     *
                     */
                    get: function () {
                        return this._min;
                    },
                    /**
                     * Sets the minimum value.
                     * @param value The value to set.
                     */
                    set: function (value) {
                        if (typeof value === "number") {
                            this._min = value;
                        }
                        else {
                            // case when the value change from a valid value to an empty value (empty string), the type of value is "string".
                            this._min = undefined;
                        }
                        var n = this.ngModelController;
                        if (n) {
                            n.$validate();
                            this.vm.reloadMessage(this);
                        }
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(NumberboxComponent.prototype, "max", {
                    /**
                     * @returns {number} Maximum value.
                     */
                    get: function () {
                        return this._max;
                    },
                    /**
                     * Sets the maximum value.
                     * @param value The value to set.
                     */
                    set: function (value) {
                        if (typeof value === "number") {
                            this._max = value;
                        }
                        else {
                            // case when the value change from a valid value to an empty value (empty string), the type of value is "string".
                            this._max = undefined;
                        }
                        var n = this.ngModelController;
                        if (n) {
                            n.$validate();
                            this.vm.reloadMessage(this);
                        }
                    },
                    enumerable: true,
                    configurable: true
                });
                /** The default format. */
                NumberboxComponent.DEFAULT_FORMAT = "amount";
                /**
                 * Authorized keyboard shortcuts.
                 */
                NumberboxComponent.AUTHORIZED_SHORTCUTS = {
                    "m": NumberboxComponent.applyMillionFormat,
                    "M": NumberboxComponent.applyMillionFormat,
                    "b": NumberboxComponent.applyBillionFormat,
                    "B": NumberboxComponent.applyBillionFormat,
                    "k": NumberboxComponent.applyThousandFormat,
                    "K": NumberboxComponent.applyThousandFormat,
                    "%": NumberboxComponent.applyPercentageFormat,
                    "bp": NumberboxComponent.applyBasepointFormat,
                    "BP": NumberboxComponent.applyBasepointFormat,
                    "Bp": NumberboxComponent.applyBasepointFormat,
                    "bP": NumberboxComponent.applyBasepointFormat
                };
                /** A string that represents a number and is used inside of NUMBER RegExp. */
                NumberboxComponent.RE_NUMBER_PART = "([+-]?)([0-9]+([.]?[0-9]+)?)";
                /**
                 * REGEXP is used to parse the string to determine if the type of number number.
                 * Groups[0] = "([+-]?)([0-9]*([.]?[0-9]+)?)( ?(authorizedShortKey))?"
                 * Groups[1] = "[+-]?"
                 * Groups[2] = "[0-9]*([.]?[0-9]+)?"
                 * Groups[3] = "[.]?[0-9]+"
                 * Groups[4] = " ?(authorizedShortKey)"
                 * Groups[5] = authorizedShortKey => Sample: "m|M|b|B|k|K|%|bp|BP|bP|Bp"
                 */
                NumberboxComponent.NUMBER_REGEXP_BASE = new RegExp("^" + NumberboxComponent.RE_NUMBER_PART + "( ?(" +
                    Object.keys(NumberboxComponent.AUTHORIZED_SHORTCUTS).join("|") +
                    "))?$");
                /**
                 *
                 *  The array containing the appropriate format for the ers-number element.
                 *
                 */
                NumberboxComponent.AVAILABLE_FORMAT = [NumberboxComponent.DEFAULT_FORMAT,
                    "rate",
                    "percentage",
                    "short_percentage",
                    "basepoint"];
                NumberboxComponent.$inject = ["$scope", "$element", "$attrs", "$filter", "$timeout", "validationManager",
                    "$exceptionHandler"];
                return NumberboxComponent;
            })(InputComponent);
            numberbox.NumberboxComponent = NumberboxComponent;
        })(numberbox = components.numberbox || (components.numberbox = {}));
    })(components = ers.components || (ers.components = {}));
})(ers || (ers = {}));






var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var BaseComp = ers.components.core.BaseComponent;
var ers;
(function (ers) {
    var components;
    (function (components) {
        var panel;
        (function (panel) {
                        /**
             * @ngdoc directive
             * @module ers.components.panel
             * @scope
             * @transclude
             * @data
             * @binding
             * @name ersPanel
             * @restrict E
             * @constructor
             *
             * @description
             *
             * <p class="lead">A panel allows you to easily outline sections of your page.</p>
             *
             * - A Panel consists of a panel header and panel body.
             * - The panel header should contain the heading for the panel.
             * - The panel body should contain any HTML content (including other components).
             *
             * ### Usage
             *
             * - Use <b>Standard Panels</b> when you have a simple text heading and no custom action icons.
             * - Use <b>Custom Panels</b> when you need a custom header which can contain any HTML or other components.
             *
             * ### Examples
             *
             * #### Standard Panel
             *
             * Example of standard panel with a string passed for the heading attribute.
             *
             * <code-editor identifier="example1" data-title="Standard Panel" html-content-url="demos/ersPanel/default/index.html"
             * js-content-url="demos/ersPanel/default/script.js" css-content-url="demos/ersPanel/default/styles.css"
             * content-mode="html"></code-editor>
             *
             * #### Custom Panel:
             *
             * Example of a panel with a custom header. You must place all ers-panel-header and ers-panel-body tags within the parent ers-panel.
             *
             * <code-editor identifier="example4" data-title="Standard Panel with Custom Heading" html-content-url="demos/ersPanel/custom/index.html"
             * js-content-url="demos/ersPanel/custom/script.js" css-content-url="demos/ersPanel/custom/styles.css"
             * content-mode="html"></code-editor>
             *
             * #### Default Closed State:
             *
             * <code-editor identifier="example2" data-title="Standard Panel with Closed State" html-content-url="demos/ersPanel/closed/index.html"
             * js-content-url="demos/ersPanel/closed/script.js" css-content-url="demos/ersPanel/closed/styles.css"
             * content-mode="html"></code-editor>
             *
             * #### Collapse Set to False:
             *
             * <code-editor identifier="example3" data-title="Standard Panel with Collapsible State Set to False" html-content-url="demos/ersPanel/
             * collapseFalse/index.html"
             * js-content-url="demos/ersPanel/collapseFalse/script.js" css-content-url="demos/ersPanel/collapseFalse/styles.css"
             * content-mode="html"></code-editor>
             *
             * ### Design Guidelines
             *
             * No design guidelines.
             *
             * ### Accessibility Guidelines
             *
             * No accessibility guidelines.
             *
             * @param {string} [heading] {@?}
             * Default: 'none'. You can set the text for the panel header with the 'heading' attribute.
             * When setting the heading this way, it must be a string.
             * If you would like to include HTML markup in your 'panel-heading' please use "Option #2".
             *
             * @param {boolean} [collapsible=true] {=?}
             * Default: 'true'. If you would like to remove the toggle functionality you can add this
             * attribute with the value of 'false'.
             *
             * @param {boolean} [closed=false] {=?}
             * Default: 'false'. Control whether an 'ers-panel' is closed by default. Add this attribute with the
             * value of 'true' to close the 'panel-body'.
             *
             * @param {string} [panel-body-height] {@?}
             * Sets the height of the panel body in pixels
             *
             */
            angular.module("ers.components.panel", ["ers.components.core", "ui.bootstrap.collapse"])
                .directive("ersPanel", ["containerEventService", function (containerEventService) {
                    return {
                        restrict: "E",
                        transclude: true,
                        replace: true,
                        scope: {
                            closed: "=?",
                            panelClass: "@?",
                            header: "@?",
                            collapsible: "=?"
                        },
                        templateUrl: function (element, attrs) {
                            if (attrs["header"]) {
                                //if the user passes the heading as an attribute use this template
                                return "panel/template/panel-template.html";
                            }
                            else {
                                //if the user does not pass the heading as an attribute. but uses the 'ersPanelHeader', then use this template
                                return "panel/template/panel-custom-template.html";
                            }
                        },
                        bindToController: true,
                        controller: PanelComponent,
                        controllerAs: "ctrl"
                    };
                }]);
            //this is the controller for the 'ersPanel' wrapper, this controller is required by the nested 'ersPanelHeader'
            // and 'ersPanelBody'.
            var PanelComponent = (function (_super) {
                __extends(PanelComponent, _super);
                /**
                 *
                 * @param $scope scope
                 * @param $element element
                 * @param eventService the event service.
                 */
                function PanelComponent($scope, $element, windowService, eventService) {
                    var _this = this;
                    _super.call(this, $scope, $element);
                    /**
                     * true if the panel is resizing.
                     */
                    this.resizing = false;
                    if (!angular.isDefined(this.collapsible)) {
                        this.collapsible = true;
                    }
                    if (this.closed) {
                        this.display = window.getComputedStyle(this.$element[0]).getPropertyValue("display");
                        this.$element[0].style.display = "none";
                    }
                    // resize events registration.
                    windowService.registerListener(this);
                    this.eventService = eventService;
                    eventService.registerDispatcher("collapse", $scope);
                    // get the user defined element height if exists
                    if (this.$element.css("visibility") !== "hidden") {
                        this.panelHeight = this.computePanelHeight();
                    }
                    //watch element resize : case if the element is directly rezised
                    // (element height changed dynamically or element is closed/open)
                    $scope.$watch(function () {
                        return $element.height();
                    }, function (newValue, oldValue) {
                        // if a specific height is defined on the element and the element height is changing
                        if (newValue !== oldValue && _this.panelHeight != null) {
                            // if the resizing process isn't started : process the size
                            if (!_this.resizing) {
                                // 1st case : panel is closed
                                if (_this.closed) {
                                    // keep the current panel height to resize the panel during the next panel open toggle.
                                    var height = _this.computePanelHeight();
                                    _this.panelHeight = height !== null ? height : _this.panelHeight;
                                    // if panel height became < header height : resize the panel.
                                    var realSize = _this.elementHeightInPixels();
                                    if (realSize < _this.$element.children(".panel-heading")[0].offsetHeight) {
                                        _this.resizing = true;
                                        _this.$element.height(realSize);
                                    }
                                    else {
                                        _this.$element.height("auto");
                                    }
                                }
                                else {
                                    setTimeout(function () {
                                        _this.resizeDidOccur();
                                    }, 0);
                                }
                            }
                            else {
                                _this.resizing = false;
                            }
                        }
                        else {
                            // if  the element height is not changing (element initialisation)
                            // get the user defined element height if exists and executes a resize of the body to apply this size.
                            setTimeout(function () {
                                if (!_this.closed && _this.$element.css("visibility") !== "hidden") {
                                    // user defined height exists : resize the body.
                                    if (_this.panelHeight !== null) {
                                        _this.resizeDidOccur();
                                    }
                                }
                            }, 0);
                        }
                    });
                }
                /**
                 * compute the element size compare to this parent size.
                 * @returns {number} size in px.
                 */
                PanelComponent.prototype.elementHeightInPixels = function () {
                    return this.$element.parent().height() * (parseInt(this.panelHeight, 0) / 100);
                };
                /**
                 * get the "exact" panel height value (not the computed one in px).
                 * Manage the pixel, percent sizes defined inline (style attribute) or inside a css class.
                 * @returns {string} the "exact" panel height value.
                 */
                PanelComponent.prototype.computePanelHeight = function () {
                    var panelHeight = null;
                    if (this.$element && this.$element.parent()) {
                        // the only way to obtain the height value as defined in the style, is to hide the panel parent :
                        // this hack avoids to get the computed size in px. Cloning the panel parent before hding it is a better solution,
                        // but doesn't work with IE...
                        var element = this.$element[0];
                        var display = window.getComputedStyle(element).getPropertyValue("display");
                        element.style.display = "none";
                        panelHeight = window.getComputedStyle(element).getPropertyValue("height");
                        element.style.display = display;
                    }
                    // only return value if different from "auto" (auto is the normal panel behaviour)
                    return panelHeight !== "auto" ? panelHeight : null;
                };
                /**
                 *  this will toggle the panel if the element is not disabled
                 */
                PanelComponent.prototype.toggle = function () {
                    this.closed = !this.closed;
                };
                Object.defineProperty(PanelComponent.prototype, "closed", {
                    /**
                     *
                     * @returns {boolean} true if the panel is closed
                     */
                    get: function () {
                        return this._closed;
                    },
                    /**
                     *
                     * @param closed true if the panel is closed
                     */
                    set: function (closed) {
                        var _this = this;
                        var emitEvent = false;
                        if (closed !== undefined && closed !== this._closed) {
                            emitEvent = true;
                        }
                        this._closed = closed;
                        // if panel has a specific height :
                        setTimeout(function () {
                            if (_this.$element) {
                                if (_this.panelHeight != null) {
                                    var height = _this.computePanelHeight();
                                    // 1st case : panel is closed => keep the specified height for the open case and apply "auto" height
                                    if (closed) {
                                        // avoid to replace specified height by "auto"
                                        if (height !== null && height !== "auto" && height !== "0px") {
                                            _this.panelHeight = height;
                                        }
                                        _this.$element.height("auto");
                                    }
                                    else if (_this.panelHeight !== height) {
                                        _this.$element.css("height", _this.panelHeight);
                                        setTimeout(function () {
                                            var body = _this.$element.children(".panel-collapse");
                                            body.css("height", "auto");
                                        }, 0);
                                    }
                                }
                                // restore the initial element display
                                _this.$element[0].style.display = _this.display;
                                // emit an event to tell parent the  size has changed
                                if (emitEvent) {
                                    _this.$scope.$emit("panel-collapsed");
                                }
                            }
                        }, 0);
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * if a panel resize occur and if there is a specific height on the panel ,
                 * we have to compute the new panel body height.
                 */
                PanelComponent.prototype.resizeDidOccur = function () {
                    if (this.panelHeight != null) {
                        // indicate we are resizing, to avoid multiple digest cycle (the resize trigger a new resize event ...)
                        var body = this.$element.children().children(".panel-body");
                        var header = this.$element.children(".panel-heading");
                        if (body.length > 0) {
                            this.resizing = true;
                            var headerHeight = 0;
                            if (header.length > 0) {
                                // Header height
                                headerHeight = header[0].offsetHeight;
                            }
                            // body height : Panel inner height - body offsets height - header height
                            this.bodyOffsetHeight = body[0].offsetHeight > 0 ? body[0].offsetHeight - body.height() :
                                (this.bodyOffsetHeight ? this.bodyOffsetHeight : 0);
                            var bodyHeight = this.$element.innerHeight() - this.bodyOffsetHeight - headerHeight;
                            body.height(bodyHeight);
                        }
                    }
                };
                Object.defineProperty(PanelComponent.prototype, "panelHeight", {
                    /**
                     * panel height getter.
                     * @returns {string}
                     */
                    get: function () {
                        return this._panelHeight;
                    },
                    /**
                     * panel height setter.
                     * @param height
                     */
                    set: function (height) {
                        var _this = this;
                        this._panelHeight = height;
                        if (height !== undefined && height !== null) {
                            setTimeout(function () {
                                var body = _this.$element.children().children(".panel-body");
                                body.css("overflow-y", "auto");
                            }, 0);
                        }
                    },
                    enumerable: true,
                    configurable: true
                });
                //inject
                PanelComponent.$inject = ["$scope", "$element", "ResizeService", "containerEventService"];
                return PanelComponent;
            })(BaseComp);
            panel.PanelComponent = PanelComponent;
        })(panel = components.panel || (components.panel = {}));
    })(components = ers.components || (ers.components = {}));
})(ers || (ers = {}));







var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var BaseC = ers.components.core.BaseComponent;
var ers;
(function (ers) {
    var components;
    (function (components) {
        var panel;
        (function (panel) {
                        angular.module("ers.components.panel")
                .directive("ersPanelBody", function () {
                return {
                    restrict: "E",
                    require: ["^ersPanel"],
                    templateUrl: "panel/template/panel-body.html",
                    transclude: true,
                    replace: true,
                    link: function (scope, element, attrs, ctrl) {
                        element.inheritedData().$ersPanelBodyController.panelController = ctrl[0];
                    },
                    bindToController: true,
                    controller: PanelBodyComponent,
                    controllerAs: "bodyCtrl"
                };
            });
            /**
             *  this is the controller for the 'ersPanelBody'
             */
            var PanelBodyComponent = (function (_super) {
                __extends(PanelBodyComponent, _super);
                /**
                 * constructor
                 * @param $scope the scope
                 * @param $element the element
                 */
                function PanelBodyComponent($scope, $element) {
                    _super.call(this, $scope, $element);
                }
                /**
                 *
                 * @returns {boolean} true if the panel is closed
                 */
                PanelBodyComponent.prototype.closed = function () {
                    return this.panelController ? this.panelController["closed"] : false;
                };
                Object.defineProperty(PanelBodyComponent.prototype, "panelClass", {
                    /**
                     *
                     * @returns {string} the panel class.
                     */
                    get: function () {
                        return this.panelController["panelClass"];
                    },
                    enumerable: true,
                    configurable: true
                });
                PanelBodyComponent.$inject = ["$scope", "$element"];
                return PanelBodyComponent;
            })(BaseC);
            panel.PanelBodyComponent = PanelBodyComponent;
        })(panel = components.panel || (components.panel = {}));
    })(components = ers.components || (ers.components = {}));
})(ers || (ers = {}));






var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var BaseCompo = ers.components.core.BaseComponent;
var ers;
(function (ers) {
    var components;
    (function (components) {
        var panel;
        (function (panel) {
                        angular.module("ers.components.panel")
                .directive("ersPanelHeader", function () {
                return {
                    restrict: "E",
                    require: ["^ersPanel"],
                    templateUrl: "panel/template/panel-header.html",
                    transclude: true,
                    replace: true,
                    bindToController: true,
                    controller: PanelHeaderComponent,
                    controllerAs: "headerCtrl",
                    link: function ($scope, element, attrs, ctrl) {
                        element.inheritedData().$ersPanelHeaderController.panelController = ctrl[0];
                    }
                };
            });
            /**
             *  this is the controller for the 'ersPanelBody'
             */
            var PanelHeaderComponent = (function (_super) {
                __extends(PanelHeaderComponent, _super);
                /**
                 * constructor
                 * @param $scope the scope
                 * @param $element the element
                 */
                function PanelHeaderComponent($scope, $element) {
                    _super.call(this, $scope, $element);
                }
                Object.defineProperty(PanelHeaderComponent.prototype, "closed", {
                    /**
                     *
                     * @returns {boolean} true if the panel is collapsed.
                     */
                    get: function () {
                        return this.panelController["closed"];
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(PanelHeaderComponent.prototype, "collapsible", {
                    /**
                     *
                     * @returns {boolean} true if the panel is collapsible.
                     */
                    get: function () {
                        return this.panelController["collapsible"];
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 *  this will toggle the panel if the element is not disabled
                 */
                PanelHeaderComponent.prototype.toggle = function () {
                    this.panelController["toggle"]();
                };
                PanelHeaderComponent.$inject = ["$scope", "$element"];
                return PanelHeaderComponent;
            })(BaseCompo);
            panel.PanelHeaderComponent = PanelHeaderComponent;
        })(panel = components.panel || (components.panel = {}));
    })(components = ers.components || (ers.components = {}));
})(ers || (ers = {}));
/**
 * The data scope for the [[RadioButtonDirective]].
 */
/**
 * The data scope for the [[RadioGroupDirective]].
 */
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};






/**
 * ERS Angular Controller: RadioGroupComponent.
 */
var ers;
(function (ers) {
    var components;
    (function (components) {
        var radioButtons;
        (function (radioButtons) {
                        var KEY = ers.components.utility.KEY;
            var DEFAULT_VALIDATION_RULES = ers.components.utility.DEFAULT_VALIDATION_RULES;
            var EditComponent = ers.components.core.EditComponent;
            /**
             * Radio button group controller.
             */
            var RadioGroupComponent = (function (_super) {
                __extends(RadioGroupComponent, _super);
                /**
                 *
                 * Constructor.
                 * @param $scope The component scope.
                 *
                 * @param $attrs The directive attributes.
                 *
                 */
                function RadioGroupComponent($scope, $element, $attrs, $timeout, vm) {
                    _super.call(this, $scope, $element, $attrs, $timeout, vm);
                    this.radioButtonControllers = [];
                    this.disabled = $scope.disabled;
                    this.readonly = $scope.readonly;
                    this.required = $scope.required;
                    this.lastTabIndex = this.$element.attr("tabindex") || "0";
                    this.configureObservers();
                }
                /**
                 *
                 * Configures the directive attribute observers for key down events, and read only, disabled, and required states.
                 *
                 * @param $attrs Directive attributes.
                 */
                RadioGroupComponent.prototype.configureObservers = function () {
                    var _this = this;
                    // Observe the keydown event.
                    this.$element.on("keydown", function (ev) {
                        if (!_this.disabled && _this.isRadioButtonEnabled()) {
                            _this.keydownListener(ev);
                        }
                    });
                    // Observe the "readonly" property state.
                    this.$attrs.$observe("readonly", function (newValue) {
                        var needRender = true;
                        if ((_this.readonly === newValue) || (newValue === false && _this.readonly === undefined)) {
                            // In this case, the UI does not need to be refreshed.
                            needRender = false;
                        }
                        _this.readonly = newValue;
                        if (needRender) {
                            _this.render();
                            _this.updateTabIndex();
                        }
                    });
                    // Observe the "disabled" property state.
                    this.$attrs.$observe("disabled", function (newValue) {
                        var needRender = true;
                        if ((_this.disabled === newValue) || (newValue === false && _this.disabled === undefined)) {
                            // In this case, the UI does not need to be refreshed.
                            needRender = false;
                        }
                        _this.disabled = newValue;
                        if (needRender) {
                            _this.render();
                            _this.updateTabIndex();
                        }
                    });
                    // Observe the "required" property state.
                    this.$attrs.$observe("required", function (newValue) {
                        var needRender = true;
                        if ((_this.required === newValue) || (newValue === false && _this.required === undefined)) {
                            // In this case, the UI does not need to be refreshed.
                            needRender = false;
                        }
                        _this.required = newValue;
                        if (needRender) {
                            _this.render();
                            _this.updateTabIndex();
                        }
                    });
                    this.$element.bind("focusin", function () {
                        // Add the focus on the select radio button if not disabled, or on the first not disabled radio button.
                        if (!_this.disabled && _this.isRadioButtonEnabled()) {
                            _this.setFocusFlag();
                        }
                    });
                };
                /**
                 *
                 * Sets the focus flag on the the selected radio button if it is not disabled, or on the first not
                 * disabled radio button.
                 *
                 */
                RadioGroupComponent.prototype.setFocusFlag = function () {
                    if (this.radioButtonControllers !== undefined && this.radioButtonControllers.length > 0) {
                        var firstDisabledRB;
                        var firstSelectedRB;
                        this.radioButtonControllers.forEach(function (rbCtrller) {
                            rbCtrller.removeFocusFlag();
                            if (!rbCtrller.disabled) {
                                if (angular.isUndefined(firstDisabledRB)) {
                                    firstDisabledRB = rbCtrller;
                                }
                                if (rbCtrller.getLastChecked()) {
                                    firstSelectedRB = rbCtrller;
                                }
                            }
                        });
                        if (angular.isDefined(firstSelectedRB)) {
                            firstSelectedRB.addFocusFlag();
                        }
                        else if (angular.isDefined(firstDisabledRB)) {
                            firstDisabledRB.addFocusFlag();
                        } // else { No focus flag to add. }
                    }
                };
                /**
                 * Sets the model controller.
                 *
                 * @param pNgModelCtrl The model controller.
                 *
                 */
                RadioGroupComponent.prototype.setNgModelController = function (pNgModelCtrl) {
                    var _this = this;
                    _super.prototype.setNgModelController.call(this, pNgModelCtrl);
                    this.ngModelController.$render = function () { return _this.render(); }; // Set our own render function.
                };
                /**
                 *
                 * Checks to see if the model controller is already defined.
                 *
                 * @returns {boolean} Returns true if the model controller is set already in the group controller, or false if
                 * it is not set.
                 *
                 *
                 */
                RadioGroupComponent.prototype.isModelDefined = function () {
                    return this.ngModelController !== undefined;
                };
                /**
                 *
                 * Registers the radio button render with the group controller.
                 *
                 *
                 * @param rbRender The render to register.
                 */
                RadioGroupComponent.prototype.addRadioButtonController = function (rbRender) {
                    this.radioButtonControllers.push(rbRender);
                };
                /**
                 *
                 * Removes radio button render from the group controller.
                 *
                 * @param rbRender The render to remove.
                 *
                 */
                RadioGroupComponent.prototype.removeRadioButtonController = function (rbRender) {
                    var index = this.radioButtonControllers.indexOf(rbRender);
                    if (index !== -1) {
                        this.radioButtonControllers.splice(index, 1);
                    }
                };
                /**
                 *
                 * Gets the the number of radio buttons in the radio group.
                 *
                 * @returns {number} Returns the number of radio buttons contained in the radio group.
                 *
                 */
                RadioGroupComponent.prototype.getNumberOfRadioButtons = function () {
                    return this.radioButtonControllers === undefined ? 0 : this.radioButtonControllers.length;
                };
                /**
                 *
                 * Renders the radio group.
                 *
                 *
                 */
                RadioGroupComponent.prototype.render = function () {
                    if (this.radioButtonControllers !== undefined && this.radioButtonControllers.length > 0) {
                        this.radioButtonControllers.forEach(function (rbCtrller) {
                            rbCtrller.render(); // render() function must be call on each radio button controller.
                        });
                        this.ngModelController.$validate();
                    }
                };
                /**
                 *
                 * Determines if a radio button is selected in the radio group.
                 *
                 * @returns {boolean} Returns true if a radio button is selected, false is no radio button is selected.
                 *
                 */
                RadioGroupComponent.prototype.isRadioButtonChecked = function () {
                    var _this = this;
                    var rbChecked = false; // Boolean used to verify if there is a radio button checked.
                    if (this.radioButtonControllers !== undefined && this.radioButtonControllers.length > 0) {
                        this.radioButtonControllers.forEach(function (rbCtrller) {
                            /* tslint:disable */
                            // do not use === to check the equality to support conversion between strings and numbers ('1' == 1 => should be true)
                            rbChecked = rbChecked || (rbCtrller.value == _this.ngModelController.$viewValue);
                            /* tslint:enable */
                        });
                    }
                    return rbChecked;
                };
                /**
                 *
                 * Determines if there is at least one enabled radio button.
                 *
                 * @returns {boolean} Returns true if at least one radio button is enabled, false if none are enabled.
                 *
                 */
                RadioGroupComponent.prototype.isRadioButtonEnabled = function () {
                    var rbEnabled = false; // Boolean used to verify if there is a radio button checked.
                    if (this.radioButtonControllers !== undefined && this.radioButtonControllers.length > 0) {
                        this.radioButtonControllers.forEach(function (rbCtrller) {
                            rbEnabled = rbEnabled || !rbCtrller.disabled;
                        });
                    }
                    return rbEnabled;
                };
                /**
                 *
                 * Change the radio group selected button by a given increment.
                 *
                 * Selects the first button if no button is selected.
                 *
                 */
                RadioGroupComponent.prototype.changeSelectedButton = function (increment) {
                    if (this.radioButtonControllers !== undefined && !this.readonly && !this.disabled) {
                        var length = this.radioButtonControllers.length;
                        var rbCheckedFound = false;
                        var rbIndex = 0;
                        while (!rbCheckedFound && rbIndex < length) {
                            var rbCtrl = this.radioButtonControllers[rbIndex];
                            if (rbCtrl.getLastChecked()) {
                                rbCheckedFound = true;
                            }
                            else {
                                rbIndex++; // I don't want to increment this index if I find a checked radio button.
                            }
                        }
                        var indexOfRadioBtnToCheck = 0;
                        if (rbCheckedFound) {
                            indexOfRadioBtnToCheck = rbIndex + increment;
                            if (indexOfRadioBtnToCheck < 0) {
                                indexOfRadioBtnToCheck = length - 1;
                            }
                            else if (indexOfRadioBtnToCheck >= length) {
                                indexOfRadioBtnToCheck = 0;
                            } // else { 0 <= indexOfRadioBtnToCheck < length => I keep this index. }
                        }
                        var rbToChecked = this.radioButtonControllers[indexOfRadioBtnToCheck];
                        if (this.disabled === undefined && rbToChecked.disabled) {
                            // NOTE: increment < 0 ? --increment or ++increment in order to following the current increment trend.
                            this.changeSelectedButton(increment < 0 ? --increment : ++increment);
                        }
                        else {
                            this.setViewValue(rbToChecked.value, "click");
                        }
                    }
                };
                /**
                 *
                 * Selects the previous radio button. If there is no previous radio button, the last is selected. If there is
                 * no current radio button selected, the first is checked.
                 *
                 *
                 */
                RadioGroupComponent.prototype.selectPrevious = function () {
                    this.changeSelectedButton(-1);
                };
                /**
                 *
                 * Selects the next radio button. If there is no next radio button, the first is selected. If there is
                 * no current radio button selected, the first is checked.
                 *
                 */
                RadioGroupComponent.prototype.selectNext = function () {
                    this.changeSelectedButton(1);
                };
                /**
                 *
                 * Determines if the arrow buttons on the keyboard are being used and moves the selection accordingly. Left and
                 * up arrows select the previous button, right and down errors selected the next button.
                 *
                 * @param ev (JQueryEventObject) Event to catch the key code.
                 *
                 */
                RadioGroupComponent.prototype.keydownListener = function (ev) {
                    switch (ev.keyCode) {
                        case KEY.LEFT_ARROW:
                        case KEY.UP_ARROW:
                            ev.preventDefault();
                            this.selectPrevious();
                            break;
                        case KEY.RIGHT_ARROW:
                        case KEY.DOWN_ARROW:
                            ev.preventDefault();
                            this.selectNext();
                            break;
                    }
                };
                /**
                 *
                 * Determines the group disabled value and then actives or deactivates the radio group focus via the tab index.
                 *
                 *
                 * @param $element (ng.IAugmentedJQuery) Element that updates the tab index.
                 */
                RadioGroupComponent.prototype.updateTabIndex = function () {
                    if (!this.readonly && (this.disabled || (this.disabled === undefined && !this.isRadioButtonEnabled()))) {
                        this.$element.removeAttr("tabIndex");
                    }
                    else {
                        this.$element.attr({
                            tabIndex: this.lastTabIndex
                        });
                    }
                };
                Object.defineProperty(RadioGroupComponent.prototype, "componentCreated", {
                    /**
                     *
                     * @returns {boolean} Determines if the radio group exists. Returns true if the radio group exists,
                     * returns false if the radio group does not.
                     *
                     */
                    get: function () {
                        return this._componentCreated;
                    },
                    /**
                     *
                     * Determines if the radio group exists. Returns true if the radio group exists,
                     * returns false if the radio group does not.
                     *
                     *
                     * @param created True if the radio group exists, false if it does not.
                     *
                     */
                    set: function (created) {
                        this._componentCreated = created;
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 *
                 * Sets the view value of the radio group.
                 *
                 * @param value The new value to set into the model.
                 *
                 * @param event The event source, or trigger.
                 *
                 */
                RadioGroupComponent.prototype.setViewValue = function (value, event) {
                    this.ngModelController.$setViewValue(value, event);
                    this.render();
                    this.setFocusFlag();
                };
                /**
                 *
                 * Determine the model value of the radio group.
                 *
                 * @returns Returns the model value.
                 *
                 */
                RadioGroupComponent.prototype.getViewValue = function () {
                    return this.ngModelController.$viewValue;
                };
                /**
                 *
                 * Sets the radio group focus.
                 *
                 */
                RadioGroupComponent.prototype.focus = function () {
                    if (!this.disabled && this.isRadioButtonEnabled()) {
                        this.$element.focus();
                    }
                };
                // EditComponent override implementation begins
                RadioGroupComponent.prototype.validationRules = function () {
                    var _this = this;
                    var requiredRule = DEFAULT_VALIDATION_RULES.REQUIRED();
                    requiredRule.errorMessage = "A radio button selection is required.";
                    requiredRule.validator = function () {
                        return _this.getNumberOfRadioButtons() > 0 && _this.required ?
                            _this.isRadioButtonChecked() : true;
                    };
                    return [requiredRule];
                };
                /** Angular service injection. */
                RadioGroupComponent.$inject = ["$scope", "$element", "$attrs", "$timeout", "validationManager"];
                return RadioGroupComponent;
            })(EditComponent);
            radioButtons.RadioGroupComponent = RadioGroupComponent;
        })(radioButtons = components.radioButtons || (components.radioButtons = {}));
    })(components = ers.components || (ers.components = {}));
})(ers || (ers = {}));
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};



/**
 * ERS Angular Controller: RadioButtonController.
 */
var ers;
(function (ers) {
    var components;
    (function (components) {
        var radioButtons;
        (function (radioButtons) {
                        var BaseController = ers.components.core.BaseController;
            /**
             * The radio button button controller.
             */
            var RadioButtonController = (function (_super) {
                __extends(RadioButtonController, _super);
                /**
                 * Constructor.
                 * @param $scope The component scope.
                 */
                function RadioButtonController($scope, $element) {
                    _super.call(this, $scope, $element);
                    this.value = $scope.value;
                    this.disabled = $scope.disabled;
                }
                /**
                 * This function associates the radio group controller with this radio button controller.
                 *
                 * @param pGroupCtrl The radio group controller.
                 * @param groupModel If it was not previously set, the group model that sets the group model contained in the
                 * group controller.
                 *
                 */
                RadioButtonController.prototype.setGroupCtrl = function (pGroupCtrl, groupModel) {
                    this.groupCtrl = pGroupCtrl;
                    if (!this.groupCtrl.isModelDefined()) {
                        // Here, we are in the case that the ersRadioGroup directive is created AFTER the ersRadioButton directives
                        // were built.
                        this.groupCtrl.setNgModelController(groupModel);
                    } // else { Here, we are in the case that the sub directives ersRadioButton were built AFTER the ersRadioGroup
                    //  and the ngGroupModel was set by the group (case when ng-repeat is used to build the all ersRadioButton).}
                };
                /**
                 * This function gets the last state of the radio button, checked or unchecked.
                 *
                 * @returns {boolean} Returns true if the last state of the radio button is checked, false if unchecked,
                 *
                 */
                RadioButtonController.prototype.getLastChecked = function () {
                    return this.lastChecked;
                };
                /**
                 * This function renders the radio button and returns its current state,
                 * checked or unchecked.
                 *
                 * @returns {boolean} Returns true if the radio button is checked or false if the radio button is unchecked.
                 */
                RadioButtonController.prototype.render = function () {
                    /* tslint:disable */
                    // do not use === to check the equality to support conversion between strings and numbers ('1' == 1 => should be true)
                    var checked = this.groupCtrl.getViewValue() == this.value;
                    /* tslint:enable */
                    var disabled = this.groupCtrl.disabled || (this.groupCtrl.disabled === undefined && this.disabled);
                    var readonly = this.groupCtrl.readonly;
                    if (readonly === this.lastReadonly
                        && disabled === this.lastDisabled
                        && checked === this.lastChecked) {
                        // There is nothing to do if no change is detected on the radio button state.
                        return;
                    }
                    var theRadioButton = this.$element.find("div[class=\"radio-btn-div\"]").find("div");
                    if (theRadioButton.length > 0) {
                        // Save current state of the radio button.
                        this.lastChecked = checked;
                        this.lastDisabled = disabled;
                        this.lastReadonly = readonly;
                        // Remove previous CSS class if exists.
                        if (this.rbClass !== undefined) {
                            theRadioButton.removeClass(this.rbClass); // remove previous CSS class.
                        }
                        // Get the CSS class to be applied.
                        this.rbClass = this.getCSSClass();
                        // Apply the CSS class
                        theRadioButton.addClass(this.rbClass);
                    }
                };
                /**
                 *
                 * This function calculates the CSS class used for the radio button display.
                 *
                 * @returns {string} The possible calculated CSS class values are:<br>
                 *   <li><b>Checked</b>&#151;The radio button is checked and normal (clickable).</li>
                 *   <li><b>Unchecked</b>&#151;The radio button is unchecked and normal (clickable).</li>
                 *   <li><b>Checked disabled</b>&#151;The radio button is checked and disabled.</li>
                 *   <li><b>Unchecked disabled</b>&#151;The radio button is unchecked and disabled.</li>
                 *   <li><b>Checked readonly</b>&#151;The radio button is checked and readonly.</li>
                 *   <li><b>Unchecked readonly</b>&#151;The radio button is unchecked and readonly.</li>
                 */
                RadioButtonController.prototype.getCSSClass = function () {
                    var radioButtonClassRender;
                    /* tslint:disable */
                    // do not use === to check the equality to support conversion between strings and numbers ('1' == 1 => should be true)
                    if (this.groupCtrl.getViewValue() == this.value) {
                        /* tslint:enable */
                        radioButtonClassRender = "checked";
                    }
                    else {
                        radioButtonClassRender = "unchecked";
                    }
                    if (this.groupCtrl.readonly) {
                        radioButtonClassRender += " readonly";
                    }
                    else if ((this.groupCtrl.disabled // group disabled property is more important than the button disabled property.
                        || (this.groupCtrl.disabled === undefined && this.disabled))) {
                        // special display when disabled.
                        radioButtonClassRender += " disabled";
                    } // else { The display of the radio button will be "normal". }
                    return radioButtonClassRender;
                };
                /**
                 * Remove the focus flag CSS from the current radio button.
                 */
                RadioButtonController.prototype.removeFocusFlag = function () {
                    var theRadioButton = this.$element.find("div[class=\"radio-btn-div\"]").find("div");
                    if (theRadioButton.length > 0) {
                        theRadioButton.removeClass("focus-flag");
                    }
                };
                /**
                 * Add the focus flag CSS to the current radio button.
                 */
                RadioButtonController.prototype.addFocusFlag = function () {
                    var theRadioButton = this.$element.find("div[class=\"radio-btn-div\"]").find("div");
                    if (theRadioButton.length > 0) {
                        theRadioButton.addClass("focus-flag");
                    }
                };
                /** The Angular service injection. */
                RadioButtonController.$inject = ["$scope", "$element"];
                return RadioButtonController;
            })(BaseController);
            radioButtons.RadioButtonController = RadioButtonController;
        })(radioButtons = components.radioButtons || (components.radioButtons = {}));
    })(components = ers.components || (ers.components = {}));
})(ers || (ers = {}));

// Declares the Angular module ers-radio-buttons
angular.module("ers.components.radio-buttons", ["ers.components.core"]);




/**
 * ERS Angular Directive: ers-radio-button.
 * Radio button component.
 */
var ers;
(function (ers) {
    var components;
    (function (components) {
        var radioButtons;
        (function (radioButtons) {
            angular.module("ers.components.radio-buttons").directive("ersRadioButton", radioButtonDirective);
            /**
             * @ngdoc directive
             * @name ersRadioButton
             * @restrict E
             * @baseDirective ers-radio-group (see [ers-radio-group](#radiogroupdirective))
             * @module ers.components.radioButtons
             * @scope
             * @transclude
             *
             * @description
             *
             * ### Usage
             * - Use the `ers-radio-button` component to create radio buttons inside of the ers-radio-group, associate
             * actions with them, and bind data from that result.
             * - `ers-radio-button` must always be wrapped by `ers-radio-group`.
             *
             * ### Examples
             *
             * #### Basic Usage
             *
             * <code-editor identifier="example1" data-title="Basic Radiobutton"
             * html-content-url="demos/ersRadioButton/basicUsage/index.html"
             * js-content-url="demos/ersRadioButton/basicUsage/script.js"
             * css-content-url="demos/ersRadioButton/basicUsage/styles.css" content-mode="html"></code-editor>
             *
             * #### Dynamic Repeat
             *
             * Radiobutton component with `ng-repeat` for more dynamic configuration.
             *
             * <code-editor identifier="example2" data-title="Dynamic Repeat"
             * html-content-url="demos/ersRadioButton/dynamicRepeat/index.html"
             * js-content-url="demos/ersRadioButton/dynamicRepeat/script.js"
             * css-content-url="demos/ersRadioButton/dynamicRepeat/styles.css" content-mode="html"></code-editor>
             *
             * #### Additional Attributes
             *
             * The radio group with additional options.
             *
             * <code-editor identifier="example2" data-title="Dynamic Repeat"
             * html-content-url="demos/ersRadioButton/extraAttributes/index.html"
             * js-content-url="demos/ersRadioButton/extraAttributes/script.js"
             * css-content-url="demos/ersRadioButton/extraAttributes/styles.css" content-mode="html"></code-editor>
             *
             * ### Design Guidelines
             *
             * - Use the radio group when a user has to make a selection of a single item from a list.
             * - Do not use the radio group if multiple options are allowed. To enable a multiple option selection, use the
             * [Checkbox](#/components/ersCheckbox/documentation) directive.
             * - Do not mix specific states. 'Read-only' radio buttons cannot be 'disabled'.
             *
             * ### Accessibility Guidelines
             *
             * No accessibility guidelines.
             *
             * @param {expression} [ng-model] {=}
             *
             * Binds the data from the selection.
             *
             * @param {boolean} [ng-readonly=false] {=?}
             *
             * Defines whether the radio button group is read-only.
             *
             *
             * @param {boolean} [ng-disabled=false] {=?}
             *
             * Enables or disables the group of radio buttons and supersedes `ng-disabled` at the individual radio button level.
             *
             * @param {boolean} [ng-required=false] {=?}
             *
             * Sets the group as required. The user must select at least one of the radio buttons.
             *
             * @param {expression} [ng-change="expression"] {=?}
             *
             * Evaluates the group for user input changes and notifies scope immediately, unlike the JavaScript
             * onChange event which only notifies scope when the button loses focus.
             *
             *
             * @param {string} [value] {=}
             * Sets the key to identify each radio button. The key must be a unique value for each radio button.
             *
             *
             * @param {boolean} [ng-disabled=false] {=?}
             *
             * Sets a single radio button to disabled if the parameter has not been defined at the
             * radio group level. `ers-radio-group` overrides this value. The default value is 'false'.
             *
             *
             * @param {expression} [ng-change="expression"] {=?}
             *
             * Evaluates the radio button for user input changes and notifies scope immediately, unlike the JavaScript
             * onChange event which only notifies scope when the button loses focus.
             *
             *
             * <doc-note> This option is overridden by the parent <code>ers-radio-group</code> option when present.</doc-note>
             *
             *
             * ##### Basic Use
             *
             * ```xml
             *     <ers-radio-button value="uniqueKey1" ng-disabled="false">
             *         Your display
             *     </ers-radio-button>
             *
             *     <ers-radio-button value="uniqueKey2" ng-disabled="false">
             *         Your display
             *     </ers-radio-button>
             *
             *     <ers-radio-button value="uniqueKey3" ng-disabled="true">
             *          Your display
             *     </ers-radio-button>
             *
             * ```
             *
             * ##### Using ers-radio-button with ng-repeat
             *
             * ```xml
             * <ers-radio-button ng-repeat="opt in sample.values"
             *       value="::opt.value" ng-disabled="::opt.disabled">
             *   {{::opt.display}}
             * </ers-radio-button>
             * ```
             */
            function radioButtonDirective() {
                return {
                    restrict: "E",
                    templateUrl: "radio-buttons/template/radio-button-template.html",
                    transclude: true,
                    controller: radioButtons.RadioButtonController,
                    controllerAs: "c",
                    require: ["ersRadioButton", "^ersRadioGroup", "^ngModel"],
                    scope: {
                        value: "=", disabled: "=?ngDisabled"
                    },
                    link: function ($scope, $element, $attrs, ctrls) {
                        var c = ctrls[0];
                        var rgc = ctrls[1];
                        var groupModel = ctrls[2];
                        // Associate the radio group controller with the current radio button controller.
                        c.setGroupCtrl(rgc, groupModel);
                        // Registering of the render of the radio button onto the group controller.
                        rgc.addRadioButtonController(c);
                        // Initial rendering for this current radio button.
                        rgc.render();
                        // Catch the click event on this radio button.
                        $element.on("click", function (event) {
                            // Dispatch the focus to the radio group in order to update the focus.
                            rgc.focus();
                            if (rgc.readonly || rgc.disabled || (rgc.disabled === undefined && c.disabled)) {
                                // On the readonly mode and the disabled mode, click event will not be processed.
                                return;
                            }
                            $scope.$apply(function () {
                                rgc.setViewValue($scope.value, event && event.type);
                            });
                        });
                        // Observe the disabled state.
                        $attrs.$observe("disabled", function (newValue) {
                            var needRender = true;
                            if ((c.disabled === newValue) || (newValue === false && c.disabled === undefined)) {
                                // In this case, the UI does not need to be refreshed.
                                needRender = false;
                            }
                            c.disabled = newValue;
                            if (needRender) {
                                rgc.render();
                                rgc.updateTabIndex();
                            }
                        });
                        // Destroy process.
                        $scope.$on("$destroy", function () {
                            rgc.removeRadioButtonController(c);
                        });
                        // If the radio group was already created, each radio button is responsible to update the tab index.
                        if (rgc.componentCreated) {
                            rgc.updateTabIndex();
                        }
                    }
                };
            }
        })(radioButtons = components.radioButtons || (components.radioButtons = {}));
    })(components = ers.components || (ers.components = {}));
})(ers || (ers = {}));




/**
 * ERS Angular Directive: ers-radio-group.
 * Radio button group component.
 */
var ers;
(function (ers) {
    var components;
    (function (components) {
        var radioButtons;
        (function (radioButtons) {
                        angular.module("ers.components.radio-buttons").directive("ersRadioGroup", radioGroupDirective);
            /**
             * @ng-doc directive
             * @name ersRadioGroup
             * @restrict E
             * @module ers.components.radioGroup
             * @scope
             * @transclude
             *
             * @description
             *
             * The `ers-radio-group` is a wrapper element for the `ers-radio-button`. It controls the radio buttons as a
             * group and provides two-way `ng-model` data binding for the selected value.
             *
             *
             *
             * <div ng-init="favoriteColor='Red'">
             *   <ers-radio-group name="favoriteColor" ng-model="favoriteColor">
             *     <ers-radio-button value="'Red'">Red</ers-radio-button>
             *     <ers-radio-button value="'Green'">Green</ers-radio-button>
             *     <ers-radio-button value="'Blue'">Blue</ers-radio-button>
             *   </ers-radio-group>
             * </div>
             *
             *
             * #### Visual Design Guidelines
             *
             * Use the radio group when a user has to make a selection of a single item from a list.
             *
             * Do not use the radio group if multiple options are allowed. To enable a multiple option selection, use the
             * [Checkbox](#/components/ersCheckbox/documentation) directive.
             *
             * Do not mix specific states. Read-only' radio buttons cannot be 'disabled'.
             *
             * #### Example
             *
             * The following example displays the code from the description display.
             *
             * ```xml
             * <ers-radio-group name="favoriteColor" ng-model="favoriteColor">
             *     <ers-radio-button value="'Red'">Red</ers-radio-button>
             *     <ers-radio-button value="'Green'">Green</ers-radio-button>
             *     <ers-radio-button value="'Blue'">Blue</ers-radio-button>
             * </ers-radio-group>
             * ```
             *
             *
             * @param {string} [name] {=}
             * Specifies the name of the group of radio buttons.
             *
             * ```xml
             * <ers-radio-group name="Favorite Color" ng-model="favoriteColor">
             *   <ers-radio-button value="'Red'">Red</ers-radio-button>
             *   <ers-radio-button value="'Green'">Green</ers-radio-button>
             *   <ers-radio-button value="'Blue'">Blue</ers-radio-button>
             * </ers-radio-group>
             * ```
             *
             * @param {expression} [ng-model] {=}
             *
             * Binds the data from the selection.
             *
             * @param {boolean} [ng-readonly=false] {=?}
             *
             * Defines whether the radio button group is read-only.
             *
             *
             * @param {boolean} [ng-disabled=false] {=?}
             *
             * Enables or disables the group of radio buttons and supersedes `ng-disabled` at the individual radio button level.
             *
             * @param {boolean} [ng-required=false] {=?}
             *
             * Sets the group as required. The user must select at least one of the radio buttons.
             *
             * @param {expression} [ng-change="expression"] {=?}
             *
             * Evaluates the group for user input changes and notifies scope immediately, unlike the JavaScript
             * onChange event which only notifies scope when the button loses focus.
             *
             */
            function radioGroupDirective() {
                return {
                    restrict: "E",
                    templateUrl: "radio-buttons/template/radio-group-template.html",
                    transclude: true,
                    controller: radioButtons.RadioGroupComponent,
                    controllerAs: "c",
                    require: ["ersRadioGroup", "ngModel"],
                    scope: {
                        name: "=", disabled: "=?ngDisabled", readonly: "=?ngReadonly", required: "=?ngRequired"
                    },
                    link: function ($scope, $element, $attrs, ctrls) {
                        var c = ctrls[0];
                        var ngGroupModel = ctrls[1];
                        // Set the radio group CSS class.
                        $element.addClass("ers-radio-group");
                        // Set the group ng-model into the group controller in order to provide the model to the radio buttons which
                        // have the group controller in their own controller.
                        if (!c.isModelDefined()) {
                            // Here, we are in the case that the ersRadioGroup directive is created BEFORE the ersRadioButton directives
                            // were built (case when ng-repeat is used to build the all ersRadioButton).
                            c.setNgModelController(ngGroupModel);
                            c.componentCreated = true; // I flag that the radio group is created. Used by the radio buttons.
                        }
                        else {
                            // Here, we are in the case that the sub directives ersRadioButton were built BEFORE the ersRadioGroup
                            // and the ngGroupModel was set by them.
                            c.updateTabIndex(); // I update the tab index from here only if all the radio buttons are created,
                        }
                    }
                };
            }
        })(radioButtons = components.radioButtons || (components.radioButtons = {}));
    })(components = ers.components || (ers.components = {}));
})(ers || (ers = {}));/*
 * Created by bertheto on 16/02/2015.
 */
/**
 * Created by bertheto on 11/03/2015.
 */

/**
 * INavigationItem Interface representing an entry in the navigation.
 */
/**
 * Created by bertheto on 28/01/2015.
 */

/**
 * IUserInfoScope Interface representing the scope for the User Info component.
 *//*
 * Created by bertheto on 28/01/2015.
 */


/*
 * Created by bertheto on 28/01/2015.
 */

/*
 * Created by bertheto on 06/02/2015.
 */
angular.module("ers.components.shell", ["ui.router",
    "ers.components.core",
    "ct.ui.router.extras.sticky",
    "ers.components.state"]).config(["$urlRouterProvider", function ($urlRouterProvider) {
        angular.module("ers.components.shell").urlRouterProvider = $urlRouterProvider;
    }]);
/**
 * Provider that allows to add states (ui-router) at runtime.
 * This provider is only a wrapper of $stateProvider to make it injectable.
 */
var ers;
(function (ers) {
    var components;
    (function (components) {
        var state;
        (function (state_1) {
            /**
             * Provider declaration => return a wrapper of $stateProvider.
             */
            angular.module("ers.components.state", []).provider("ersDynamicStateService", ["$stateProvider",
                function ($stateProvider) {
                    this.$get = ["$state", function ($state) {
                            return {
                                addState: function (name, state) {
                                    // delegate to ui router provider
                                    $stateProvider.state(name, state);
                                    return this;
                                }, addNestedState: function (name, state) {
                                    var val = $state.current.name + "." + name;
                                    return this.addState(val, state);
                                }
                            };
                        }];
                }]);
        })(state = components.state || (components.state = {}));
    })(components = ers.components || (ers.components = {}));
})(ers || (ers = {}));/*
 * Created by bertheto on 06/04/2015.
 */








var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var ers;
(function (ers) {
    var components;
    (function (components) {
        var shell;
        (function (shell) {
                        /**
             * @ngdoc directive
             * @module ers.components.shell
             * @name ersShell
             * @restrict E
             * @scope
             * @transclude
             *
             * @description
             *
             * Use `ers-shell` to form the main wrapper for your Galileo-powered applications. It contains two components:
             *
             * - **Top Shell** -- which consists of the **Product Selector** on the left and the header and user information
             * area on the right.
             * - **Content Area** -- which appears below the top shell and contains views of your application.
             *
             * Use the [ersNav](/#/components/ersNavigation/documentation)
             * component inside the shell for the left menu and an instance of
             * an [ersTabset](/#/components/ersTabset/documentation) (or custom content) on the right.
             *
             * <div style="position: relative; width: 500px; margin-left: 0px; margin-right: auto; padding-top: 10px;">
             *   <img src="assets/images/shell_header_RO1.png" width="85%" style=" border: 1px solid #ddd; padding: 1px;"
             *        alt="Shell Preview" /> </div>
             *
             * #### Visual Design Guidelines
             *
             * Set the navigation on the left side of the screen and your content on the right side.
             *
             * @param {string} title  {@}
             *
             * Specifies the title displayed in the header section. This can also be set dynamically using the Angular
             * "double-moustache" syntax.
             * ```xml
             * <ers-shell title="myCtrl.title()"/>
             * ```
             *
             * @param {expression} [products] {=}
             *
             * Specifies  the array of products to be displayed in the product selector.
             *
             * For more information, see the [IProduct API documentation](/typdoc/interfaces/ers.components.core.iproduct.html).
             *```xml
             * <ers-shell products="myCtrl.products"/>
             * ```
             * @param {expression} [user-info] {=}
             *
             * Specifies  the object containing the information about the currently logged in user. For more information, see
             * [IUserInfo API documentation](/typdoc/interfaces/ers.components.core.iuserinfo.html).
             *
             * @param {string} [current-context] {=}
             *
             * Specifies  current context for the information displayed in the **Context Selector** in the header user information section.
             *```xml
             * <ers-shell current-context="myCtrl.currentContext"/>
             * ```
             * @param {expression} [current-product] {=?}
             *
             * Sets the currently selected product in the **Content Area** from the current dropdown list of available products.
             *
             * @param {expression} [on-product-change] {&?}
             *
             * Specifies  the Angular expression invoked when the user makes a selection from the **Product Selector**.
             *
             * ```xml
             * <ers-shell on-product-change="myCtrl.productDidChange(newProduct,oldProduct)"></ers-shell>
             * ```
             * @param {expression} [on-after-product-change] {&?}
             *
             * Sets the Angular expression invoked when product has changed and on-product-change binding invoked (if specified).
             *
             * ```xml
             * <ers-shell on-after-product-change="myCtrl.productHasdChanged(newProduct,oldProduct)"></ers-shell>
             * ```
             *
             * @param {expression} [on-context-selector] {&?}
             *
             * Specifies  the Angular expression invoked when the user clicks on the Context Selector.
             * ```xml
             *  <ers-shell on-product-change="myCtrl.onProductChange(newProduct,oldProduct)"></ers-shell>
             *  ```
             *
             * @param {expression} [on-settings] {&?}
             *
             * Sets the Angular expression invoked when the user clicks on the Settings icon.
             * ```xml
             * <ers-shell on-settings="myCtrl.onSettings()"/>
             * ```
             *
             * @param {boolean} [settings-is-visible=true] {=?}
             *
             * Specifies  the Settings icon as visible or not. The default value is true.
             *```xml
             * <ers-shell settings-is-visible="myCtrl.settingIsVisible()"/>
             * ```
             * @param {expression} [on-info] {&?}
             *
             * Specifies  the Angular expression invoked when the user clicks on the Info icon.
             *
             * ```xml
             * <ers-shell on-info="myCtrl.onInfo()"/>
             * ```
             * @param {boolean} [info-is-visible=true] {=?}
             *
             * Sets the Info icon to visible or not. The default value is true.
             * ```xml
             * <ers-shell info-is-visible="myCtrl.infoIsVisible()"/>
             * ```
             * @param {expression} [on-help] {&?}
             *
             * Specifies  the Angular expression invoked when the user clicks on the Help icon.
             * ```xml
             * <ers-shell on-help="myCtrl.onHelp()"/>
             * ```
             * @param {boolean} [help-is-visible=true] {=?}
             *
             * Specifies  the Help icon to visible or not. The default value is true.
             *```xml
             * <ers-shell help-is-visible="myCtrl.helpIsVisible()"/>
             * ```
             * @param {expression} [on-edit-profile] {&?}
             *
             * Specifies  the Angular expression invoked when the user clicks the Edit Profile link in the User Information
             * drop down.
             * ```xml
             * <ers-shell on-context-selector="myCtrl.onContextSelector()"/>
             * ```
             *
             * @param {expression} [on-logout] {&?}
             *
             * Specifies  the Angular expression invoked when the user clicks the Logout link in the User Information dropdown.
             *```xml
             * <ers-shell on-logout="myCtrl.onLogout()"/>
             * ```
             *
             */
            angular.module("ers.components.shell").directive("ersShell", function () {
                return {
                    restrict: "E",
                    controller: ShellComponent,
                    controllerAs: "ctrl",
                    bindToController: true,
                    templateUrl: "shell/template/shell-template.html",
                    transclude: true,
                    /**
                     *  The scope mapping.
                     */
                    scope: {
                        onSettings: "&?",
                        onInfo: "&?",
                        onHelp: "&?",
                        onEditProfile: "&?",
                        onLogout: "&?",
                        onContextSelector: "&?",
                        products: "=",
                        currentProduct: "=?",
                        userInfo: "=",
                        currentContext: "=",
                        helpIsVisible: "=?",
                        infoIsVisible: "=?",
                        settingsIsVisible: "=?",
                        title: "@",
                        onProductChange: "&?",
                        onAfterProductChange: "&?"
                    }
                };
            });
            /**
             * ### Shell Component
             *
             * The shell component displays the shell screen and its sub components, product selector, topshell, and viewport.
             *
             * The shell component presents the Shell with two main displays, the topshell and the viewport.
             *
             * The **Top Shell** is composed of a **Product Selector** and a **Toolbar**, each with unique links, icons and menus.
             *
             * On click, the links and icons can only trigger external actions, so each must be configured with the
             * callback attributes needed to complete those actions.
             *
             * The current context, user, and product, are managed by the shell component.
             *
             * The product selection sets the current product and displays the corresponding product url in the viewport.
             *
             *  ### Available Options
             *
             * The following are the options available for the Shell component:
             *
             * * [onSettings](#onsettings), [onInfo](#oninfo), [onHelp](#onhelp), [onProductChange](#onproductchange),
             * [onAfterProductChange](#onAfterProductChange),
             * [onLogout](#onlogout),[onEditProfile](#oneditprofile), [onContextSelector](#oncontextselector),
             * [currentContext](#currentcontext),[products](#products),[userInfo](#userinfo),[infoIsVisible](#infoisvisible),
             * [settingsIsVisible](#settingsisvisible),[helpIsVisible](#helpisvisible)
             *
             * The following methods are available for the Shell component:
             *
             * ### Available Methods
             *
             * * [configureProductStates](#configureproductstates), [onProductChange](#onproductchange)
             * ### Examples
             *
             * #### Example with all the options and all the icons displayed.
             *
             * ```xml
             * <ers-shell on-settings="myCtrl.displaySettingsModal()" on-info="myCtrl.displayInfoModal()" on-help="myCtrl.displayHelp()"
             *    on-edit-profile="myCtrl.onEditProfile()" on-logout="myCtrl.onLogout()" products="myCtrl.products"
             *    user-info="myCtrl.userInfo" on-context-selector="myCtrl.displayContextSelector()"
             *    on-product-change="myCtrl.onProductChange(newProduct,oldProduct)"
             *    on-after-product-change="myCtrl.onProductChange(newProduct,oldProduct)"
             *    current-context="myCtrl.currentContext" help-is-visible="myCtrl.helpIsVisible()" info-is-visible="myCtrl.infoIsVisible()"
             * settings-is-visible="myCtrl.settingIsVisible()">
             * </ers-shell>
             * ```
             *
             * #### Example with icons dynamically displayed.
             *
             *```xml
             * <ers-shell  help-is-visible="myCtrl.helpIsVisible()" info-is-visible="myCtrl.infoIsVisible()"
             * settings-is-visible="myCtrl.settingIsVisible()">
             * </ers-shell>
             * ```
             */
            var BaseComponent = ers.components.core.BaseComponent;
            var ShellComponent = (function (_super) {
                __extends(ShellComponent, _super);
                /**
                 * @constructor
                 * @param $scope The IShellScope scope
                 * @param $state The state service.
                 * @param $rootScope The $rootScope service.
                 * @param $compile compile service
                 */
                function ShellComponent($scope, $element, $state, $rootScope, $q, $compile, dynamicStateService) {
                    _super.call(this, $scope, $element);
                    this.rootScope = $rootScope;
                    this.promiseService = $q;
                    this.configureProductStates($state, $compile, dynamicStateService);
                }
                /**
                 * Test if the product is the current product.
                 * @param pProductToTest
                 * @returns {boolean}True if the product is the current product.
                 */
                ShellComponent.prototype.isCurrentProduct = function (pProductCode) {
                    return this._currentProduct && pProductCode === this._currentProduct.code;
                };
                /**
                 * Test if a state is already configured in the stateProvider.
                 * @param pState the state to test
                 * @returns {boolean} true if the state is configured.
                 *
                 */
                ShellComponent.prototype.isStateAlreadyConfigured = function (pState) {
                    return angular.toJson(this.stateService.get()).indexOf(pState) < 0;
                };
                /**
                 *
                 * When a product is selected, a new state, consisting of the shell state plus the product code, is created to
                 * display the selected product in the viewport. The state cannot be defined during the configuration phase
                 * of the module because it is impossible to know which
                 * product and url will be selected.
                 *
                 * @param $state The state service.
                 *
                 */
                ShellComponent.prototype.configureProductStates = function ($state, $compile, dynamicStateService) {
                    var _this = this;
                    if (this.products) {
                        this.openedProducts = [];
                        this.stateService = $state;
                        this.shellState = $state.current.name;
                        this.shellState = this.shellState !== null && !angular.isUndefined(this.shellState) && this.shellState !== ""
                            ? this.shellState + "."
                            : "";
                        //for each product we create state for the products routing.
                        // the state is defined by the the shell state plus the product code.
                        // the state is link to a view "shell".
                        // the product is passed as data in the state to be used in the product pages.
                        var viewParent = (this.$element) ? this.$element.find(".product-view") : null;
                        this.products.forEach(function (product) {
                            var stateName = _this.shellState + product.code;
                            if (_this.isStateAlreadyConfigured(stateName)) {
                                // generate a view name for ui-router
                                var viewName = "productView-" + product.code;
                                if (viewParent) {
                                    // create dynamically <ui-view> element in the DOM as its name cannot be dynamic (in ng-repeat or in a template for example)
                                    // a div is added around ui-view to avoid scope issue to evaluate ng-class expression
                                    // if it is set to the ui-view element, ng-class will be evaluated in a new scope created for ui-view and not in the current
                                    // scope of the component!!!
                                    var template = "<div ng-class=\"ctrl.isCurrentProduct('" + product.code + "')" +
                                        "?'ers-shell-active-product':'ers-shell-hidden-product'\"><ui-view name=\"" +
                                        viewName + "\"></ui-view></div>";
                                    var el = $compile(template)(_this.$scope);
                                    viewParent.append(el);
                                }
                                // create the view config for ui-router
                                var view = {};
                                view[viewName] = {
                                    templateUrl: product.templateUrl, controller: product.controller, controllerAs: product.controllerAs
                                };
                                // create the state for ui-router
                                var state = {
                                    url: product.url, data: { product: product }, views: view, sticky: product.sticky || false
                                };
                                dynamicStateService.addState(stateName, state);
                            }
                        });
                        //on the state change, the current product is set, the product is added to the opened products list.
                        // in case of a nested state under the product, we keep this state to navigate to this after ave settled
                        // the product and navigated to this product : indeed, if this state is asked by directly (by the
                        // browser url for example, deep link) , we have to set the product first, go to this, and after go to
                        // the nested state inside this product.
                        this.rootScope.$on("$stateChangeStart", function (event, toState) {
                            var productFromState = toState.data.product;
                            // The nestedState is not defined so we are not in the case of the nested navigation.
                            if (angular.isUndefined(_this.nestedState) || _this.nestedState === null) {
                                // filter on the shell state
                                if (toState.name.indexOf(_this.shellState) === 0) {
                                    // if the new state is different than the product state, it's a nested state, so we keep this
                                    // in a variable
                                    if (toState.name !== _this.shellState + productFromState.code) {
                                        _this.nestedState = toState;
                                    }
                                    // The product is settled and by extension the navigation to this product occurs.
                                    _this.currentProduct = productFromState;
                                    if (_this.openedProducts.indexOf(productFromState) < 0) {
                                        _this.openedProducts.push(productFromState);
                                    }
                                }
                            }
                            else {
                                if (!toState.views || !toState.views["shell"]) {
                                    _this.nestedState = null;
                                }
                            }
                        });
                        // if a product is already set during initialisation, we force change product to trigger the routing
                        // mecanism.
                        if (this.currentProduct != null) {
                            this._onProductChange(this.currentProduct, null);
                        }
                    }
                };
                /**
                 *
                 * If onProductChange returns on product upon selection, and the promise is resolved, the new navigation route
                 * is used for the newly selected product. Otherwise, no routing changes are needed because there is no new
                 * product to which to navigate. All errors are raised.
                 *
                 * @param newProduct The selected product.
                 * @param oldProduct The previous product.
                 * @return a promise Resolved if the product is changed.
                 *
                 *
                 *
                 */
                ShellComponent.prototype._onProductChange = function (newProduct, oldProduct) {
                    var _this = this;
                    var deferred = this.promiseService.defer();
                    // if onProductChange exists and return a promise.
                    if (this.onProductChange) {
                        var promise = this.onProductChange({
                            newProduct: newProduct, oldProduct: this._currentProduct
                        });
                        if (promise) {
                            //the onProductChange promise is resolved : the product is changed, we can navigate.
                            promise.then(function () {
                                _this._onProductChangeResolved(deferred, newProduct, oldProduct);
                                //the onProductChange promise is rejected : the product isn't changed, we can't navigate.
                            }, function (error) {
                                if (error) {
                                    deferred.reject(error);
                                    _this.nestedState = null;
                                }
                            });
                        }
                        else {
                            this._onProductChangeResolved(deferred, newProduct, oldProduct);
                        }
                    }
                    else {
                        this._onProductChangeResolved(deferred, newProduct, oldProduct);
                    }
                    return deferred.promise;
                };
                /**
                 * Call if the onProductChange promise is resolved.
                 * @param deferred ng.IDeferred
                 * @param The selected product.
                 * @param oldProduct The previous product.
                 */
                ShellComponent.prototype._onProductChangeResolved = function (deferred, newProduct, oldProduct) {
                    var _this = this;
                    deferred.resolve();
                    //navigate to the product state
                    if (this.stateService) {
                        this.stateService.go(this.shellState + newProduct.code).then(function () {
                            // now the product is open; if we are in the  nested state case, we have to navigate to this state
                            if (!angular.isUndefined(_this.nestedState) && _this.nestedState !== null) {
                                var stateName = _this.nestedState.name;
                                _this.stateService.go(stateName).finally(function () {
                                    _this.nestedState = null;
                                });
                            }
                        });
                    }
                    //onAfterProductChange callback.
                    if (this.onAfterProductChange) {
                        this.onAfterProductChange({
                            newProduct: newProduct, oldProduct: oldProduct
                        });
                    }
                };
                Object.defineProperty(ShellComponent.prototype, "currentProduct", {
                    /**
                     * Get the current product.
                     * @returns {IProduct}
                     */
                    get: function () {
                        return this._currentProduct;
                    },
                    /**
                     * Set the current product.
                     * @param pProduct
                     */
                    set: function (pProduct) {
                        this._currentProduct = pProduct;
                    },
                    enumerable: true,
                    configurable: true
                });
                ShellComponent.$inject = ["$scope", "$element", "$state", "$rootScope", "$q", "$compile", "ersDynamicStateService"];
                return ShellComponent;
            })(BaseComponent);
            shell.ShellComponent = ShellComponent;
        })(shell = components.shell || (components.shell = {}));
    })(components = ers.components || (ers.components = {}));
})(ers || (ers = {}));




var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};


var ers;
(function (ers) {
    var components;
    (function (components) {
        var shell;
        (function (shell) {
                        /**
             * @ngdoc directive
             * @module ers.components.shell
             * @name ersTopShell
             * @restrict E
             *
             * @description
             *
             * Use the `ers-top-shell` with the main `ers-shell` component for additional control over your application
             * configuration. `ers-top-shell` handles the **Product Selector** in the left navigation window,
             * the section **Header**
             * at the top right, and provides a callback mechanism that tracks when you change from one product selection
             * to another.
             *
             *
             * The following graphic shows `ers-top-shell` with three icons displayed.
             *
             * <div style="position: relative; width: 100%; margin-left: 0px; margin-right: auto; padding-top: 10px;
             * padding-bottom: 20px;">
             *
             *   <img src="assets/images/topshell_icons.png" style=" border: 1px solid #ddd; padding: 1px;"
             *        alt="TopShell Icons" /> </div>
             *
             * <!-- not using example until we can figure out the straggler artifact.
             * <div style="margin: 30px;">
             * <ers-top-shell
             *  help-is-visible="myCtrl.helpIsVisible()"
             *  info-is-visible="myCtrl.infoIsVisible()"
             *  settings-is-visible="myCtrl.settingIsVisible()">
             * </ers-top-shell>
             * </div>
             * //-->
             *
             *
             * <!-- the above example was hacked from here. need to resolve the straggler
             * <div style="margin: 40px;">
             *     <ers-top-shell
             *     on-settings="myCtrl.onSettings()"
             *     on-info="myCtrl.onInfo()"
             *     on-help="myCtrl.onHelp()"
             *     on-edit-profile="myCtrl.onEditProfile()"
             *     on-logout="myCtrl.onLogout()"
             *     products="myCtrl.products"
             *     on-product-change="myCtrl.onProductChange(currentProduct)"
             *     user-info="myCtrl.userInfo"
             *     on-context-selector="myCtrl.onContextSelector()"
             *     current-context="myCtrl.currentContext"
             *     help-is-visible="myCtrl.helpIsVisible"
             *     info-is-visible="myCtrl.infoIsVisible"
             *     settings-is-visible="myCtrl.settingsIsVisible"/>
             * </div>
             *
             * //-->
             *
             * The following graphic illustrates the `ers-top-shell` with the **Product Selector**.
             *
             *
             * <div style="position: relative; width: 500px; margin-left: 0px; margin-right: auto; padding-top: 10px;">
             *   <img src="assets/images/shell_header_RO1.png" width="85%" style=" border: 1px solid #ddd; padding: 1px;"
             *        alt="Shell Preview" /> </div>
             *
             *
             * #### Visual Design Guidelines
             *
             * There are no visual design guidelines at this time.
             *
             * #### Example
             *
             * The following example displays the code from the first description display:
             *
             * ```xml
             * <div style="margin: 30px;">
             * <ers-top-shell
             * help-is-visible="myCtrl.helpIsVisible()"
             * info-is-visible="myCtrl.infoIsVisible()"
             * settings-is-visible="myCtrl.settingIsVisible()">
             * </ers-top-shell>
             * </div>
             * ```
             *
             *
             *
             *
             * @param {string} title Sets the title that is displayed in the header section. You can set this dynamically using
             * the Angular "double-moustache" syntax.
             *
             * @param {expression} products Sets the product array for display in the product selector. For more information
             * about the usage and expected properties see
             * [IProduct API documentation](/typedoc/interfaces/ers.components.core.iproduct.html).
             *
             * ```xml
             * <ers-top-shell products="myCtrl.products"/></ers-top-shell>
             * ```
             *
             * @param {expression} user-info Sets the object containing information about the currently logged in user.
             *
             * For more information about usage and expected properties see
             * the [IUserInfo API documentation](http://galileo/typedoc/interfaces/ers.components.core.iuserinfo.html).
             *
             * ```xml
             * <ers-top-shell user-info="myCtrl.userInfo"/></ers-top-shell>
             * ```
             *
             * @param {string} current-context
             *
             * Sets the current context that is displayed in the user information section **Context Selector** for the header.
             *
             *
             * @param {expression} [current-product]
             *
             * Sets the selected product from the list of products currently available in Product Selector drop-down list.
             *
             * @param {expression} [on-product-change]
             *
             * Sets the route to the new product when the user makes a selection from the **Product Selector**.
             *
             * ```xml
             * <ers-top-shell on-product-change="myCtrl.productDidChange(newProduct,oldProduct)"></ers-top-shell>
             * ```
             * @param {expression} [on-after-product-change]
             *
             * Sets the new product when the user makes a selection from the **Product Selector**.
             *
             * ```xml
             * <ers-top-shell on-after-product-change="myCtrl.productHasdChanged(newProduct,oldProduct)"></ers-top-shell>
             * ```
             *
             * @param {expression} [on-context-selector]
             *
             * Sets the expression (menu item) and callback executed when the user clicks the target in the
             * **Context Selector**.
             *
             *  ```xml
             * <ers-top-shell on-context-selector="myCtrl.onHelp()"/></ers-top-shell>
             * ```
             *
             *
             * @param {expression} [on-settings]
             *
             * Sets the expression and callback executed when the user clicks the **Settings** icon.
             *
             *  ```xml
             * <ers-top-shell on-settings="myCtrl.onHelp()"/></ers-top-shell>
             * ```
             *
             *
             * @param {boolean} [settings-is-visible=true]
             *
             * Sets whether or not the **Settings** icon is displayed. The default is `true`.
             *
             * @param {expression} [on-info]
             *
             * Sets the expression and callback executed when the user clicks the **Info** icon.
             *
             * @param {boolean} [info-is-visible=true]
             *
             * Sets whether or not the **Info** icon is displayed. The default is `true`, displayed.
             *
             * @param {expression} [on-help]
             *
             * Sets the expression and callback executed when the user clicks the **Help** icon.
             *
             *  ```xml
             * <ers-top-shell on-help="myCtrl.onHelp()"/></ers-top-shell>
             * ```
             *
             * @param {boolean} [help-is-visible=true]
             *
             * Sets whether or not the **Help** icon is displayed. The default is `true`.
             *
             *
             *
             * @param {expression} [on-edit-profile]
             *
             * Sets the expression (profile name) and callback executed when the user clicks the **User Information**
             * dropdown.
             *
             *  ```xml
             * <ers-top-shell on-edit-profile="myCtrl.onEditProfile()"/></ers-top-shell>
             * ```
             *
             * @param {expression} [on-logout]
             *
             * Sets the expression and callback executed when the user clicks in the **User Information** dropdown.
             *
             *  ```xml
             * <ers-top-shell on-logout="myCtrl.onLogout()"/></ers-top-shell>
             *
             * ```
             *
             *
             *
             */
            angular.module("ers.components.shell").directive("ersTopShell", function () {
                return {
                    restrict: "E",
                    controller: TopShellComponent,
                    controllerAs: "ctrl",
                    bindToController: true,
                    templateUrl: "shell/template/top-shell-template.html",
                    /**
                     *  The scope mapping.
                     *
                     */
                    scope: {
                        onSettings: "&?",
                        onInfo: "&?",
                        onHelp: "&?",
                        onEditProfile: "&?",
                        onLogout: "&?",
                        userInfo: "=",
                        products: "=",
                        onProductChange: "&?",
                        onContextSelector: "&?",
                        currentContext: "=",
                        currentProduct: "=?",
                        helpIsVisible: "=?",
                        infoIsVisible: "=?",
                        settingsIsVisible: "=?",
                        title: "@",
                        onAfterProductChange: "&?"
                    }
                };
            });
            /**
             * ###TopShell component
             *
             * Displays the topshell screen and its sub components, product selector, icons, menu, and links. The topshell
             * is composed of a product selector,  and a toolbar with different links, icons and menu.
             *
             * On click, the links and icons can only trigger external actions, so each must be configured with the
             * callback attributes needed to complete those actions.
             *
             * The current context, user, and product, are managed by the topshell component.
             *
             * The product selection sets the current product and dispatches the information with the callback
             * function [onProductChange](#onproductchange).
             *
             *  ### Available Options
             *
             * The following are the options available for the top-Shell component:
             *
             * * [onSettings](#onsettings), [onInfo](#oninfo), [onHelp](#onhelp),
             * [onLogout](#onlogout),[onEditProfile](#oneditprofile), [onContextSelector](#oncontextselector),
             * [onProductChange](#onproductchange),[onAfterProductChange](#onAfterProductChange),
             * [currentContext](#currentcontext),[products](#products),[userInfo](#userinfo),[infoIsVisible](#infoisvisible),
             * [settingsIsVisible](#settingsisvisible),[helpIsVisible](#helpisvisible)
             *
             * The following are the methods available for the top-Shell component:
             *
             * ### Available Methods
             *
             * * [changeProduct](#changeproduct), [isHelpVisible](#ishelpvisible), [isInfoVisible](#isinfovisible),
             * [isSettingsVisible](#issettingsvisible)
             *
             * ### Examples
             *
             * #### Example with all the options and all the icons displayed.
             *
             * ```xml
             * <ers-top-shell on-settings="myCtrl.onSettings()" on-info="myCtrl.onInfo()" on-help="myCtrl.onHelp()"
             * on-edit-profile="myCtrl.onEditProfile()" on-logout="myCtrl.onLogout()"
             * products="myCtrl.products"
             * on-product-change="myCtrl.onProductChange(newProduct,oldProduct)"
             * on-after-product-change="myCtrl.onProductChange(newProduct,oldProduct)"
             * user-info="myCtrl.userInfo" on-context-selector="myCtrl.onContextSelector()"
             * current-context="myCtrl.currentContext"
             * help-is-visible="myCtrl.helpIsVisible" info-is-visible="myCtrl.infoIsVisible"
             * settings-is-visible="myCtrl.settingsIsVisible"/>
             * ```
             *
             * #### Example with icons dynamically displayed.
             *
             *```xml
             * <ers-top-shell  help-is-visible="myCtrl.helpIsVisible()" info-is-visible="myCtrl.infoIsVisible()"
             * settings-is-visible="myCtrl.settingIsVisible()">
             * </ers-top-shell>
             * ```
             */
            var BaseComponent = ers.components.core.BaseComponent;
            var TopShellComponent = (function (_super) {
                __extends(TopShellComponent, _super);
                /**
                 * * @constructor
                 * @param $scope The ITopShellScope scope.
                 */
                function TopShellComponent($scope, ersModalService) {
                    _super.call(this, $scope);
                    /**
                     * The selected product index.
                     */
                    this.selectedProductIndex = 0;
                    this.modalService = ersModalService;
                }
                /**
                 * Sets the selected product index for the newly selected product.
                 * @param newProduct The new product and route to set.
                 */
                TopShellComponent.prototype.changeProduct = function (newProduct) {
                    var _this = this;
                    var promise;
                    if (newProduct) {
                        var oldProduct = this._currentProduct;
                        promise = this.onProductChange({
                            newProduct: newProduct, oldProduct: oldProduct
                        });
                        if (promise) {
                            // promise is resolved : change the product
                            promise.then(function () {
                                _this.selectedProductIndex = _this.products.indexOf(newProduct);
                                _this._currentProduct = newProduct;
                                // promise is rejected : don't change the product
                            }, function (error) {
                                if (error) {
                                    _this.modalService.informationDialog("Error", error);
                                }
                            });
                        }
                        else {
                            this.selectedProductIndex = this.products.indexOf(newProduct);
                            this._currentProduct = newProduct;
                        }
                    }
                    return promise;
                };
                Object.defineProperty(TopShellComponent.prototype, "currentProduct", {
                    /**
                     *
                     * The product getter.
                     *
                     * @returns {IProduct} The currently selected product.
                     *
                     */
                    get: function () {
                        return this._currentProduct;
                    },
                    /**
                     *
                     * If onProductChange exists and its promise is resolved, the newly selected product is set. If it is not set,
                     * the promise is rejected and an error is raised with the rejected promise as the error message.
                     *
                     *
                     *
                     * @param pProduct The product.
                     */
                    set: function (newProduct) {
                        this.changeProduct(newProduct);
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * Help icon visibility test
                 * @return {boolean} true If the help icon is visible.
                 */
                TopShellComponent.prototype.isHelpVisible = function () {
                    return this.helpIsVisible === undefined || this.helpIsVisible === "true";
                };
                /**
                 * Info icon visibility test.
                 * @return {boolean} True if the info icon is visible.
                 */
                TopShellComponent.prototype.isInfoVisible = function () {
                    return this.infoIsVisible === undefined || this.infoIsVisible === "true";
                };
                /**
                 * Settings icon visibility test.
                 * @return {boolean} True if the settings icon is visible.
                 */
                TopShellComponent.prototype.isSettingsVisible = function () {
                    return this.settingsIsVisible === undefined || this.settingsIsVisible === "true";
                };
                TopShellComponent.$inject = ["$scope", "ersModalService"];
                return TopShellComponent;
            })(BaseComponent);
            shell.TopShellComponent = TopShellComponent;
        })(shell = components.shell || (components.shell = {}));
    })(components = ers.components || (ers.components = {}));
})(ers || (ers = {}));/*
 * Created by fangiot on 12/14/2014.
 */
var ers;
(function (ers) {
    var components;
    (function (components) {
        var tabs;
        (function (tabs) {
                    })(tabs = components.tabs || (components.tabs = {}));
    })(components = ers.components || (ers.components = {}));
})(ers || (ers = {}));
// only declare angular module
angular.module("ers.components.tabs", ["ers.components.core"]);/*
 * Created by FangioT on 5/15/2015.
 */

var ers;
(function (ers) {
    var components;
    (function (components) {
        var tabs;
        (function (tabs) {
                    })(tabs = components.tabs || (components.tabs = {}));
    })(components = ers.components || (ers.components = {}));
})(ers || (ers = {}));/*
 * Created by Topher Fangio on 12/10/2014.
 */

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};








/**
 * @ng-doc directive
 * @module ers.components.tabs
 * @name ersTabset
 * @restrict E
 * @transclude
 * @scope
 *
 * @description
 *
 *
 * The `ers.components.tabs` module comprises two elements:
 *
 *  - ers-tabset&#151;Wraps the tabs that you wish to display (this directive).
 *  - ers-tab&#151;Creates a selectable tab, a tab heading,
 *  and a corresponding sheet containing tab content.
 *
 * ### Usage
 *
 * - Use `ers-tabset` as the envelope to group `ers-tabs` into logical groups that display sheets of information. The
 * sheets are the containers holding the tab content. Primary Tabs are at the top of sheets providing
 * the main label, or the name of the sheet. Use `ers-tabset` to create additional tab levels
 * under the primary tab.
 * - `ers-tabset` uses the _class_ attribute (&lt;ers-tabset class="secondary"&gt;) {{tab}} to define sub-tabs
 * within a sheet. You can transclude the tab header and content.
 *
 *
 * ### Examples
 *
 * <code-editor identifier="example3" data-title="Tabset" html-content-url="demos/ersTabset/basicUsage/index.html"
 * js-content-url="demos/ersTabset/basicUsage/script.js" css-content-url="demos/ersTabset/basicUsage/styles.css"
 * content-mode="html"></code-editor>
 *
 * ### Design Guidelines
 *
 * Use `ers-tabset` where you are designing grouped content such as forms, settings, and grids, to provide
 * a consistent level of navigation between similar modules of your application.
 *
 * ##### Styles
 *
 * There are two levels of visual tabset:
 *
 * - Primary&#151;Used at the tops of pages to provide navigation between elements.
 * - Secondary&#151;Used beneath Primary tabset for an additional levels of navigation.
 *
 * ##### Best Practices
 *
 * Consider the following principles and best practices when designing the user interface with these components:
 *
 * - Use only one primary tabset per page to maintain proper visual hierarchy.
 * - Primary tabsets should always appear above secondary tabsets.
 * - Do not stack secondary tabsets as this may cause confusion to the user.
 * - Always place the secondary tabset inside of the primary tabset content to ensure that the tab
 *   switching animation applies to all of the content.
 *
 * ### Accessibility Guidelines
 *
 * No accessibility guidelines.
 *
 * @param {string} heading {@?}
 *
 * Specifies the text to be displayed in the tab title (selection) area. Use only text, not HTML. To add an HTML tag or
 * an icon, use the `tab-heading` element. Title text can be transcluded.
 *
 *
 * ##### Example - Basic Heading
 *
 * ```xml
 * <ers-tab heading="My Heading"></ers-tab>
 * ```
 *
 * ##### Example - HTML Heading
 *
 * ```xml
 * <ers-tab><tab-heading><i class='fa fa-user'></i> Users</tab-heading></ers-tab>
 * ```
 *
 * @param {boolean} [active] {=?}
 * (ers-tab) Whether or not this tab should be active.
 *
 * ```xml
 * <ers-tab heading="Test Active" active="myCtrl.active"></ers-tab>
 * ```
 *
 * @param {string[]} [errors] {=?}
 * (ers-tab) Adds a red dot to the tab indicating an error associated with the tab. These error message are not
 * displayed to the user.
 *
 * ```xml
 * <ers-tab heading="Contact Us" errors="MyCtrl.tabs['contact-us'].errors"></ers-tab>
 * ```
 *
 * @param {expression} [select] {&?}
 * (ers-tab) Sets the action invoked when the tab is selected or gains focus.
 *
 * ```xml
 * <ers-tab select="MyCtrl.tabSelected()"></ers-tab>
 * ```
 *
 * @param {expression} [deselect] {&?}
 * (ers-tab) Sets the action invoked when the tab loses focus, or is deselected.
 *
 * ```xml
 * <ers-tab deselect="MyCtrl.tabDeselected()"></ers-tab>
 * ```
 *
 * @param {expression} [close] {&?}
 * (ers-tab) Sets the action invoked when this tab is closed and removed from the list
 * of tabs.
 *
 * ```xml
 * <ers-tab close="MyCtrl.tabClosed()"></ers-tab>
 * ```
 *
 * @param {boolean} [auto-activate-first-tab] {=?}
 *
 * (ers-tabset) Specifies whether or not the first tab is automatically activated when the tabs are loaded.
 * This allows the developer to choose the tab to activate when a page opens.
 *
 * @param {boolean} [can-close] {=?}
 *
 * (ers-tabset) Specifies whether or not a tab can be closed. When true, the tabs display a 'close' icon at the top right
 * of the tab during a mouse-over or hover.
 *
 * @param {boolean} [can-close-single=true] {=?}
 *
 * (ers-tabset) Specifies whether or not the last tab can be closed. This is only relevant when `can-close` is set to `true`.
 *
 * @param {boolean} [can-sort] {=?}
 *
 * (ers-tabset) Specifies if tab sorting is allowed. If true, you can click and drag the tabs to rearrange them within the
 * current list of tabs.
 *
 * @param {expression} [sort]  {@?}
 *
 * (ers-tabset) An Angular expression that is evaluated when a sort occurs.
 *
 * The expression accesses the `$event` object which is a jQuery event and provides the following additional properties:
 *
 *  - `sortOrder` - An array of indices representing the order of the tabs after the sort.
 *
 *    For example, if the first and second indices were swapped this may return `[0,2,1,3]`, allowoing you
 *    to determine the new order of your array:
 *
 *    ```js
 *    var newTabs = _.map($event.sortOrder, function(order) {
 *      return oldTabs[order];
 *    });
 *    ```
 */
var ers;
(function (ers) {
    var components;
    (function (components) {
        var tabs;
        (function (tabs) {
                        // Tell Angular about our directives
            angular.module("ers.components.tabs").directive("ersTabset", function TabsetDirective() {
                return {
                    restrict: "E",
                    transclude: true,
                    templateUrl: "tabs/template/tabset-template.html",
                    scope: {
                        // Define our value-based scope attributes
                        autoActivateFirstTab: "=?",
                        canClose: "=?",
                        canCloseSingle: "=?",
                        canSort: "=?",
                        delegate: "=?",
                        sort: "@?",
                        ngShow: "="
                    },
                    controller: TabsetComponent, controllerAs: "vm", bindToController: true,
                    link: function (scope, el, attrs, ctrl) {
                        // Call the link function with 'this' set to the scope's controller
                        ctrl.link.call(ctrl, scope, el, attrs);
                    }
                };
            });
            var EVENT = ers.components.core.event.EVENT;
            var BaseComponent = ers.components.core.BaseComponent;
            /**
             * @description
             *
             * Tabset handles the events, styles, and primary and secondary level tab navigation components A Tabset must
             * contain Tabs ([[TabComponent]]) for anything to be displayed.
             *
             *
             *
             * ### Methods
             * The following are the Tabset component methods:
             *
             * * [[addTab]], [[hide]], [[layout]], [[removeTab]], [[scrollToTab]], [[selectFirstTab]], [[selectTab]], [[show]]
             *
             * ```xml
             *  <div ng-controller="MyController as ctrl">
             *    <ers-tabs>
             *      <ers-tab ng-repeat="tab in ctrl.myTabs"
             *               heading="{{tab.heading}}"
             *               errors="{{tab.errors}}"></ers-tab>
             *    </ers-tabs>
             *  </div>
             *  ```
             */
            var TabsetComponent = (function (_super) {
                __extends(TabsetComponent, _super);
                /**
                 * Creates a new TabsetComponent instance.
                 *
                 * **Note** This method is called automatically by Angular when it sees a matching directive, so you will rarely
                 * instantiate this class in your code (perhaps only in a test).
                 *
                 * @constructor
                 *
                 * @returns A new [[TabsetComponent]] instance.
                 *
                 */
                function TabsetComponent($scope, $parse, $timeout, containerEventService) {
                    var _this = this;
                    _super.call(this, $scope, null, null, $timeout);
                    /**
                     * @private
                     * Specifies the internal boolean used to stop the layout() function from activating
                     * for all tabs when the tabset is created.
                     */
                    this.initialized = false;
                    /**
                     * The drop down menu of hidden tabs.
                     *
                     * @type {Array}
                     */
                    this.menuItemsOfHiddenTabs = [];
                    /**
                     * @private
                     *
                     * Specifies whether or not tabs have been added or removed since the last sortable setup.
                     */
                    this.sortableTabsChanged = false;
                    /**
                     * Implements the IContainerEventService protocol to listen for resize events. This currently resizes on a
                     * 100ms delay per request in case of multiple resize calls.
                     *
                     * @param dimensions - The new dimensions of the window.
                     *
                     */
                    this.needsLayout = false;
                    // Initialize our scope variables
                    this.autoActivateFirstTab = (this.autoActivateFirstTab === undefined ? true : this.autoActivateFirstTab);
                    this.canClose = (this.canClose === undefined ? false : this.canClose);
                    this.canCloseSingle = (this.canCloseSingle === undefined ? true : this.canCloseSingle);
                    this.canSort = (this.canSort === undefined ? false : this.canSort);
                    // Parse the sort function if provided
                    if (this.sort) {
                        this.sortFn = $parse(this.sort);
                    }
                    // Initialize our internal variables
                    this.tabs = [];
                    this.leftHiddenTabs = [];
                    this.rightHiddenTabs = [];
                    this.activeTab = null;
                    // Run a new layout to update the hidden tabs
                    this.$timeout(function () {
                        _this.initialized = true;
                        _this.layout();
                    });
                    this.containerEventService = containerEventService;
                    this.containerEventService.registerDispatcher(EVENT.RESIZE, $scope);
                    containerEventService.on(EVENT.RESIZE, $scope, function () { return _this.resizeDidOccur(); });
                }
                Object.defineProperty(TabsetComponent.prototype, "ngShow", {
                    /**
                     * Getter on the ngShow directive attribute.
                     * @returns {boolean} Returns the ngShow value.
                     */
                    get: function () {
                        return this._ngShow;
                    },
                    /**
                     * Setter on the ngShow directive attribute.
                     * @param value If true, the hidden tabs will be computed again to update the hidden tabs context menu.
                     */
                    set: function (value) {
                        this._ngShow = value;
                        if (value) {
                            this.resizeDidOccur();
                        }
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * Called when a parent has resized the tabs.
                 */
                TabsetComponent.prototype.resizeDidOccur = function () {
                    var _this = this;
                    // Layout our component after 100ms to batch it in case of multiple calls
                    this.needsLayout = true;
                    if (this.$timeout) {
                        this.$timeout(function () {
                            if (_this.needsLayout) {
                                _this.layout();
                                _this.needsLayout = false;
                                // dispatch resize event to children
                                _this.containerEventService.dispatch(EVENT.RESIZE, _this.$scope);
                            }
                        }, 100);
                    }
                };
                /**
                 * @private
                 *
                 * Called by Angular when the directive is being linked to an HTML element in the DOM.
                 *
                 * @param $scope The scope this directive monitors and modifies.
                 * @param element The jQuery representation of the HTML element.
                 * @param attributes The array of HTML attributes on the element.
                 */
                TabsetComponent.prototype.link = function ($scope, element, attributes) {
                    var self = this;
                    _super.prototype.link.call(this, $scope, element, attributes);
                    // does not work if element is injected at contstructor level, need to add this affectation to store the current element
                    this.$element = element;
                    // Add the appropriate classes/aria attributes
                    element.addClass("ers-tabset");
                    element.attr("role", "navigation");
                    // If the autoActivateFirstTab property is true; setup a watcher to wait
                    // until we have valid tabs and then activate the first one
                    if (this.autoActivateFirstTab && this.tabs && this.tabs.length > 0) {
                        // Add a $timeout task to the end of the $digest loop to select the first tab after the loop finishes
                        self.$timeout(self.selectFirstTab);
                    }
                };
                /**
                 * Attempts to select the very first tab (if one is available).
                 */
                TabsetComponent.prototype.selectFirstTab = function () {
                    if (!this.activeTab && this.tabs[0]) {
                        this.setActiveTab(this.tabs[0]);
                    }
                };
                /**
                 * Selects the requested tab.
                 *
                 * @param tab The [[TabComponent]] from the list of [[tabs]] that you wish to select.
                 */
                TabsetComponent.prototype.selectTab = function (tab) {
                    // Make sure we were actually passed a tab to select
                    if (!tab) {
                        return;
                    }
                    // Deactivate the current tab
                    if (this.activeTab) {
                        this.activeTab.deactivate();
                    }
                    // Set and activate the new tab
                    this.activeTab = tab;
                    this.activeTab.active = true;
                    this.activeTab.activate();
                    // Layout all of our tabs
                    this.layout();
                    // If we have a delegate that specifies the tabActivated method; call it
                    if (this.delegate && this.delegate.tabActivated) {
                        this.delegate.tabActivated(this.activeTab);
                    }
                };
                /**
                 * Hides this directive by setting the display to none.
                 */
                TabsetComponent.prototype.hide = function () {
                    this.$element.hide();
                };
                /**
                 * Shows this directive by setting the CSS display to block and ensuring the layout is updated.
                 */
                TabsetComponent.prototype.show = function () {
                    this.$element.show();
                    this.layout();
                };
                /**
                 * Gathers information about, and lays out the component in a responsive way and updates the CSS.
                 *
                 * Call this to refresh the layout and CSS of the component when it's container size changes or you need to ensure
                 * the CSS and hidden tabs are up-to-date.
                 *
                 * _**Note:** You must manually run a `$digest()` cycle if calling this method outside of Angular._
                 */
                TabsetComponent.prototype.layout = function () {
                    // if tabset is not already initialized => nothing done!
                    // avoid to execute layout for each tab!
                    if (!this.initialized) {
                        return;
                    }
                    // Don't attempt to layout if we haven't fully rendered yet
                    if (!this.$element) {
                        return;
                    }
                    // Make sure our tabs are in sync with the actual tabs on the page
                    this.syncTabs();
                    // Check to see if we should auto-activate the first tab
                    if (!this.activeTab && this.autoActivateFirstTab) {
                        this.selectFirstTab();
                    }
                    // Ensure that as many tabs as possible are in view
                    this.scrollIntoView();
                    // Update our CSS and which tabs are hidden; this must be done BEFORE our scrolling of the active tab
                    // so we know how wide the component is.
                    this.updateHiddenTabs();
                    // If we have an active tab, scroll so it's visible
                    if (this.activeTab) {
                        // Scroll to the active tab
                        this.scrollToTab(this.activeTab);
                    }
                    // Update our list of hidden tabs again; this must be done again AFTER our scrolling to the active tab above
                    // to ensure that the width change and scrolling hasn't hidden any additional tabs.
                    this.updateHiddenTabs();
                    // Allow sorting
                    if (this.canSort) {
                        this.setupSortable();
                    }
                };
                /**
                 * @private
                 *
                 * Sets up the internal jQuery UI for rearranging the tabs on this component.
                 */
                TabsetComponent.prototype.setupSortable = function () {
                    // TODO: Replace this functionality with Angular-only code (eliminate jQuery UI to save space).
                    // Don't re-run if our tabs have not changed
                    if (!this.sortableTabsChanged) {
                        return;
                    }
                    if (this.tabsElement().sortable()) {
                        // Destroy any existing sortables
                        this.tabsElement().sortable("destroy");
                    }
                    var self = this;
                    var beforeSortTabs;
                    // Create a new sortable
                    this.tabsElement().sortable({
                        axis: "x",
                        forcePlaceholderSize: true,
                        /*helper: "clone",*/
                        start: function (event, ui) {
                            // Save our tab order before the sort
                            beforeSortTabs = _.clone(self.tabs);
                        },
                        update: function (event, ui) {
                            // Grab/update the new list of tab controllers
                            self.tabs = _.map(self.tabsElement().find("ers-tab").toArray(), function (tabEl) {
                                return angular.element(tabEl).controller("ersTab");
                            });
                            // If we're giving a sort function, call it
                            if (self.sortFn) {
                                // Cast our regular event to a new type with our custom additions
                                var sortEvent = event;
                                // Calculate the new order based on the pre-sort tabs array
                                sortEvent.sortOrder = _.map(self.tabs, function (tab) {
                                    return beforeSortTabs.indexOf(tab);
                                });
                                // Make the call
                                self.sortFn(self.$scope.$parent, { $event: sortEvent });
                                self.$scope.$parent.$digest();
                            }
                            // Run a new layout to update the hidden tabs
                            self.$timeout(function () {
                                self.layout();
                            });
                        }
                    });
                    // Reset our property so we don't setup sortables too often
                    this.sortableTabsChanged = false;
                };
                /**
                 * Scrolls to take up any unused space so that as many tabs as possible
                 * will be displayed on the screen.
                 *
                 * This is most useful when the component resizes and gets larger and
                 * has unused space on the right side.
                 *
                 * This is automatically called on a window resize event, but may be
                 * called by your code as well.
                 */
                TabsetComponent.prototype.scrollIntoView = function () {
                    var lastTab = this.tabsElement().find("ers-tab:last");
                    if (lastTab) {
                        var myWidth = this.$element.width();
                        var myOffset = (this.tabsElement().position() || { left: 0 }).left;
                        var lastTabWidth = lastTab.width();
                        var lastTabOffset = (lastTab.position() || { left: 0 }).left;
                        var dropdownToggleWidth = this.$element.find(".dropdown-toggle").width();
                        var fadePadding = TabsetComponent.FADE_PADDING;
                        var currentPosition = this.tabsElement().position().left;
                        var extraSpace = myWidth - myOffset - lastTabOffset - lastTabWidth - fadePadding - dropdownToggleWidth;
                        if (extraSpace > 0) {
                            // Don't move past 0 (i.e. the starting position)
                            this.moveLeft(Math.min(currentPosition + extraSpace, 0));
                        }
                    }
                };
                /**
                 * Scrolls the active tab into view.
                 *
                 * @param tab The tab from the list of [[tabs]] that can be scrolled into view.
                 */
                TabsetComponent.prototype.scrollToTab = function (tab) {
                    var index = this.tabs.indexOf(tab);
                    var hiddenOnLeft = this.leftHiddenTabs.indexOf(tab) > -1, hiddenOnRight = this.rightHiddenTabs.indexOf(tab) > -1;
                    // If the active tab is not hidden; don't bother scrolling
                    if (!hiddenOnLeft && !hiddenOnRight) {
                        return;
                    }
                    // Grab the width of the viewport (the non-hidden portion of the <ul>) and the active element
                    var viewportWidth = this.$element.width();
                    var $tab = this.tabsElement().find("ers-tab").eq(index);
                    var activeWidth = $tab.width();
                    var activeLeft = $tab.position().left;
                    var isFirst = index === 0;
                    var isLast = index === this.tabs.length - 1;
                    var padding = isFirst || isLast ? 0 : TabsetComponent.FADE_PADDING;
                    var toggleWidth = 29;
                    var newPosition;
                    if (hiddenOnRight) {
                        newPosition = viewportWidth - (activeLeft + activeWidth + padding + toggleWidth);
                    }
                    if (hiddenOnLeft) {
                        newPosition = -activeLeft + padding;
                    }
                    this.moveLeft(newPosition);
                };
                TabsetComponent.prototype.moveLeft = function (newPosition) {
                    var _this = this;
                    // Animate to the new position
                    this.tabsElement().css({ left: newPosition });
                    // During the transition, go ahead and update our hidden tabs so that the fade effect might appear during movement
                    // which makes it less jarring than at the end
                    this.$timeout(function () {
                        _this.updateHiddenTabs();
                    }, 200);
                    // After the transition has run (which is defined in the CSS), update our hidden tabs
                    // TODO: The time below is jarring and not precise; use the 'transitionend' event when browser support is better
                    this.$timeout(function () {
                        _this.updateHiddenTabs();
                    }, 1300);
                };
                /**
                 * @private
                 *
                 * Synchronizes the list of angular tab elements with our internal cache.
                 *
                 */
                TabsetComponent.prototype.syncTabs = function () {
                    var _this = this;
                    var previousTabs = _.clone(this.tabs);
                    // Update the list of tabs based on the real <ers-tab> elements
                    this.tabs = _.compact(_.map(this.tabsElement().find("ers-tab:first-of-type, *~ers-tab"), function (tab) {
                        return angular.element(tab).controller("ersTab");
                    }));
                    // Check to see if any of the tabs are already active
                    _.each(this.tabs, function (tab) {
                        if (tab.active) {
                            _this.activeTab = tab;
                        }
                    });
                    // Check to see if the active tab is still in the list
                    if (this.activeTab && this.tabs.indexOf(this.activeTab) === -1) {
                        this.activeTab = null;
                    }
                    // Check to see if we actually changed anything
                    if (previousTabs !== this.tabs) {
                        this.sortableTabsChanged = true;
                    }
                };
                /**
                 * @private
                 *
                 * Updates the tabs that are partially or fully hidden.
                 *
                 */
                TabsetComponent.prototype.updateHiddenTabs = function () {
                    var hiddenTabIndexes = this.getHiddenTabIndexes();
                    this.leftHiddenTabs = [];
                    this.rightHiddenTabs = [];
                    var i, j;
                    // Update the left hidden tabs
                    for (i = 0; hiddenTabIndexes[i]; i++) {
                        this.leftHiddenTabs.push(this.tabs[i]);
                    }
                    // Update the right hidden tabs
                    for (j = hiddenTabIndexes.length - 1; hiddenTabIndexes[j]; j--) {
                        this.rightHiddenTabs.push(this.tabs[j]);
                    }
                    // The above for loop puts the tabs in reverse order, so we fix it here
                    this.rightHiddenTabs = this.rightHiddenTabs.reverse();
                    // Make sure we actually have tabs
                    this.leftHiddenTabs = _.compact(this.leftHiddenTabs);
                    this.rightHiddenTabs = _.compact(this.rightHiddenTabs);
                    this.updateDropdownMenu();
                };
                TabsetComponent.prototype.updateDropdownMenu = function () {
                    var _this = this;
                    this.menuItemsOfHiddenTabs = [].concat(this.leftHiddenTabs, this.rightHiddenTabs).map(function (tab, i) {
                        return {
                            label: tab.getFormattedHeading(),
                            action: function (o) { _this.selectTab(tab); },
                            separatorBefore: i !== 0 && i === _this.leftHiddenTabs.length
                        };
                    });
                };
                /**
                 *
                 * Programmatically add a tab to the end of this component's list of tabs.
                 *
                 * @param tab The tab to be added to the list of [[tabs]].
                 */
                TabsetComponent.prototype.addTab = function (tab) {
                    this.tabs.push(tab);
                    this.sortableTabsChanged = true;
                    // Make sure to call the layout function after we've added a tab in case it extends off the screen
                    // TODO: Should we instead assume that the user will do a $digest() similar to the removeTab method?
                    this.layout();
                };
                /**
                 * Programmatically remove a tab, no matter the position. If removing a tab from outside of Angular, manually
                 * run the `$digest() cycle to update scope.
                 *
                 *
                 * @param tabToRemove The tab that you wish to remove from the list of [[tabs]].
                 *
                 */
                TabsetComponent.prototype.removeTab = function (tabToRemove) {
                    // Ask the delegate if it can be removed (delegate.willRemoveTab())
                    if (this.delegate && this.delegate.willRemoveTab) {
                        if (!this.delegate.willRemoveTab(tabToRemove)) {
                            // If the delegate returns false, we should not remove the tab
                            return;
                        }
                    }
                    var index = this.tabs.indexOf(tabToRemove), isActive = (this.activeTab === tabToRemove);
                    // If the object was found and the index looks right
                    if (index >= 0 && index < this.tabs.length) {
                        // Remove the object from our list
                        this.tabs.splice(index, 1);
                        // Remove the tab's content (if any)
                        this.$element.find(".tab-content").first().find("> .tab-pane").eq(index).remove();
                        // Notify the delegate it has been removed
                        if (this.delegate && this.delegate.tabRemoved) {
                            this.delegate.tabRemoved(tabToRemove);
                        }
                        // Destroy the element
                        tabToRemove.destroy();
                    }
                    // Attempt to select the next (preferred) or previous tabs
                    if (isActive) {
                        this.setActiveTab(this.tabs[index]);
                    }
                    // Track that our sortable tabs have changed
                    this.sortableTabsChanged = true;
                    // Make sure to call the layout function after we've removed a tab in case it no longer extends off the screen
                    this.layout();
                };
                /**
                 * Set the next if possible active tab after
                 *
                 * @param tab the tab which becomes not visible
                 */
                TabsetComponent.prototype.setActiveTab = function (tab, ondelete) {
                    this.sortableTabsChanged = true;
                    // The tab was just hidden (not deleted), we have to check the next index.
                    var index = 0;
                    var count = this.tabs.indexOf(tab);
                    if (angular.isDefined(ondelete) && ondelete) {
                        // Set the next visible tab after the deleted one
                        count = (count + 1) % this.tabs.length;
                    }
                    while (index < this.tabs.length) {
                        if (this.tabs[count] != null && this.tabs[count].isVisible()) {
                            this.selectTab(this.tabs[count]);
                            // finish
                            return;
                        }
                        index++;
                        count = (count + 1) % this.tabs.length; // cyclic indexation
                    }
                    // from here, no tabs are activated
                    this.activeTab = null;
                };
                /**
                 * @private
                 *
                 * Return an array of boolean values describing whether or not the corresponding tab, by index, is hidden.
                 *
                 * @returns {boolean[]} Returns a list of the indexes of any hidden tabs.
                 */
                TabsetComponent.prototype.getHiddenTabIndexes = function () {
                    var tabContainer = this.tabsElement();
                    var containerWidth = this.$element.width();
                    var containerLeft = tabContainer.position().left;
                    var tabPositions = tabContainer.find("li").map(function () {
                        return {
                            width: $(this).width(), left: $(this).position().left
                        };
                    }).get();
                    return tabPositions.map(function (pos) {
                        var tabWidth = pos.width;
                        var tabLeft = pos.left;
                        var hiddenOnLeft = containerLeft + tabLeft < 0;
                        var hiddenOnRight = containerLeft + tabLeft + tabWidth > containerWidth;
                        return hiddenOnLeft || hiddenOnRight;
                    });
                };
                /**
                 * Returns the jQuery element used to display the tabs.
                 *
                 * @returns {JQuery} The jQuery element which wraps the actual HTML tab elements on the screen.
                 */
                TabsetComponent.prototype.tabsElement = function () {
                    return this.$element.find("ul.nav-tabs").first();
                };
                TabsetComponent.prototype.dropdownMenuId = function () {
                    var tbsId = this.$element != null ? this.$element.attr("id") : null;
                    // generates a specific ID for the context menu to display hidden tabs.
                    return tbsId != null ? "hiddentabs_" + tbsId : "";
                };
                /**
                 * The amount of padding for the fade effect.
                 *
                 * **Note:** This should match the fade image used in the CSS.
                 */
                TabsetComponent.FADE_PADDING = 30;
                /** Angular injection.*/
                TabsetComponent.$inject = ["$scope", "$parse", "$timeout", "containerEventService"];
                return TabsetComponent;
            })(BaseComponent);
            tabs.TabsetComponent = TabsetComponent;
        })(tabs = components.tabs || (components.tabs = {}));
    })(components = ers.components || (ers.components = {}));
})(ers || (ers = {}));/*
 * Created by FangioT on 2/4/2015.
 */
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};



/// <a href="#/components/ersTabset/documentation">ers-tabset
/// <a ui-sref="directives.ersTabset.overview">ersTabset</a>(not working)

/**
 * @ngdoc directive
 * @module ers.components.tabs
 * @name ersTab
 * @restrict E
 * @transclude
 * @scope
 *
 *
 * @description
 *
 * The `ers.components.tabs` module comprises two elements:
 *
 *  - ers-tabset&#151;Wraps the tabs that you wish to display (this directive).
 *  - ers-tab&#151;Creates a selectable tab, a tab heading,
 *  and a corresponding sheet containing tab content.
 *
 * ### Usage
 *
 * - Use `ers-tabset` as the envelope to group `ers-tabs` into logical groups that display sheets of information.
 * - The sheets are the containers holding the tab content. Primary Tabs are at the top of sheets providing
 * the main label, or the name of the sheet. Use `ers-tabset` to create additional tab levels under the primary tab.
 * - `ers-tabset` uses the _class_ attribute (&lt;ers-tabset class="secondary"&gt;) {{tab}} to define sub-tabs
 * within a sheet. You can transclude the tab header and content.
 *
 *
 * ### Examples
 *
 * #### Primary Tabs
 *
 * <code-editor identifier="example1" data-title="Primary Tabs" html-content-url="demos/ersTabset/basicUsage/index.html"
 * js-content-url="demos/ersTabset/basicUsage/script.js" css-content-url="demos/ersTabset/basicUsage/styles.css"
 * content-mode="html"></code-editor>
 *
 * #### Secondary Tabs
 *
 * <code-editor identifier="example2" data-title="Secondary Tabs"
 * html-content-url="demos/ersTabset/secondaryTabs/index.html"
 * js-content-url="demos/ersTabset/secondaryTabs/script.js"
 * css-content-url="demos/ersTabset/secondaryTabs/styles.css"
 * content-mode="html"></code-editor>
 *
 * #### Nested Tabs
 *
 * <code-editor identifier="example3" data-title="Nested Tabs" html-content-url="demos/ersTabset/nestedTabs/index.html"
 * js-content-url="demos/ersTabset/nestedTabs/script.js" css-content-url="demos/ersTabset/nestedTabs/styles.css"
 * content-mode="html"></code-editor>
 *
 * #### Close Tabs
 *
 * The example with ability to close the tabs
 *
 * <code-editor identifier="example4" data-title="Close Tabs" html-content-url="demos/ersTabset/closeTabs/index.html"
 * js-content-url="demos/ersTabset/closeTabs/script.js" css-content-url="demos/ersTabset/closeTabs/styles.css"
 * content-mode="html"></code-editor>
 *
 * #### Responsive Tabs
 *
 * <code-editor identifier="example5" data-title="Nested Tabs"
 * html-content-url="demos/ersTabset/responsiveTabs/index.html"
 * js-content-url="demos/ersTabset/responsiveTabs/script.js"
 * css-content-url="demos/ersTabset/responsiveTabs/styles.css"
 * content-mode="html"></code-editor>
 *
 * #### Error Tabs
 *
 * The example with error indication for 'Tab 2'
 *
 * <code-editor identifier="example6" data-title="Error Tabs"
 * html-content-url="demos/ersTabset/errorTabs/index.html"
 * js-content-url="demos/ersTabset/errorTabs/script.js"
 * css-content-url="demos/ersTabset/errorTabs/styles.css"
 * content-mode="html"></code-editor>
 *
 * ### Design Guidelines
 *
 * Use `ers-tabset` where you are designing grouped content such as forms, settings, and grids, to provide
 * a consistent level of navigation between similar modules of your application.
 *
 * ##### Styles
 *
 * There are two levels of visual tabset:
 *
 * - Primary&#151;Used at the tops of pages to provide navigation between elements.
 * - Secondary&#151;Used beneath Primary tabset for an additional levels of navigation.
 *
 * ##### Best Practices
 *
 * Consider the following principles and best practices when designing the user interface with these components:
 *
 * - Use only one primary tabset per page to maintain proper visual hierarchy.
 * - Primary tabsets should always appear above secondary tabsets.
 * - Do not stack secondary tabsets as this may cause confusion to the user.
 * - Always place the secondary tabset inside of the primary tabset content to ensure that the tab
 *   switching animation applies to all of the content.
 *
 * ### Accessibility Guidelines
 *
 * No accessibility guidelines.
 *
 * @param {string} heading {@?}
 *
 * Specifies the text to be displayed in the tab title (selection) area. Use only text, not HTML. To add an HTML tag or
 * an icon, use the `tab-heading` element. Title text can be transcluded.
 *
 *
 * ##### Example - Basic Heading
 *
 * ```xml
 * <ers-tab heading="My Heading"></ers-tab>
 * ```
 *
 * ##### Example - HTML Heading
 *
 * ```xml
 * <ers-tab><tab-heading><i class='fa fa-user'></i> Users</tab-heading></ers-tab>
 * ```
 *
 * @param {boolean} [active] {=?}
 * (ers-tab) Whether or not this tab should be active.
 *
 * ```xml
 * <ers-tab heading="Test Active" active="myCtrl.active"></ers-tab>
 * ```
 *
 * @param {string[]} [errors] {=?}
 * (ers-tab) Adds a red dot to the tab indicating an error associated with the tab. These error message are not
 * displayed to the user.
 *
 * ```xml
 * <ers-tab heading="Contact Us" errors="MyCtrl.tabs['contact-us'].errors"></ers-tab>
 * ```
 *
 * @param {expression} [select] {&?}
 * (ers-tab) Sets the action invoked when the tab is selected or gains focus.
 *
 * ```xml
 * <ers-tab select="MyCtrl.tabSelected()"></ers-tab>
 * ```
 *
 * @param {expression} [deselect] {&?}
 * (ers-tab) Sets the action invoked when the tab loses focus, or is deselected.
 *
 * ```xml
 * <ers-tab deselect="MyCtrl.tabDeselected()"></ers-tab>
 * ```
 *
 * @param {expression} [close] {&?}
 * (ers-tab) Sets the action invoked when this tab is closed and removed from the list
 * of tabs.
 *
 * ```xml
 * <ers-tab close="MyCtrl.tabClosed()"></ers-tab>
 * ```
 *
 * @param {boolean} [auto-activate-first-tab] {=?}
 *
 * (ers-tabset) Specifies whether or not the first tab is automatically activated when the tabs are loaded.
 * This allows the developer to choose the tab to activate when a page opens.
 *
 * @param {boolean} [can-close] {=?}
 *
 * (ers-tabset) Specifies whether or not a tab can be closed. When true, the tabs display a 'close' icon at the top right
 * of the tab during a mouse-over or hover.
 *
 * @param {boolean} [can-close-single=true] {=?}
 *
 * (ers-tabset) Specifies whether or not the last tab can be closed. This is only relevant when `can-close` is set to `true`.
 *
 * @param {boolean} [can-sort] {=?}
 *
 * (ers-tabset) Specifies if tab sorting is allowed. If true, you can click and drag the tabs to rearrange them within the
 * current list of tabs.
 *
 * @param {expression} [sort]  {@?}
 *
 * (ers-tabset) An Angular expression that is evaluated when a sort occurs.
 *
 * The expression accesses the `$event` object which is a jQuery event and provides the following additional properties:
 *
 *  - `sortOrder` - An array of indices representing the order of the tabs after the sort.
 *
 *    For example, if the first and second indices were swapped this may return `[0,2,1,3]`, allowoing you
 *    to determine the new order of your array:
 *
 *    ```js
 *    var newTabs = _.map($event.sortOrder, function(order) {
 *      return oldTabs[order];
 *    });
 *    ```
 */
var ers;
(function (ers) {
    var components;
    (function (components) {
        var tabs;
        (function (tabs) {
                        // Import our relevant dependencies
            var BaseComponent = ers.components.core.BaseController;
            angular.module("ers.components.tabs").directive("ersTabHeadingTransclude", function () {
                return {
                    restrict: "A",
                    require: "^ersTab",
                    link: function (scope, el, attrs, controller) {
                        var ctrl = controller;
                        // Watch heading to update content
                        ctrl.addHeadingWatcher(el);
                    }
                };
            });
            angular.module("ers.components.tabs").directive("ersTabContentTransclude", function () {
                return {
                    link: function (scope, elem, attrs) {
                        var tab = scope.$eval(attrs.ersTabContentTransclude);
                        // Tab's content treatment => Do the transclusion
                        tab.$trancludeFn(tab.getScope().$parent, function (contents) {
                            angular.forEach(contents, function (node) {
                                if (tab.isHeadingTab(node)) {
                                    tab.headingElement = node;
                                }
                                else {
                                    elem.append(node);
                                }
                            });
                        });
                    }
                };
            });
            // Define our directives
            angular.module("ers.components.tabs").directive("ersTab", function () {
                return {
                    restrict: "E",
                    transclude: true,
                    require: ["ersTab", "^ersTabset"],
                    scope: {
                        // Available properties
                        active: "=?", heading: "@?", errors: "=?",
                        // Available methods
                        select: "&?", deselect: "&?", close: "&?",
                        ngShow: "=?"
                    },
                    controller: TabComponent, controllerAs: "vm", bindToController: true,
                    templateUrl: "tabs/template/tab-template.html",
                    link: function (scope, el, attrs, controllers, transclude) {
                        var ctrl = controllers[0];
                        var tabsetCtrl = controllers[1];
                        // Call the link function with 'this' set to the directive's controller
                        ctrl.linkWithTabset.call(ctrl, scope, el, attrs, tabsetCtrl, transclude);
                    }
                };
            });
            /**
             *
             * This is the controller class for the ersTab directive that handles all business logic for the tabs.
             *
             */
            var TabComponent = (function (_super) {
                __extends(TabComponent, _super);
                /**
                 * Creates a new instance of the TabComponent.
                 *
                 * *Note* As this method is called automatically by Angular when it sees a matching directive, it is rarely
                 * instantiated by code.
                 *
                 * @param scope The scope to which this TabComponent is bound.
                 */
                function TabComponent($scope, $element, $timeout) {
                    _super.call(this, $scope, $element);
                    this.internalActive = false;
                    this.$timeout = $timeout;
                }
                /**
                 * @private
                 *
                 * Called by the [[linkWithTabset]] method when linking the directive.
                 */
                TabComponent.prototype.link = function (scope, el, attrs) {
                    _super.prototype.link.call(this, scope, el, attrs);
                    if (angular.isDefined(this.active)) {
                        this.internalActive = this.active;
                    }
                    this.$element.addClass("ers-tab");
                };
                /**
                 * @private
                 *
                 * Called by the Angular directive when linking this controller to the directive.
                 *
                 * @param scope The scope to which this controller/directive is bound.
                 * @param el The DOM element to which this controller/directive is bound.
                 * @param attrs The attributes assigned to the directive.
                 * @param tabset The parent [[TabsetComponent]] instance.
                 * @param transclude The Angular transclude function that will return the compiled contents of the tab.
                 */
                TabComponent.prototype.linkWithTabset = function (scope, el, attrs, tabset, transclude) {
                    var _this = this;
                    // Store a reference to our parent tabset
                    this.tabset = tabset;
                    // Run the regular link function
                    this.link(scope, el, attrs);
                    // Store the transclusion function, and wait until the content will be ready
                    this.$trancludeFn = transclude;
                    // Set listener
                    this.setListeners();
                    // awful hack to synchronize the list of tabs
                    // A new tab is being created => should notify the tabset to rebuild its layout in case of ng-repeat, ng-if...
                    // => tab content will be created even if the tab is not the selected one.
                    this.$timeout(function () {
                        _this.tabset.layout();
                    }, 0);
                };
                /**
                 * @protected
                 *
                 * Listener events.
                 */
                TabComponent.prototype.setListeners = function () {
                    var _this = this;
                    // In case of element is deleted (nf-if, ...)
                    this.$scope.$on("$destroy", function () {
                        if (_this.active) {
                            _this.tabset.setActiveTab(_this, true);
                        }
                        // awful hack to synchronize the list of tabs
                        // the tab is being destroyed (ng-if or ng-repeater or ...) => tabset should be notified to rebuild the layout...
                        // unfortunately the tabset not does manage dynamic number of tabs... so it should be notified to synchronize its layout...
                        // $timeout is mandatory because tabset synchronizes its internal tabs array from the DOM, and at this moment,
                        // the tab is still in the DOM, so tabset should be notified to update the layout after the tab was removed from the DOM...
                        _this.$timeout(function () {
                            if (!_this.active) {
                                _this.tabset.layout();
                            }
                        }, 0, false);
                    });
                };
                /**
                 *
                 * Listener heading content change.
                 *
                 * @param element new element
                 */
                TabComponent.prototype.addHeadingWatcher = function (element) {
                    var _this = this;
                    this.$scope.$watch(function () {
                        return _this.headingElement;
                    }, function (heading) {
                        if (heading) {
                            if (_this.isHeadingTab(heading)) {
                                // Clear node and append heading content
                                element.html("");
                                element.append(heading);
                            }
                        }
                    });
                };
                /**
                 * @private
                 *
                 * Called by the directive's template when a tab is clicked or selected.
                 *
                 */
                TabComponent.prototype.onSelect = function () {
                    this.tabset.selectTab(this);
                };
                /**
                 * @private
                 *
                 * Called by the directive's template when a tab is closed using the remove icon.
                 */
                TabComponent.prototype.onClose = function () {
                    this.tabset.removeTab(this);
                };
                /**
                 *
                 * Activates the tab and evaluates the code in the [[select]] option, if provided.
                 *
                 */
                TabComponent.prototype.activate = function () {
                    this.active = true;
                    // Call the scope's select() method if provided
                    if (this.select) {
                        this.select();
                    }
                };
                /**
                 *
                 * De-activates the tab and evaluates the code in the [[deselect]] option, if provided.
                 *
                 */
                TabComponent.prototype.deactivate = function () {
                    this.active = false;
                    // Call the scope's deselect() method if provided
                    if (this.deselect) {
                        this.deselect();
                    }
                };
                /**
                 *
                 * Cleans up the directive or controller when the element is being removed from the list of tabs.
                 *
                 */
                TabComponent.prototype.destroy = function () {
                    // Call the scope's close() method if provided
                    if (this.close) {
                        this.close();
                    }
                    // Destroy the scope
                    this.$scope.$destroy();
                    // THEN remove the element from the DOM
                    this.$element.remove();
                };
                /**
                 * @public
                 *
                 * Getter to the directive scope.
                 *
                 * @returns {ng.IScope} the diretcive scope
                 */
                TabComponent.prototype.getScope = function () {
                    return this.$scope;
                };
                /**
                 * @private
                 *
                 * Tests whether or not the requested DOM element is a tab heading element.
                 *
                 * @param node The node which we would like to test.
                 *
                 * @returns {string|boolean} True if the requested node is a tab heading node.
                 */
                TabComponent.prototype.isHeadingTab = function (node) {
                    return node.tagName && (node.hasAttribute("tab-heading") || node.hasAttribute("data-tab-heading") ||
                        node.tagName.toLowerCase() === "tab-heading" || node.tagName.toLowerCase() === "data-tab-heading");
                };
                /**
                 * @public
                 *
                 * Get the formatted heading tab.
                 *
                 * @returns {string} the formatted heading tab
                 */
                TabComponent.prototype.getFormattedHeading = function () {
                    // Case 1: heading element is known get its html for the context menu item.
                    if (this.headingElement && angular.isDefined(this.headingElement)) {
                        return this.headingElement.innerHTML;
                    }
                    // Case 2: no html element, but heading attribute is set, use it for the context menu item.
                    if (this.heading && this.heading.length > 0) {
                        return this.heading;
                    }
                    // Case 3: empty string
                    return "";
                };
                /**
                 * Check if the tab is visible.
                 *
                 * @returns {boolean} trie if visible else false
                 */
                TabComponent.prototype.isVisible = function () {
                    return (!angular.isDefined(this.ngShow) && this.$element.is(":visible")) || this.ngShow;
                };
                Object.defineProperty(TabComponent.prototype, "ngShow", {
                    /**
                     *
                     * Getter on the ngShow directive attribute.
                     *
                     * @returns {boolean} Returns the ngShow value.
                     */
                    get: function () {
                        return this._ngShow;
                    },
                    /**
                     *
                     * Setter on the ngShow directive attribute.
                     *
                     * @param value If true, the hidden tabs are deactivated.
                     *
                     */
                    set: function (show) {
                        this._ngShow = show;
                        if (!this._ngShow && this.internalActive) {
                            this.deactivate();
                        }
                        // Notify change to tabset
                        if (this.tabset != null && this.tabset.activeTab === this) {
                            this.tabset.setActiveTab(this);
                        }
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(TabComponent.prototype, "active", {
                    get: function () {
                        return this._active;
                    },
                    set: function (state) {
                        this._active = state;
                        this.internalActive = state;
                        /* for-loop prevents multiple sibling tabs from being active at the same time*/
                        if (this.tabset) {
                            for (var i = 0; i < this.tabset.tabs.length; i++) {
                                if (this._active && this.tabset.tabs[i]._active && (this.heading !== this.tabset.tabs[i].heading)) {
                                    this.tabset.tabs[i]._active = false;
                                }
                            }
                        }
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 *
                 * Angular injection.
                 *
                 */
                TabComponent.$inject = ["$scope", "$element", "$timeout"];
                return TabComponent;
            })(BaseComponent);
            tabs.TabComponent = TabComponent;
        })(tabs = components.tabs || (components.tabs = {}));
    })(components = ers.components || (ers.components = {}));
})(ers || (ers = {}));/*
 * Created by fangiot on 12/14/2014.
 */

var ers;
(function (ers) {
    var components;
    (function (components) {
        var tabs;
        (function (tabs) {
                    })(tabs = components.tabs || (components.tabs = {}));
    })(components = ers.components || (ers.components = {}));
})(ers || (ers = {}));/*
 * Created by fangiot on 12/12/2014.
 */



var ers;
(function (ers) {
    var components;
    (function (components) {
        var tabs;
        (function (tabs) {
                    })(tabs = components.tabs || (components.tabs = {}));
    })(components = ers.components || (ers.components = {}));
})(ers || (ers = {}));
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};



/**
 * @ngdoc directive
 * @name ersTextbox
 * @restrict E
 * @module ers.components.textbox
 * @scope
 *
 * @description
 * Use the `ers-textbox` to create an input that accepts any form of text.
 *
 * ### Usage
 *
 * - Use `ng-readonly` or `ng-disabled` to set optional `ers-textbox` states.
 * - Use the textboxes with ng-minlength, ng-maxlength, ng-required and ng-pattern attributes.
 *
 * ### Examples
 *
 * #### Basic Textbox
 *
 * <code-editor identifier="example1" data-title="Basic Textbox" html-content-url="demos/ersTextbox/basicUsage/index.html"
 * js-content-url="demos/ersTextbox/basicUsage/script.js" css-content-url="demos/ersTextbox/basicUsage/styles.css"
 * content-mode="html"></code-editor>
 *
 * #### Other Usage
 *
 * Textboxes with `ng-minlength`, `ng-maxlength`, `ng-required` and `ng-pattern` attributes.
 *
 * <code-editor identifier="example2" data-title="Textbox attributes" html-content-url="demos/ersTextbox/otherUsage/index.html"
 * js-content-url="demos/ersTextbox/otherUsage/script.js" css-content-url="demos/ersTextbox/otherUsage/styles.css"
 * content-mode="html"></code-editor>
 *
 * ### Design Guidelines
 *
 * Use `ers-textbox` anywhere the user is asked to input short text-based content such as login forms,
 * data entry, etc. Do not use the textbox it if you are asking the user for
 * a significant amount of text input spanning multiple lines.
 *
 * ### Accessibility Guidelines
 *
 * No accessibility guidelines.
 *
 * @param {string} [name] {@}
 *
 * Specifies the text box form name. The form name must be unique within the form.
 *
 * @param {string} [placeholder] {@}
 *
 * Specifies  the ghost text that appears when the value is empty. Uses the standard HTML5 placeholder attribute.
 *
 * @param {expression} [ng-model] {=}
 *
 * Specifies the Angular model object which is bound to the text box's value.
 *
 * @param {expression} [ng-change="expression"] {&?}
 *
 * Evaluates the textbox for user input changes and notifies scope immediately, unlike the JavaScript
 * onCharge event which only notifies scope when the textbox loses focus.
 *
 * @param {boolean} [ng-disabled=false] {=?}
 *
 * Specifies  the disabled mode and is used in conjunction with the edit mode to prevent user entry in the specified text box.
 *
 * @param {boolean} [ng-readonly=false] {=?}
 *
 * Specifies  the read only option to non-editable mode.
 *
 * @param {boolean} [ng-required=false] {=?}
 *
 * Specifies the text box value as required or not. The available values are true or false. The default is false.
 *
 * @param {string} [ng-pattern] {=?}
 *
 * Specifies  a user-specified validation on the entered text. When this attribute is not used the application does not
 * check the content of the box.
 *
 * @param {boolean} [password=false] {=}
 *
 * Specifies password constraints (prevent copy, characters are not readable) when enabled.
 * The default value is `false`.
 *
 * @param {number} [ng-minlength] {=?}
 *
 * Specifies a minimum length constraint to the user entered text. There is no default value.
 *
 * @param {number} [ng-maxlength] {=?}
 *
 * Specifies a maximum length constraint for the user entered text. There is no default value.
 *
 * @param {string} [text-align] {@?}
 *
 * Specifies the text box alignment value. Expected values are 'right', 'left', or 'center'. The default value is 'left'.
 *
 *
 */
var ers;
(function (ers) {
    var components;
    (function (components) {
        var textbox;
        (function (textbox) {
                        angular.module("ers.components.textbox", ["ers.components.core", "ngMessages"]).directive("ersTextbox", function () {
                return {
                    restrict: "E",
                    templateUrl: "textbox/template/textbox-template.html",
                    controller: TextboxComponent,
                    controllerAs: "c",
                    bindToController: true,
                    scope: {
                        "name": "@",
                        "placeholder": "@",
                        "ngModel": "=",
                        "readOnly": "=?ngReadonly",
                        "ngDisabled": "=?",
                        "textAlign": "@?",
                        "minLength": "=?ngMinlength",
                        "maxLength": "=?ngMaxlength",
                        "required": "=?ngRequired",
                        "textPattern": "=?ngPattern",
                        "password": "="
                    },
                    link: function ($scope, $element, $attrs, component) {
                        component.link();
                    }
                };
            });
            var DEFAULT_VALIDATION_RULES = ers.components.utility.DEFAULT_VALIDATION_RULES;
            var InputComponent = ers.components.core.InputComponent;
            /**
             * @tag ers-textbox
             * @restrict E
             *
             * ### Description
             *
             * Use the <code>ers-textbox</code> component to create a textbox.
             *
             */
            var TextboxComponent = (function (_super) {
                __extends(TextboxComponent, _super);
                /**
                 * Constructor.
                 *
                 * @param $element The component element.
                 * @param $timeout Angular timeout service. Currently used to execute a function when the model
                 * controller is fully loaded.
                 *
                 */
                function TextboxComponent($scope, $element, $attrs, $timeout, vm, $exceptionHandler) {
                    _super.call(this, $scope, $element, $attrs, $timeout, vm, $exceptionHandler);
                    // Set the textbox CSS class.
                    $element.addClass("ers-textbox");
                }
                /**
                 * @Override from InputComponent#configureRender.
                 *
                 * The method used to configure the render.
                 *
                 */
                TextboxComponent.prototype.configureRender = function () {
                    var _this = this;
                    _super.prototype.configureRender.call(this);
                    this.ngModelController.$render = function () {
                        _this.inputComponent.val(_this.ngModelController.$viewValue);
                    };
                };
                Object.defineProperty(TextboxComponent.prototype, "password", {
                    /**
                     *
                     * Retrieves the password input constraint.
                     *
                     * @returns {boolean} Returns true if the password input constraint is enabled, otherwise false.
                     *
                     */
                    get: function () {
                        return this._password;
                    },
                    /**
                     *
                     * Update the input password constraint state.
                     *
                     * @param value The password constraint state.
                     */
                    set: function (value) {
                        this._password = value;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(TextboxComponent.prototype, "maxLength", {
                    /**
                     * Retrieves the maximum length constraint value.
                     *
                     * @returns {number} Returns the maximum length constraint value.
                     *
                     */
                    get: function () {
                        return this._maxLength;
                    },
                    /**
                     *
                     * Update the maximum length constraint value.
                     *
                     * @param value The maximum length constraint.
                     *
                     */
                    set: function (value) {
                        this._maxLength = value;
                        if (angular.isDefined(this.ngModelController)) {
                            this.ngModelController.$validate();
                            this.vm.reloadMessage(this);
                        }
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(TextboxComponent.prototype, "minLength", {
                    /**
                     *
                     * Retrieves the minimum length constraint value.
                     *
                     * @returns {number} Returns the minimum length constraint value.
                     *
                     */
                    get: function () {
                        return this._minLength;
                    },
                    /**
                     *
                     * Update the minimum length constraint value.
                     *
                     * @param value The minimum length constraint.
                     *
                     */
                    set: function (value) {
                        this._minLength = value;
                        if (angular.isDefined(this.ngModelController)) {
                            this.ngModelController.$validate();
                            this.vm.reloadMessage(this);
                        }
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 *
                 * @Override super method
                 *
                 */
                TextboxComponent.prototype.validationRules = function () {
                    var _this = this;
                    var textboxRules = [];
                    // ngMinlength validator.
                    var minLengthRule = DEFAULT_VALIDATION_RULES.MIN_LENGTH(this.minLength);
                    minLengthRule.validator = function (modelValue) {
                        return angular.isUndefined(_this.minLength) || angular.isUndefined(modelValue) || modelValue === null ||
                            (modelValue.length === 0 || modelValue.length >= _this.minLength);
                    };
                    textboxRules.push(minLengthRule);
                    // ngMaxlength validator.
                    var maxLengthRule = DEFAULT_VALIDATION_RULES.MAX_LENGTH(this.maxLength);
                    maxLengthRule.validator = function (modelValue) {
                        return angular.isUndefined(_this.maxLength) || angular.isUndefined(modelValue) || modelValue === null ||
                            modelValue.length <= _this.maxLength;
                    };
                    textboxRules.push(maxLengthRule);
                    return _super.prototype.validationRules.call(this).concat(textboxRules);
                };
                TextboxComponent.$inject = ["$scope", "$element", "$attrs", "$timeout", "validationManager", "$exceptionHandler"];
                return TextboxComponent;
            })(InputComponent);
            textbox.TextboxComponent = TextboxComponent;
        })(textbox = components.textbox || (components.textbox = {}));
    })(components = ers.components || (ers.components = {}));
})(ers || (ers = {}));
var ers;
(function (ers) {
    var components;
    (function (components) {
        var toolbar;
        (function (toolbar) {
                    })(toolbar = components.toolbar || (components.toolbar = {}));
    })(components = ers.components || (ers.components = {}));
})(ers || (ers = {}));

// only declare angular module
angular.module("ers.components.toolbar", ["ers.components.core"]);



var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var ers;
(function (ers) {
    var components;
    (function (components) {
        var toolbar;
        (function (toolbar) {
                        /**
            *
            * @ngdoc directive
            * @module ers.components.toolbar
            * @scope
            * @transclude
            * @data
            * @binding
            * @name ersToolbar
            * @restrict E
            * @constructor
            *
            * @description
            *
            * A toolbar groups a set of icons and buttons.
            *
            * - A toolbar is a set of icons that serve as a visual indicator on the UI
            * - Icons within a toolbar may represent specific actions or commands
            * - Toolbars can be placed horizontally or vertically
            *
            * ### Usage
            *
            * - Toolbars are used above a component such as grid, form, etc.
            * -	Toolbars are generally placed within a panel container (best practices)
            * - You may use a separator to group a set of actions within a toolbar
            *
            * ### Examples
            *
            * ##### Horizontal Toolbar
            *
            * Example of a horizontal toolbar placed above a gird (table).
            *
            * <code-editor identifier="example1" data-title="Basic Toolbar" html-content-url="demos/ersToolbar/basic/index.html"
            * js-content-url="demos/ersToolbar/basic/script.js" css-content-url="demos/ersToolbar/basic/styles.css"
            * content-mode="html"></code-editor>
            *
            * ##### Vertical Toolbar
            *
            * Example of a vertical toolbar.
            *
            * <code-editor identifier="example2" data-title="Vertical Toolbar" html-content-url="demos/ersToolbar/vertical/index.html"
            * js-content-url="demos/ersToolbar/vertical/script.js" css-content-url="demos/ersToolbar/vertical/styles.css"
            * content-mode="html"></code-editor>
            *
            * ### Design Guidelines
            *
            * No design guidelines.
            *
            * ### Accessibility Guidelines
            *
            * No accessibility guidelines.
            *
            * - All icons within a toolbar should have a tooltip
            *
            * @param { string } [direction] {=}
            * Set the direction of the Toolbar.Possible choices are 'horizontal' or 'vertical'
            * Default is horizontal.
            *
            * @param { string } [spacing] {=}
            *
            * Sets the spacing between elements displayed in the toolbar. The value is a number without any unit type specified.
            * The default is 5px.
            *
            */
            angular.module("ers.components.toolbar", ["ers.components.core"]).directive("ersToolbar", function () {
                return {
                    restrict: "E",
                    templateUrl: "toolbar/template/toolbar-template.html",
                    transclude: true,
                    scope: {
                        direction: "@?", spacing: "@?"
                    },
                    bindToController: true,
                    controller: ToolbarComponent,
                    controllerAs: "toolbarController",
                    link: function ($scope, $element, $attributes) {
                        var ctrl = $element.controller("ersToolbar");
                        ctrl.link($scope, $element, $attributes);
                    }
                };
            });
            var BaseComponent = ers.components.core.BaseComponent;
            /**
             * Toolbar Directive
             * Main class for the toolbar component.
             */
            var ToolbarComponent = (function (_super) {
                __extends(ToolbarComponent, _super);
                /**
                 * Class constructor.
                 * @param $scope directive's scope.
                 * @param $element directive's root element.
                 * @param $attrs directive's attributes.
                 */
                function ToolbarComponent($scope, $element, $attrs) {
                    _super.call(this, $scope, $element, $attrs);
                    // Default
                    this.direction = $scope.direction || ToolbarComponent.HZ_DIRECTION;
                    if ($scope.spacing == null || $scope.spacing.length < 1) {
                        this.spacing = ToolbarComponent.SPACING;
                    }
                    else {
                        this.spacing = $scope.spacing;
                    }
                }
                /**
                 * Allowed way to manipulate DOM, set watchers, ...
                 * @param $scope the directive scope
                 * @param $element DOM element (directive start)
                 * @param $attributes DOM attributes
                 */
                ToolbarComponent.prototype.link = function ($scope, $element, $attributes) {
                    _super.prototype.link.call(this, $scope, $element, $attributes);
                    // Add ers class
                    this.divContainer = this.$element.find(".toolbar-container");
                    // Add watchers
                    this.addWatchers();
                };
                /**
                 * Inspect dynamic DOM element.
                 */
                ToolbarComponent.prototype.addWatchers = function () {
                    var _this = this;
                    // Watch direction
                    this.$scope.$watch(function () {
                        return _this.direction;
                    }, function () {
                        _this.renderUpdate();
                    });
                    // Watch direction
                    this.$scope.$watch(function () {
                        return _this.spacing;
                    }, function () {
                        _this.renderUpdate();
                    });
                };
                /**
                 * Update display.
                 */
                ToolbarComponent.prototype.renderUpdate = function () {
                    var isVertical = this.direction === ToolbarComponent.VT_DIRECTION;
                    // Replace main alignment
                    this.divContainer.toggleClass("toolbar-vt", !isVertical);
                    this.divContainer.toggleClass("toolbar-hz", isVertical);
                    // Update all separator (if exist)
                    this.$element.find(".ers-toolbar-separator").toggleClass("hz-separator", isVertical);
                    this.$element.find(".ers-toolbar-separator").toggleClass("vt-separator", !isVertical);
                    // Update spacing if needed
                    if (isVertical) {
                        this.divContainer.children().css("margin-top", this.spacing + "px");
                        this.divContainer.children().css("margin-left", ToolbarComponent.SPACING + "px");
                    }
                    else {
                        this.divContainer.children().css("margin-left", this.spacing + "px");
                        this.divContainer.children().css("margin-top", ToolbarComponent.SPACING + "px");
                    }
                };
                /** Constants */
                ToolbarComponent.VT_DIRECTION = "vertical";
                ToolbarComponent.HZ_DIRECTION = "horizontal";
                ToolbarComponent.SPACING = "5";
                /** Services injection  */
                ToolbarComponent.$inject = ["$scope", "$element", "$attrs"];
                return ToolbarComponent;
            })(BaseComponent);
            toolbar.ToolbarComponent = ToolbarComponent;
        })(toolbar = components.toolbar || (components.toolbar = {}));
    })(components = ers.components || (ers.components = {}));
})(ers || (ers = {}));


var ers;
(function (ers) {
    var components;
    (function (components) {
        var toolbar;
        (function (toolbar) {
                        var toolbarSeparatorDirective = function () {
                return {
                    restrict: "E",
                    template: "<div class='ers-toolbar-separator'></div>",
                    require: "^ersToolbar"
                };
            };
            angular.module("ers.components.toolbar").directive("ersToolbarSeparator", toolbarSeparatorDirective);
        })(toolbar = components.toolbar || (components.toolbar = {}));
    })(components = ers.components || (ers.components = {}));
})(ers || (ers = {}));
;/**
 * Created by zhangfa on 3/19/2015.
 */
/**
 * Created by zhangfa on 3/19/2015.
 */
/*
 * Created by zhangfa on 3/18/2015.
 */





var ers;
(function (ers) {
    var components;
    (function (components) {
        var tooltip;
        (function (tooltip) {
            tooltip._module = angular.module("ers.components.tooltip", ["ers.components.popover"]);
        })(tooltip = components.tooltip || (components.tooltip = {}));
    })(components = ers.components || (ers.components = {}));
})(ers || (ers = {}));/**
 * Created by zhangfa on 7/3/2015.
 */
/**
 * Created by zhangfa on 7/1/2015.
 */
/**
 * Created by zhangfa on 7/6/2015.
 */
/**
 * Created by zhangfa on 7/15/2015.
 */
/**
 * Created by zhangfa on 7/9/2015.
 */
/*
 * Created by zhangfa on 7/20/2015.
 */

var ers;
(function (ers) {
    var components;
    (function (components) {
        var tree;
        (function (tree) {
            tree.CONSTANTS = {
                DATA_FORMAT: "tree-item-data",
                TREE_ITEM_MIDDLE_RANGE: 12,
                DRAG_OVER_CLASS: "drag-over",
                DRAGGING_SOURCE_CLASS: "dragging-source",
                DROP_EFFECT_ALLOWED: "move",
                DRAG_INDICATOR_TEMPLATE: "<li class='drag-indicator'></li>"
            };
        })(tree = components.tree || (components.tree = {}));
    })(components = ers.components || (ers.components = {}));
})(ers || (ers = {}));/*
 * The Tree Component Module
 *
 * Created by zhangfa on 7/1/2015.
 */







var ers;
(function (ers) {
    var components;
    (function (components) {
        var tree;
        (function (tree) {
            tree._module = angular.module("ers.components.tree", ["ngSanitize", "ers.components.label"]);
        })(tree = components.tree || (components.tree = {}));
    })(components = ers.components || (ers.components = {}));
})(ers || (ers = {}));// Created by ZhangFa on 6/13/2015.

var ers;
(function (ers) {
    var components;
    (function (components) {
        var contextmenu;
        (function (contextmenu) {
            /**
             * Creates a bindable object from a menu item.
             */
            var BindMenuItem = (function () {
                /**
                 * Default Constructor.
                 * @param Item [[IMenuItem]].
                 * @param Context Scope.
                 */
                function BindMenuItem(item, context) {
                    this.item = item;
                    this.context = context;
                }
                Object.defineProperty(BindMenuItem.prototype, "separatorBefore", {
                    /** True if there is a separator immediately before the menu item.  */
                    get: function () {
                        return this.item.separatorBefore;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(BindMenuItem.prototype, "enabled", {
                    /**
                     * @returns {boolean} True if the linked scope defines the current menu item as enabled.
                     */
                    get: function () {
                        if (angular.isUndefined(this.item.enabled)) {
                            return true; // enabled by default
                        }
                        if (angular.isFunction(this.item.enabled)) {
                            return this.item.enabled(this.context);
                        }
                        return this.item.enabled;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(BindMenuItem.prototype, "visible", {
                    /**
                     * @returns {boolean} True if the linked scope defines the current menu item as visible.
                     */
                    get: function () {
                        if (angular.isUndefined(this.item.visible)) {
                            return true; // visible by default
                        }
                        if (angular.isFunction(this.item.visible)) {
                            return this.item.visible(this.context);
                        }
                        return this.item.visible;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(BindMenuItem.prototype, "label", {
                    /**
                     * @returns {string} The current item label as defined by the linked scope.
                     */
                    get: function () {
                        if (angular.isFunction(this.item.label)) {
                            return this.item.label(this.context);
                        }
                        return this.item.label;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(BindMenuItem.prototype, "icon", {
                    /**
                     * @returns {string} The current item icon name as defined by the linked scope.
                     */
                    get: function () {
                        if (angular.isFunction(this.item.icon)) {
                            return this.item.icon(this.context);
                        }
                        return this.item.icon;
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * The action the event handler executes on a mouse click.
                 * @param e Click event.
                 */
                BindMenuItem.prototype.onClick = function (e) {
                    if (!this.enabled) {
                        e.preventDefault();
                        e.stopPropagation();
                        return;
                    }
                    this.item.action(this.context, e);
                };
                Object.defineProperty(BindMenuItem.prototype, "children", {
                    /**
                     * @returns {IBindMenuItem[]} An array from BindMenuItem propagated from the item menu children.
                     */
                    get: function () {
                        var _this = this;
                        if (!_.isEmpty(this.item.children) && !this._children) {
                            this._children = this.item.children.map(function (c) {
                                return new BindMenuItem(c, _this.context);
                            });
                        }
                        return this._children;
                    },
                    enumerable: true,
                    configurable: true
                });
                return BindMenuItem;
            })();
            contextmenu.BindMenuItem = BindMenuItem;
        })(contextmenu = components.contextmenu || (components.contextmenu = {}));
    })(components = ers.components || (ers.components = {}));
})(ers || (ers = {}));// Created by zhangfa on 6/11/2015.



var ers;
(function (ers) {
    var components;
    (function (components) {
        var contextmenu;
        (function (contextmenu) {
            var KEY = ers.components.utility.KEY; // Keyboard event module
            /**
             * The helper class for handling context menu key board events.
             */
            var KeyBoardHelper = (function () {
                /**
                 *
                 * The default constructor.
                 * @param cm [[ContextMenu]) instance.
                 *
                 */
                function KeyBoardHelper(cm) {
                    this.cm = cm;
                }
                /**
                 *
                 * The event handler for context menu keyboard interaction. Use the standard UP and DOWN arrows
                 * to move the highlight and the ENTER key to choose and select the menu selection.
                 *
                 * @param e The keyboard event.
                 *
                 */
                KeyBoardHelper.prototype.onKeyDown = function (e) {
                    switch (e.keyCode) {
                        case KEY.ESCAPE:
                            e.stopPropagation();
                            e.preventDefault();
                            this.cm.hide();
                            break;
                        case KEY.LEFT_ARROW:
                        case KEY.UP_ARROW:
                            event.preventDefault();
                            event.stopPropagation();
                            this.moveFocus(-1);
                            break;
                        case KEY.RIGHT_ARROW:
                        case KEY.DOWN_ARROW:
                            event.preventDefault();
                            event.stopPropagation();
                            this.moveFocus(1);
                            break;
                    }
                };
                /**
                 *
                 * Provides menu entry focus.
                 *
                 * @param step The menu entry index.
                 * @returns {JQuery}.
                 */
                KeyBoardHelper.prototype.moveFocus = function (step) {
                    var cmElement = this.cm.element();
                    var focused = cmElement.find("a:focus");
                    var focusables = cmElement.find(":focusable").not("[tabindex='-1']");
                    if (focused.length === 0) {
                        return (step > 0 ? focusables.first() : focusables.last()).focus();
                    }
                    var index = (focusables.index(focused) + step + focusables.length) % focusables.length;
                    return focusables.eq(index).focus();
                };
                return KeyBoardHelper;
            })();
            contextmenu.KeyBoardHelper = KeyBoardHelper;
        })(contextmenu = components.contextmenu || (components.contextmenu = {}));
    })(components = ers.components || (ers.components = {}));
})(ers || (ers = {}));// Created by zhangfa on 6/8/2015.





var ers;
(function (ers) {
    var components;
    (function (components) {
        var contextmenu;
        (function (contextmenu) {
            var TriggerBindUtil = ers.components.utility.TriggerBindUtil;
            /**
             * The context menu implementation.
             */
            var ContextMenu = (function () {
                /**
                 * Default constructor.
                 * @param items The context menu items.
                 * @param template The static or asynchronous HTML template, as a promise.
                 * @param $compile The compile service.
                 * @param ps The placement service.
                 */
                function ContextMenu(items, template, $compile, ps) {
                    var _this = this;
                    /** The event triggering the context menu display. */
                    this._trigger = "contextmenu";
                    /** True if only one context menu can be displayed at a time. */
                    this._showExclusively = true;
                    /**
                     *
                     * The event handler definition defining all events that can be selected as trigger methods to
                     * display the context menu.
                     *
                     * @type {{onTrigger: (function(JQueryEventObject): undefined), toggle: (function(JQueryEventObject): undefined)}}
                     *
                     */
                    this.triggerEventHandler = {
                        onTrigger: function (e) {
                            e.stopPropagation();
                            e.preventDefault();
                            _this.show(e.pageX, e.pageY);
                        },
                        // initially, onUnTrigger was specified, it was used by TriggerbindingUtil to support focus/hover on
                        // contextmenu link. But it makes it unusable (e.g focus on contextlink -> try to click on contextmenu,
                        // it disappears before you ever clicked)
                        toggle: function (e) {
                            e.stopPropagation();
                            e.preventDefault();
                            _this.isShown() ? _this.hide() : _this.show(e.pageX, e.pageY);
                        }
                    };
                    /**
                     *
                     * The event handler dismissing the context menu that is triggered when the user interacts with the screen.
                     *
                     * @param evt Jquery event.
                     */
                    this.onBodyClick = function (evt) {
                        if (evt.isDefaultPrevented()) {
                            return;
                        }
                        _this.hide();
                    };
                    this._menuItems = items;
                    this._template = template;
                    this.$compile = $compile;
                    this.placementService = ps;
                    ContextMenu.instances.push(this);
                }
                /**
                 *
                 * Binds an an event handler to a DOM element and triggers it as defined for the menu event.
                 *
                 *
                 *
                 * @param host The event handler attached to the DOM element.
                 * @returns {ers.components.contextmenu.ContextMenu} Ensures proper chaining of methods.
                 */
                ContextMenu.prototype.bindTo = function (host) {
                    if (this._host) {
                        TriggerBindUtil.unBind(this._host, this._trigger, this.triggerEventHandler);
                    }
                    this._host = host;
                    if (this._host) {
                        TriggerBindUtil.bind(this._host, this._trigger, this.triggerEventHandler);
                    }
                    return this;
                };
                /**
                 * Sets the trigger method to display the context menu.
                 *
                 * @param trigger Trigger event name.
                 * @returns {ers.components.contextmenu.ContextMenu} Ensures the proper chaining of methods.
                 */
                ContextMenu.prototype.triggeredBy = function (trigger) {
                    if (!trigger || this._trigger === trigger) {
                        return this;
                    }
                    this._trigger = trigger;
                    this.bindTo(this._host);
                    return this;
                };
                Object.defineProperty(ContextMenu.prototype, "exclusively", {
                    /**
                     * Get the showexclusively property.
                     * @returns {boolean}
                     */
                    get: function () {
                        return this._showExclusively;
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 *
                 * Sets the showexclusively property.
                 * @param exclusively boolean value to set.
                 * @returns {ers.components.contextmenu.ContextMenu} Ensures the proper chaining of methods.
                 *
                 */
                ContextMenu.prototype.setExclusively = function (exclusively) {
                    this._showExclusively = exclusively;
                    return this;
                };
                /**
                 *
                 * Sets the future context menu container (DOM ID or DOM element).
                 *
                 * @param container ContextMenu container.
                 * @returns {ers.components.contextmenu.ContextMenu} Ensures proper method chaining.
                 *
                 */
                ContextMenu.prototype.appendTo = function (container) {
                    this._container = container;
                    return this;
                };
                /**
                 * @returns {ng.IAugmentedJQuery} The context menu directive host.
                 */
                ContextMenu.prototype.host = function () {
                    return this._host;
                };
                /**
                 *
                 * @returns {IMenuItem[]} The menu item definition.
                 *
                 */
                ContextMenu.prototype.menuItems = function () {
                    return this._menuItems;
                };
                /**
                 *
                 * Shows the context menu at the specified coordinates. If this context menu is set to display as exclusive,
                 * all other content menus are hidden. If not, only the context menus set to exclusive display are hidden.
                 *
                 * @param x The X coordinate.
                 * @param y The Y coordinate.
                 */
                ContextMenu.prototype.show = function (x, y) {
                    var _this = this;
                    if (this._element) {
                        if (this._showExclusively) {
                            this.clearExists();
                        }
                        else {
                            this.clearExists(false);
                        }
                        this._element.show();
                        this.setPosition(x, y);
                        this.toggleBodyClickHandler(true);
                        this.addEventHandlers();
                        return;
                    }
                    if (angular.isString(this._template)) {
                        this._element = this.render(this._template);
                        this._scope.$digest();
                        this.show(x, y);
                    }
                    else {
                        this._template.then(function (t) {
                            _this._template = t;
                            _this.show(x, y);
                        });
                    }
                };
                /**
                 *
                 * Hides the context menu.
                 *
                 */
                ContextMenu.prototype.hide = function () {
                    this.toggleBodyClickHandler(false);
                    this.removeEventHandlers();
                    if (this._element) {
                        this._element.hide();
                    }
                };
                /**
                 *
                 * @returns {ng.IAugmentedJQuery} The ContextMenu main DOM element.
                 *
                 */
                ContextMenu.prototype.element = function () {
                    return this._element;
                };
                /**
                 *
                 * Destroy the existing event handlers on DOM elements.
                 *
                 */
                ContextMenu.prototype.destroy = function () {
                    this.toggleBodyClickHandler(false);
                    if (this._element) {
                        this._element.scope().$destroy();
                        this._element.remove();
                        this._element = null;
                    }
                    if (this._host) {
                        TriggerBindUtil.unBind(this._host, this._trigger, this.triggerEventHandler);
                        this._host = null;
                    }
                    this._menuItems = null;
                    var index = ContextMenu.instances.indexOf(this);
                    ContextMenu.instances.splice(index, 1);
                };
                /**
                 *
                 * Override this method when the menu needs to be placed at specific coordinates.
                 *
                 * @param x x coordinate of mouse click point
                 * @param y y coordinate of mouse click point
                 *
                 *
                 */
                ContextMenu.prototype.setPosition = function (x, y) {
                    //var dropdownElement = this._element.children("ul");
                    var point = { left: x, top: y };
                    this.placementService.applyPlacement(this._element, point, "auto bottom-left", this.getContainer());
                };
                /**
                 * Override this method when the menu needs to bind to a custom context menu.
                 *
                 * @returns {T} The context to which the the menu items are bound.
                 *
                 */
                ContextMenu.prototype.getContext = function () {
                    return this.host().scope();
                };
                /**
                 *
                 * @param template
                 * @returns {ng.IAugmentedJQuery}
                 *
                 */
                ContextMenu.prototype.render = function (template) {
                    var _this = this;
                    var container = this.getContainer();
                    this._scope = this.createScope();
                    var el = this.$compile(template)(this._scope);
                    el.on("click contextmenu", function (e) {
                        _this.hide();
                    }).appendTo(container);
                    return el;
                };
                /**
                 *
                 * Finds the appropriate container according to the property container definition.
                 *
                 * If not specified, or if the container does not exist in the DOM attached to the body,
                 * 'self' returns the DOM element holding the menu directive.
                 *
                 * @returns {JQuery} a JQuery DOM element
                 *
                 */
                ContextMenu.prototype.getContainer = function () {
                    if (this._container === "self") {
                        return this._host;
                    }
                    return angular.element(this._container || "body");
                };
                /**
                 *
                 * Creates a scope for the newly created context menu.
                 * @returns {IContextMenuScope}
                 *
                 */
                ContextMenu.prototype.createScope = function () {
                    var context = this.getContext();
                    var scope = context.$new(true);
                    scope.menuItems = this._menuItems.map(function (item) {
                        return new contextmenu.BindMenuItem(item, context);
                    });
                    // add keyboard support
                    var keyHandler = new contextmenu.KeyBoardHelper(this);
                    scope.onKeyDown = angular.bind(keyHandler, keyHandler.onKeyDown);
                    // Creates ID attribute for QA automation
                    var hostID = this._host ? this._host.prop("id") : undefined;
                    var elID = hostID ? "ctx_menu_" + hostID : undefined;
                    scope.id = elID;
                    // Stores this menu in the scope, used by submenus
                    scope.menu = this;
                    return scope;
                };
                /**
                 *
                 * Sets a specific handler on the DOM body to ensure that the context menu is dismissed if the user
                 * clicks elsewhere on the screen.
                 *
                 * @param on Activate or deactivate the content menu handlers.
                 *
                 */
                ContextMenu.prototype.toggleBodyClickHandler = function (on) {
                    var events = "mousedown contextmenu";
                    on ? angular.element("body").on(events, this.onBodyClick) :
                        angular.element("body").off(events, this.onBodyClick);
                };
                /**
                 *
                 * @returns {ng.IAugmentedJQuery|boolean} True if the context menu is currently displayed on screen.
                 *
                 */
                ContextMenu.prototype.isShown = function () {
                    return this._element && this._element.is(":visible");
                };
                Object.defineProperty(ContextMenu.prototype, "parentMenu", {
                    /**
                     *
                     * Gets the parentMenu property value.
                     *
                     * @return IContextMenu as value.
                     *
                     */
                    get: function () {
                        return this._parentMenu;
                    },
                    /**
                     *
                     * Sets the parentMenu property value.
                     * @param pValue The value to set as IContextMenu.
                     *
                     */
                    set: function (pValue) {
                        this._parentMenu = pValue;
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 *
                 * Hides all context menus displayed when pIncludeNotExclusively is set to true. When
                 * pIncludeNotExclusively is set to false, only exclusive menus are hidden.
                 *
                 *
                 * @param pIncludeNotExclusive
                 */
                ContextMenu.prototype.clearExists = function (pIncludeNotExclusive) {
                    var _this = this;
                    if (pIncludeNotExclusive === void 0) { pIncludeNotExclusive = true; }
                    ContextMenu.instances.forEach(function (cm) {
                        if (cm !== _this && !_this.isParentMenu(cm) && cm.isShown()) {
                            if (pIncludeNotExclusive || (!pIncludeNotExclusive && cm.exclusively)) {
                                cm.hide();
                            }
                        }
                    });
                };
                /**
                 *
                 * Returns true if the context menu is also part of the current parentMenu.
                 *
                 *
                 * @param pMenu Menu to compare.
                 * @returns {boolean}
                 */
                ContextMenu.prototype.isParentMenu = function (pMenu) {
                    var tmpParentMenu = this.parentMenu;
                    while (tmpParentMenu != null) {
                        if (pMenu === tmpParentMenu) {
                            return true;
                        }
                        tmpParentMenu = tmpParentMenu.parentMenu;
                    }
                    return false;
                };
                /**
                 *
                 * Adds an mouse down event handler on the context menu to avoid triggering a body handler event
                 * instead of a mouse down event.
                 *
                 *
                 */
                ContextMenu.prototype.addEventHandlers = function () {
                    if (this._element) {
                        this._element.on("mousedown", this.onContextMenuMouseDown);
                    }
                };
                /**
                 *
                 * Removes the mouse down event handler on the context menu to avoid triggering a body handler event
                 * instead of a mouse down event.
                 *
                 */
                ContextMenu.prototype.removeEventHandlers = function () {
                    if (this._element) {
                        this._element.off("mousedown", this.onContextMenuMouseDown);
                    }
                };
                /**
                 *
                 * Stops the mouse down event handler on the context menu.
                 *
                 */
                ContextMenu.prototype.onContextMenuMouseDown = function (pEvt) {
                    pEvt.stopImmediatePropagation();
                };
                /** All context menu instances in the application. */
                ContextMenu.instances = [];
                return ContextMenu;
            })();
            contextmenu.ContextMenu = ContextMenu;
        })(contextmenu = components.contextmenu || (components.contextmenu = {}));
    })(components = ers.components || (ers.components = {}));
})(ers || (ers = {}));// Created by ZhangFa on 6/13/2015.



var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var ers;
(function (ers) {
    var components;
    (function (components) {
        var contextmenu;
        (function (contextmenu) {
            /**
             * See [[IAnchoredContextMenu]] and [[IContextMenu]]
             */
            var AnchoredContextMenu = (function (_super) {
                __extends(AnchoredContextMenu, _super);
                function AnchoredContextMenu() {
                    _super.apply(this, arguments);
                    /** Stores the context menu placement relative to the element to which it is attached, for example,
                     * a context menu attached to a link menu.
                     *
                     *
                     *
                     */
                    this.placement = "auto bottom-left";
                }
                /**
                 * @inheritDoc
                 */
                AnchoredContextMenu.prototype.withPlacement = function (placement) {
                    this.placement = placement || "auto bottom-left";
                    return this;
                };
                /**
                 * @Override This is used specifically with the link menu and ensures that the context menu is displayed
                 * next to the
                 * element to which it is attached, and positioned as defined in the placement configuration.
                 *
                 *
                 */
                AnchoredContextMenu.prototype.setPosition = function (x, y) {
                    this.placementService.applyPlacement(this.element(), this.host(), this.placement, this.getContainer());
                };
                /**
                 * @Override Uses the LinkMenu scope context.
                 */
                AnchoredContextMenu.prototype.getContext = function () {
                    return this.host().scope().$parent;
                };
                return AnchoredContextMenu;
            })(contextmenu.ContextMenu);
            contextmenu.AnchoredContextMenu = AnchoredContextMenu;
        })(contextmenu = components.contextmenu || (components.contextmenu = {}));
    })(components = ers.components || (ers.components = {}));
})(ers || (ers = {}));// Created by zhangfa on 6/8/2015.
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};


var ers;
(function (ers) {
    var components;
    (function (components) {
        var contextmenu;
        (function (contextmenu) {
            var DecoratorComponent = ers.components.core.DecoratorComponent;
            /**
             * @ngdoc directive
             * @name ersContextMenu
             * @restrict A
             * @module ers.components.contextmenu
             *
             *
             *
             * @description
             *
             * ### Usage
             *
             * - Use the `ers-context-menu` component as an attribute within a visible element, to create a
             * contextual menu for the component to which it is attached.
             * - The attribute's value is an Angular expression, so it can be a literal array.
             * - The underlying value is an array of menu items
             * - Each menu item has several options (see the Options section). The menu is displayed, depending on your mouse
             * configuration, for right-handed mouse on the right-click, or for the left-handed mouse on the left-click.
             *
             * ### Examples
             *
             * Right-click on any of the menu items for a context menu.
             *
             * <code-editor identifier="example1" data-title="Context Menu" html-content-url="demos/ersContextMenu/basicUsage/index.html"
             * js-content-url="demos/ersContextMenu/basicUsage/script.js" css-content-url="demos/ersContextMenu/basicUsage/styles.css"
             * content-mode="html"></code-editor>
             *
             * ### Design Guidelines
             *
             * - Create menus with three to eight listings or items. If you need more, consider breaking your items into groups
             * and using the `children` option to create a sub-menu.
             * - Where fewer items are needed, consider using a button or link for the action.
             * - Use menus to hide infrequently used actions. Make frequent actions accessible via always-visible buttons.
             * - Limit the number of menu separators to two or three. Using too many separators adds visual clutter to your
             *   application making it difficult for the user.
             *
             * ### Accessibility Guidelines
             *
             * No accessibility guidelines.
             *
             * @param {object[]} ers-context-menu
             *  Array of menu entries as defined in [IMenuItem](http://galileo/typedoc/interfaces/ers.components.contextmenu.imenuitem.html)
             *
             *
             *
             *  <!--
             *
             *  @param children
             *  The list of sub menu items. When this list is populated, a sub menu displays on a mouse click or mouse over.
             *
             *  @param enabled
             *  A flag indicating whether sub menu is clickable or not. It can be a boolean constant or a function receiving
             *  the context and returning a boolean. If it is a function, it is executed every time the context scope changes.
             *
             *  @param icon
             *  The name of the icon. It must be one of the available names names listed
             *  in [IconComponent](http://galileo/typedoc/classes/ers.components.icon.iconcomponent.html). It can be a
             *  string constant or function that receives the
             *  context and returns a string. If it is a function, it is executed every time the context scope changes.
             *
             *  @param label
             *  The label of the menu item. It can be a string constant or function that receives the context and
             *  returns a string If it's a function, it will be executed every time the context scope changes.
             *
             *  @param separatorBefore
             *  A flag indicating that the item has a divider located before it.
             *
             *  @param visible
             *  A flag indicating whether the item is visible or not. It can be a boolean constant or a function receiving
             *  the context and returning a boolean If it is a function, it is executed every time the context scope changes.
             *
             *  //-->
             *
             *
             *
             *
             *
             *
             *
             *
             *
             *
             *
             *
             *
             *
             *
             *
             *
             *
             *
             */
            function contextMenuDirective(contextMenuService) {
                return {
                    restrict: "A",
                    controller: ContextMenuComponent, bindToController: true,
                    link: function ($scope, element, attrs, controller) {
                        var menuItems = $scope.$eval(attrs["ersContextMenu"]);
                        if (!menuItems) {
                            return;
                        }
                        if (!angular.isArray(menuItems)) {
                            throw "The attribute value set in ers-context-menu is not an array:" + attrs["ersContextMenu"];
                        }
                        var cm = contextMenuService.createContextMenu(menuItems).bindTo(element);
                        if (controller) {
                            controller.contextMenu = cm;
                        }
                        $scope.$on("$destroy", function () {
                            cm.destroy();
                            cm = null;
                        });
                    }
                };
            }
            contextmenu._module.directive("ersContextMenu", ["contextMenuService", contextMenuDirective]);
            /**
             * ContextMenuComponent class
             * @class
             *
             * ### Description
             *
             * The controller linked to the ers-context-menu directive.
             *
             */
            var ContextMenuComponent = (function (_super) {
                __extends(ContextMenuComponent, _super);
                /**
                 * Constructor
                 * @param $scope controller scope
                 * @param $element root element (directive element)
                 */
                function ContextMenuComponent($scope, $element) {
                    _super.call(this, $scope, $element);
                }
                Object.defineProperty(ContextMenuComponent.prototype, "contextMenu", {
                    get: function () {
                        return this._contextMenu;
                    },
                    set: function (contextMenu) {
                        this._contextMenu = contextMenu;
                    },
                    enumerable: true,
                    configurable: true
                });
                ContextMenuComponent.$inject = ["$scope", "$element"];
                return ContextMenuComponent;
            })(DecoratorComponent);
            contextmenu.ContextMenuComponent = ContextMenuComponent;
        })(contextmenu = components.contextmenu || (components.contextmenu = {}));
    })(components = ers.components || (ers.components = {}));
})(ers || (ers = {}));// Created by zhangfa on 6/8/2015.




var ers;
(function (ers) {
    var components;
    (function (components) {
        var contextmenu;
        (function (contextmenu) {
            var DEFAULT_TEMPLATE_PATH = "contextmenu/template/contextmenu.tpl.html";
            /**
             * See [[IContextMenuService]]
             */
            var ContextMenuService = (function () {
                /**
                 * Default constructor.
                 * @param $compile
                 * @param templateHelper
                 * @param ps
                 */
                function ContextMenuService($compile, templateHelper, ps) {
                    this.$compile = $compile;
                    this.placementService = ps;
                    this._template = templateHelper.fetchTemplate(DEFAULT_TEMPLATE_PATH);
                }
                ContextMenuService.prototype.createContextMenu = function (menuItems) {
                    return new contextmenu.ContextMenu(menuItems, this._template, this.$compile, this.placementService);
                };
                ContextMenuService.prototype.createAnchoredContextMenu = function (menuItems) {
                    return new contextmenu.AnchoredContextMenu(menuItems, this._template, this.$compile, this.placementService);
                };
                /** Dependency injection. */
                ContextMenuService.$inject = ["$compile", "templateHelper", "placementService"];
                return ContextMenuService;
            })();
            contextmenu._module.service("contextMenuService", ContextMenuService);
        })(contextmenu = components.contextmenu || (components.contextmenu = {}));
    })(components = ers.components || (ers.components = {}));
})(ers || (ers = {}));// Created by ZhangFa on 6/13/2015.



var ers;
(function (ers) {
    var components;
    (function (components) {
        var contextmenu;
        (function (contextmenu) {
            /**
             * @ngdoc directive
             * @module ers.components.contextmenu
             * @name ersLinkMenu
             * @data
             * @binding
             * @attribute
             * @restrict EA
             * @scope
             *
             * @description
             *
             * ### Usage
             * Use the `ers-link-menu` component as an attribute or element name used to create a link containing an icon
             * and a label which can be clicked to display a drop-down contextual menu. The menu can also be configured to
             * display on hover or focus events on this link.
             *
             * ### Examples
             *
             * <code-editor identifier="example1" data-title="Layout" html-content-url="demos/ersLinkMenu/basicUsage/index.html"
             * js-content-url="demos/ersLinkMenu/basicUsage/script.js" css-content-url="demos/ersLinkMenu/basicUsage/styles.css"
             * content-mode="html"></code-editor>
             *
             * ### Design Guidelines
             *
             * Consider the length of the contextual menu link and whether or not an icon is appropriate.
             *
             * ### Accessibility Guidelines
             *
             * No accessibility guidelines
             *
             * <!--
             * Use `menuItems` to set the scope of the current controller or the parent controller of the host element.
             * An example of a `menuItems` might look like this:
             *
             * ```xml
             *    menuItems = [
             *    {
             *        label: (context:IItemScope):string => {
             *          return context.item.color === "red" ? "Unavailable for Red" : "Add a Note";
             *        },
             *        icon: "add",
             *        enabled: (context:IItemScope):boolean => {
             *          return context.item.color !== "red"
             *        },
             *        action: (c:IItemScope, e:JQueryEventObject) => {}
             *    },
             *    {
             *        label: (context:IItemScope):string => {
             *          return context.item.color === "red" ? "Unavailable for Red" : "Edit a Note";
             *        },
             *        icon: "edit",
             *        enabled: (context:IItemScope):boolean => {
             *          return context.item.color !== "red"
             *        },
             *        action: (c:IItemScope, e:JQueryEventObject) => {}
             *    },
             *    {
             *        label: (context:IItemScope):string => {
             *          return context.item.color === "red" ? "Unavailable for Red" : "Settings"
             *        },
             *        icon: "settings",
             *        enabled: (context:IItemScope):boolean => {
             *          return context.item.color !== "red"
             *        },
             *        action: (c:IItemScope, e:JQueryEventObject) => {}
             *    },
             *    {
             *        label:"An Item without Icon",
             *        action: (c:IItemScope, e:JQueryEventObject) => {}
             *    }
             *  ]
             *
             * ```
             * //-->
             *
             * @param {string} [menu-items] {=}
             *        Sets the *attribute* of the menu item in the contextual menu. This is the value that is passed to scope
             *        and can have a literal string array
             *       `[{label:'item 1', icon:'icon 1'}`, `{label:'item 2'`, `icon:'icon 2'}]`
             *        or a variable name `[[IMenuItem]]`.
             *
             * @param {string} [label] {@} Sets the text of the contextual menu link.
             *
             * @param {string} [icon] {@?} Sets the name *attribute* of the icon displayed in contextual menu link.
             * The icon and name must
             * be available in [IconComponent](#/components/ersIcon/documentation).
             *
             * @param {string} [trigger] {@?} Specifies the type of event triggering the context menu display. The default
             * value is 'mousedown'. You can also use 'hover' or 'focus'.
             *
             * @param {string} [container] {@?} Specifies the container element into which the contextual menu element
             * is appended. If specified with 'self', the contextual menu element appends directly inside the link element. The
             * default value is `body`.
             *
             *
             * @param {boolean} [exclusively=false] {=?} Specifies whether more than one contextual menu can
             * display at a time.
             *
             * @param {string} [placement] {@?} Sets the *attribute* position relative to the contextual menu link.
             * Available values from `PlacementService` are "top", "top-left", "top-right", "bottom", "bottom-left", "bottom-right",
             * "left", "left-top", "left-bottom", "right", "right-bottom", "right-top".
             *
             */
            function linkMenuDirective(contextMenuService, placementService) {
                return {
                    restrict: "EA",
                    scope: {
                        "icon": "@?",
                        "label": "@",
                        "placement": "@?",
                        "trigger": "@?",
                        "container": "@?",
                        "exclusively": "=?",
                        "menuItems": "="
                    },
                    templateUrl: "contextmenu/template/linkmenu.tpl.html",
                    replace: true,
                    link: function ($scope, element, attrs) {
                        var acm;
                        // apply default values if necessary
                        var exclusively = ($scope.exclusively !== undefined) ? $scope.exclusively : true;
                        var trigger = $scope.trigger || "mousedown";
                        var placement = $scope.placement || "bottom-left";
                        function getDirection() {
                            var placementObj = placementService.toPlacementObject(placement);
                            switch (placementObj.side) {
                                case "bottom":
                                    return "down";
                                case "top":
                                    return "up";
                                default:
                                    return placementObj.side;
                            }
                        }
                        $scope.direction = getDirection();
                        $scope.$watch("menuItems", function (menuItems) {
                            if (acm) {
                                acm.destroy();
                            }
                            if (!menuItems) {
                                return;
                            }
                            if (!angular.isArray(menuItems)) {
                                throw "The attribute value set in menu-items is not an array:" + attrs["menuItems"];
                            }
                            acm = contextMenuService.createAnchoredContextMenu(menuItems)
                                .withPlacement(placement)
                                .triggeredBy(trigger)
                                .bindTo(element)
                                .setExclusively(exclusively)
                                .appendTo($scope.container);
                            // Sets parent menu if exist.
                            var parentMenuScope = $scope.$parent;
                            if (parentMenuScope) {
                                acm.parentMenu = parentMenuScope.menu;
                            }
                        });
                        $scope.$on("$destroy", function () {
                            if (!acm) {
                                return;
                            }
                            acm.destroy();
                            acm = null;
                        });
                    }
                };
            }
            contextmenu._module.directive("ersLinkMenu", ["contextMenuService", "placementService", linkMenuDirective]);
        })(contextmenu = components.contextmenu || (components.contextmenu = {}));
    })(components = ers.components || (ers.components = {}));
})(ers || (ers = {}));

var ers;
(function (ers) {
    var components;
    (function (components) {
        var grid;
        (function (grid) {
            var renderer;
            (function (renderer) {
                var EditableRenderer = (function () {
                    function EditableRenderer() {
                    }
                    EditableRenderer.prototype.renderer = function (params) {
                        return document.createElement("");
                    };
                    return EditableRenderer;
                })();
                renderer.EditableRenderer = EditableRenderer;
            })(renderer = grid.renderer || (grid.renderer = {}));
        })(grid = components.grid || (components.grid = {}));
    })(components = ers.components || (ers.components = {}));
})(ers || (ers = {}));/*
 * Created by zhangfa on 3/22/2015.
 */





var ers;
(function (ers) {
    var components;
    (function (components) {
        var popover;
        (function (popover) {
            var TriggerBindUtil = ers.components.utility.TriggerBindUtil;
            var HTML_REPLACE_REG_EXP = /ng-bind=/gi;
            /**
             *
             * Implementing [[IPopInstance]]
             *
             */
            var PopInstance = (function () {
                /**
                 * Constructor.
                 *
                 * @param $host The root element.
                 * @param options Common options.
                 * @param $rootScope Root scope.
                 * @param $compile Angular compile service.
                 * @param $q Angular promise service.
                 * @param $timeout Angular timeout service.
                 * @param th Template helper.
                 * @param ps Custom Placement Service.
                 */
                function PopInstance($host, options, $rootScope, $compile, $q, $timeout, th, ps) {
                    var _this = this;
                    this.triggerByClick = false;
                    this.builded = false;
                    this.isHiding = false;
                    this.isShowing = false;
                    this.isShown = false;
                    this.hoverShown = false;
                    this.hostOriginallyActive = false;
                    /**
                     *
                     *  DOM listeners.
                     *
                     */
                    /**
                     *
                     * The animation that runs when the popup becomes visible.
                     *
                     *
                     */
                    this.onTrigger = function () {
                        _this.timeoutService.cancel(_this.timeout);
                        _this.hoverState = "in";
                        if (!_this.options.showDelay) {
                            _this.show();
                            return;
                        }
                        _this.timeout = _this.timeoutService(function () {
                            if (_this.hoverState === "in") {
                                _this.show();
                            }
                        }, _this.options.showDelay);
                    };
                    /**
                     *
                     * The animation that runs when a popup is dismissed or is no longer visible.
                     *
                     * @param evt event
                     */
                    this.onUntrigger = function (evt) {
                        _this.timeoutService.cancel(_this.timeout);
                        _this.hoverState = "out";
                        var exrtadelay = _this.options.hideDelay || 0;
                        if (evt && evt.type === "mouseleave") {
                            _this.isShowing = false;
                            exrtadelay = exrtadelay || 10;
                        }
                        _this.timeout = _this.timeoutService(function () {
                            if (_this.hoverState === "out") {
                                _this.hide();
                            }
                        }, exrtadelay);
                    };
                    /**
                     *
                     * The animation to run based on the popup's current visible state.
                     *
                     */
                    this.toggle = function () {
                        _this.isShown ? _this.onUntrigger() : _this.onTrigger();
                    };
                    /**
                     *
                     * Listen for the ESC key and hide the popup when invoked.
                     *
                     * @param evt JQuery event
                     */
                    this.onKeyUp = function (evt) {
                        if (evt.which === 27) {
                            _this.hide();
                        }
                    };
                    /**
                     *
                     *
                     * When a trigger focus is set, listen for the ESC key and hide the popup when invoked.
                     *
                     *
                     * @param evt JQuery event.
                     */
                    this.onFocusKeyUp = function (evt) {
                        if (evt.which === 27) {
                            _this.$host.blur();
                        }
                    };
                    /**
                     *
                     * Manage the popup behavior on a body click.
                     *
                     * @param evt JQuery event
                     * @returns {boolean}
                     */
                    this.onBodyClick = function (evt) {
                        if (evt.isDefaultPrevented()) {
                            return false;
                        }
                        if (evt.target === _this.$host[0]) {
                            return false;
                        }
                        if (_this.$host.has(evt.target).length > 0) {
                            return false;
                        }
                        _this.onUntrigger();
                    };
                    this.rootScopeService = $rootScope;
                    this.compileService = $compile;
                    this.qService = $q;
                    this.timeoutService = $timeout;
                    this.templateHelper = th;
                    this.placementService = ps;
                    this.$host = $host;
                    this.options = options;
                    this.init();
                }
                Object.defineProperty(PopInstance.prototype, "target", {
                    get: function () {
                        return this._target;
                    },
                    set: function (pTarget) {
                        this._target = pTarget;
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 *
                 *  Public methods
                 *
                 */
                /**
                 *
                 * Root element accessor
                 *
                 * @returns {ng.IAugmentedJQuery} The root element
                 */
                PopInstance.prototype.host = function () {
                    return this.$host;
                };
                /**
                 *
                 * Clean object (destructor)
                 *
                 */
                PopInstance.prototype.destroy = function () {
                    this.timeoutService.cancel(this.timeout);
                    angular.element("body").off("click", this.onBodyClick);
                    if (this.$host && this.options.trigger) {
                        TriggerBindUtil.unBind(this.$host, this.options.trigger, this);
                    }
                    if (this.target) {
                        this.target.off();
                        this.target.remove();
                        this.target = null;
                    }
                    if (!this.options.$scope) {
                        this.$scope.$destroy();
                    }
                };
                /**
                 *
                 * The action to run to when opening a popup.
                 *
                 * @param callback The action to run to open a popup.
                 */
                PopInstance.prototype.show = function (callback) {
                    var _this = this;
                    if (this.options.lazyLoad && !this.builded) {
                        this.build().then(function () {
                            _this.show(callback);
                        });
                        return;
                    }
                    if (this.isShown || this.isShowing || this.isHiding) {
                        return;
                    }
                    if (this.options.clearExists) {
                        this.clearExists();
                    }
                    this.isShowing = true;
                    if (this.target) {
                        this.target.removeClass(this.options.placement);
                        this.target.removeClass("with-arrow");
                    }
                    // update the target position in the next frame otherwise the width & height of the target may not be accurate
                    this.timeoutService(function () {
                        if (_this.$scope.$parent) {
                            // Applying the placement only if the parent scope is still present in order to prevent the empty popup display.
                            _this.applyPlacement();
                        }
                    }, 0);
                    this.complateShow(callback);
                    this.updateTheme();
                    this.updateArrow();
                    this.isShowing = false;
                    this.isShown = this.$scope.isShown = true;
                };
                /**
                 *
                 * The action to run when hiding a popup.
                 *
                 *
                 * @param callback The action to run when hiding a popup.
                 */
                PopInstance.prototype.hide = function (callback) {
                    if (!this.target || !this.isShown || this.isShowing || this.isHiding) {
                        return;
                    }
                    this.isHiding = true;
                    this.target.hide();
                    this.isShown = this.$scope.isShown = false;
                    this.complateHide(callback);
                    this.isHiding = false;
                };
                /**
                 *
                 * The action to perform on popup focus.
                 *
                 *
                 */
                PopInstance.prototype.focus = function () {
                    if (this.target) {
                        this.target.focus();
                    }
                };
                /**
                 * Scope accessor.
                 *
                 * @returns {IPopInstanceScope} The directive scope
                 */
                PopInstance.prototype.scope = function () {
                    return this.$scope;
                };
                /**
                 *
                 *  Private methods
                 *
                 */
                /**
                 *
                 * Initialize and build the popup.
                 *
                 */
                PopInstance.prototype.init = function () {
                    this.createScope();
                    this.triggerByClick = this.options.trigger === "click";
                    // Check at DOM element if one can access controller (via getErsComponent) and then apply TriggerBindUtil on the delegate object
                    if (this.$host && angular.isDefined(this.$host) && this.options.trigger) {
                        var host = (this.$host[0].hasOwnProperty("getErsComponent"))
                            ? this.$host[0].getErsComponent().getTooltipDelegate(this.options.trigger)
                            : this.$host;
                        TriggerBindUtil.unBind(host, this.options.trigger, this);
                        TriggerBindUtil.bind(host, this.options.trigger, this);
                    }
                    if (!this.options.lazyLoad || this.options.lazyLoad.toString() === "false") {
                        this.build();
                    }
                };
                /**
                 *
                 * Add the appropriate class to theme the popup.
                 *
                 */
                PopInstance.prototype.updateTheme = function () {
                    if (this.options.theme && this.target) {
                        var themeClass = this.options.instanceName + "-" + this.options.theme;
                        this.target.addClass(themeClass);
                    }
                };
                /**
                 *
                 * Add the appropriate class to add or remove the popup arrow.
                 *
                 */
                PopInstance.prototype.updateArrow = function () {
                    var useArrow = (this.options.showArrow.toString() === "true" || this.options.showArrow === true);
                    if (useArrow && this.target) {
                        this.target.addClass("with-arrow");
                    }
                };
                /**
                 *
                 * Create an isolated scope and add specific properties to it.
                 *
                 */
                PopInstance.prototype.createScope = function () {
                    this.$scope = (this.options.$scope || this.rootScopeService.$new());
                    var scope = (this.options.defaultTemplate
                        ? this.$scope
                        : this.$scope.$parent);
                    scope.$$ersHide$$ = angular.bind(this, this.hide);
                    scope.$$ersId$$ = this.options.id;
                };
                /**
                 *
                 * Build the popup.
                 *
                 * @returns {IPromise<TResult>|IPromise<undefined>} the object build (promise)
                 */
                PopInstance.prototype.build = function () {
                    var _this = this;
                    return this.resovleTemplate().then(function (template) {
                        _this.$container = _this.resovleContainer();
                        _this.linker = _this.createLinker(template);
                        _this.target = (_this.options.targetElement || _this.compileService(_this.linker)((_this.options.defaultTemplate)
                            ? _this.$scope
                            : _this.$scope.$parent));
                        _this.target.addClass(_this.options.typeClass);
                        if (_this.target.attr("id") === undefined) {
                            _this.target.attr("id", _this.scope().$$ersId$$);
                        }
                        _this.target.hide().appendTo(_this.$container);
                        _this.builded = true;
                        if (!_this.target.data("$scope")) {
                            _this.target.data("$scope", _this.$scope);
                        }
                    });
                };
                /**
                 *
                 *
                 * Based on the option set, load the template content.
                 *
                 *
                 * @returns {any} The popup HTML content
                 */
                PopInstance.prototype.resovleTemplate = function () {
                    //template is a DOM
                    if (angular.isElement(this.options.template)) {
                        return this.qService.when(this.options.template);
                    }
                    //template is a url
                    if (this.options.template.indexOf(".html") > -1) {
                        return this.qService.when(this.templateHelper.fetchTemplate(this.options.template));
                    }
                    //template is html
                    return this.qService.when(angular.element(this.options.template));
                };
                /**
                 *
                 * Define the container (DOM element) to which popup is attached.
                 *
                 * @returns {any} The container.
                 */
                PopInstance.prototype.resovleContainer = function () {
                    if (this.options.container === "self") {
                        return this.$host;
                    }
                    this.options.container = this.options.container || "body";
                    var container = angular.element(this.options.container);
                    return container;
                };
                /**
                 *
                 * Resolve the template path to use, either the directive template, or the options template.
                 *
                 *
                 * @param template Name of the template (path)
                 * @returns {any} The appropriate template
                 */
                PopInstance.prototype.createLinker = function (template) {
                    if (angular.isElement(template)) {
                        return template;
                    }
                    return this.options.html ? template.replace(HTML_REPLACE_REG_EXP, "ng-bind-html=") : template;
                };
                /**
                 *
                 * Hide all open popups.
                 *
                 */
                PopInstance.prototype.clearExists = function () {
                    var exists = angular.element("." + this.options.typeClass + ":visible", angular.element("body"));
                    angular.forEach(exists, function (exist) {
                        var scope = (angular.element(exist).scope());
                        if (scope && (scope.$id !== this.$scope.$id)) {
                            scope.$$ersHide$$();
                        }
                    }, this);
                };
                /**
                 *
                 * Set the popup position.
                 *
                 */
                PopInstance.prototype.applyPlacement = function () {
                    this.target.css({ display: "block", top: "", left: "" });
                    this.placementService.applyPlacement(this.target, this.$host, this.options.placement, this.options.container);
                    this.target.css({ position: "" });
                };
                /**
                 *
                 * The actions to perform when hiding a popup.
                 *
                 * @param callback If defined, action to execute on hide.
                 */
                PopInstance.prototype.complateHide = function (callback) {
                    this.hoverShown = false;
                    if (this.options.keyboard) {
                        angular.element(document).off("keyup");
                        angular.element(document).off("keyup");
                    }
                    if (this.options.blur && this.options.trigger === "focus") {
                        this.$host.blur();
                    }
                    if (!this.hostOriginallyActive) {
                        this.$host.removeClass("active");
                    }
                    if (this.options.clearExists && this.triggerByClick) {
                        angular.element("body").off("click", this.onBodyClick);
                    }
                    if (callback) {
                        callback.call(this);
                    }
                    this.target.css({ top: "", left: "" }).removeClass(this.options.placement);
                    this.isHiding = false;
                };
                /**
                 *
                 * The actions to perform when a popup is opening.
                 *
                 * @param callback If defined, the action to execute when opening a popup.
                 */
                PopInstance.prototype.complateShow = function (callback) {
                    this.hoverShown = true;
                    if (this.options.keyboard) {
                        if (this.options.trigger !== "focus") {
                            angular.element(document).on("keyup", this.onKeyUp);
                        }
                        else {
                            angular.element(document).on("keyup", this.onFocusKeyUp);
                        }
                    }
                    this.hostOriginallyActive = this.$host.hasClass("active");
                    this.$host.addClass("active");
                    if (this.options.clearExists && this.triggerByClick) {
                        angular.element("body").on("click", this.onBodyClick);
                    }
                    if (callback) {
                        callback.call(this);
                    }
                };
                return PopInstance;
            })();
            popover.PopInstance = PopInstance;
        })(popover = components.popover || (components.popover = {}));
    })(components = ers.components || (ers.components = {}));
})(ers || (ers = {}));/*
 * Created by zhangfa on 3/15/2015.
 */



var ers;
(function (ers) {
    var components;
    (function (components) {
        var popover;
        (function (popover) {
            /**
             * @Constant
             *
             * The default configurations for all popup instances.
             *
             */
            var DEFAULTS = {
                trigger: "click",
                typeClass: "pop",
                placement: "auto left",
                clearExists: true,
                lazyLoad: true
            };
            /**
             * @Factory
             *
             * @param $rootScope Angular RootScope service
             * @param $compile Angular Compile service
             * @param $q The Angular Q service
             * @param th TemplateHelper Service
             * @returns [[IPopManager]]
             */
            function PopManagerFactory($rootScope, $compile, $q, $timeout, th, ps) {
                return {
                    pop: function ($host, config) {
                        var options = angular.extend({}, DEFAULTS, config);
                        return new popover.PopInstance($host, options, $rootScope, $compile, $q, $timeout, th, ps);
                    }
                };
            }
            popover.PopManagerFactory = PopManagerFactory;
            PopManagerFactory.$inject = ["$rootScope", "$compile", "$q", "$timeout", "templateHelper", "placementService"];
            popover._module.factory("popManager", PopManagerFactory);
        })(popover = components.popover || (components.popover = {}));
    })(components = ers.components || (ers.components = {}));
})(ers || (ers = {}));/*
 * Created by zhangfa on 3/16/2015.
 */

var ers;
(function (ers) {
    var components;
    (function (components) {
        var popover;
        (function (popover_1) {
            var popoverUtils = ers.components.popover.popoverUtils;
            /**
             * @Constant
             *
             * Default popover configuration.
             */
            var DEFAULT_OPTIONS = {
                template: "popover/template/popover.tpl.html",
                trigger: "click",
                showArrow: true,
                container: "body",
                instanceName: "popover",
                typeClass: "ers-popover"
            };
            /**
             * @Constant
             *
             * Names of variables bound in popover scope instance.
             */
            var BINDING_SCOPE_KEYS = ["title", "content"];
            /**
             * @Inject
             *
             * SCE Service injected by [[PopoverServiceFactory]]
             */
            var sceService;
            /**
             * @Inject
             *
             * PopManager instance injected by [[PopoverServiceFactory]]
             */
            var popManager;
            function resolveTarget(options) {
                return options.target ? angular.element(options.target) : null;
            }
            /**
             * @Factory
             *
             * The factory that creates a popover instance.
             *
             * @param element Anchor element
             * @param attr Angular directive attributes
             * @param config Configuration that overrides attributes, and the default attributes that can over overridden.
             * @returns {IPopInstance}
             */
            function popoverFactory(element, attr, config, defaultConfig) {
                var options = popoverUtils.parseOptions(attr, "po-");
                options = angular.extend({}, DEFAULT_OPTIONS, defaultConfig, options, config);
                options.targetElement = options.targetElement || resolveTarget(options);
                options.defaultTemplate = DEFAULT_OPTIONS.template === options.template;
                var popover = popManager.pop(element, options);
                var scope = popover.scope();
                BINDING_SCOPE_KEYS.forEach(function (key) {
                    scope[key] = options[key];
                });
                popoverUtils.bindAttrToScope(attr, scope, BINDING_SCOPE_KEYS, "po-", sceService.trustAsHtml);
                return popover;
            }
            /**
             * @Factory
             *
             * Factory that creates the [[IPopoverService]] instance.
             *
             * @param $sce SCE service.
             * @param pm PopManager instance.
             * @returns [[IPopoverService]]
             */
            function PopoverServiceFactory($sce, pm) {
                sceService = $sce;
                popManager = pm;
                return {
                    createPopover: function (element, attr, config, defaultConfig) {
                        return popoverFactory(element, attr, config, defaultConfig);
                    }
                };
            }
            popover_1.PopoverServiceFactory = PopoverServiceFactory;
            PopoverServiceFactory.$inject = ["$sce", "popManager"];
            popover_1._module.factory("popoverService", PopoverServiceFactory);
        })(popover = components.popover || (components.popover = {}));
    })(components = ers.components || (ers.components = {}));
})(ers || (ers = {}));/*
 * Created by zhangfa on 3/11/2015.
 */

var ers;
(function (ers) {
    var components;
    (function (components) {
        var tooltip;
        (function (tooltip_1) {
            /**
             * @ngdoc directive
             * @module ers.components.tooltip
             * @name ersTooltip
             * @restrict A
             *
             * @description
             *
             * Use `ers-tooltip` component to create a tooltip.  The tooltip is a popover displaying additional information
             * about a link, button, or other chosen component.
             *
             * ### Usage
             *
             * - **Contextualize Feedback Messages**&#151;It is critical that a user receives contextual feedback when an action
             * or function is committed to the database. This is particularly important for web-based applications.
             * - **Reduce miscommunication**&#151;Timely and accurate feedback and validations to the user reduce user
             * miscommunication and misunderstandings.
             * - **Better understand context**&#151;Enable the user to fully understand the context of the current action
             * and make accurate and measured decisions.
             *
             * ### Examples
             *
             * #### Tooltip Position
             *
             *  Use the `tt-placement` option to position the location of the tooltip display.
             * <code-editor identifier="example1" data-title="Tooltip Position"
             * html-content-url="demos/ersTooltip/tooltipPosition/index.html"
             * js-content-url="demos/ersTooltip/tooltipPosition/script.js"
             * css-content-url="demos/ersTooltip/tooltipPosition/styles.css" content-mode="html"></code-editor>
             *
             * #### Tooltip Themes
             *
             * Use the `tt-theme` option to set the theme and placement from the available options.
             *
             * <code-editor identifier="example1" data-title="Tooltip Theme"
             * html-content-url="demos/ersTooltip/tooltipThemes/index.html"
             * js-content-url="demos/ersTooltip/tooltipThemes/script.js"
             * css-content-url="demos/ersTooltip/tooltipThemes/styles.css" content-mode="html"></code-editor>
             *
             * #### Tooltip Triggers
             *
             * Use the `tt-trigger` attribute to determine the display trigger from the `click`, `hover` (default) and
             * `focus` options.
             *
             * <code-editor identifier="example1" data-title="Tooltip Triggers"
             * html-content-url="demos/ersTooltip/tooltipTriggers/index.html"
             * js-content-url="demos/ersTooltip/tooltipTriggers/script.js"
             * css-content-url="demos/ersTooltip/tooltipTriggers/styles.css" content-mode="html"></code-editor>
             *
             * #### Tooltip Delay
             *
             * Use the `tt-show-delay` and `tt-hide-delay` options to determine how much time elapses before the tooltip displays
             * or dismisses.
             *
             * <code-editor identifier="example1" data-title="Tooltip Delay"
             * html-content-url="demos/ersTooltip/tooltipDelay/index.html"
             * js-content-url="demos/ersTooltip/tooltipDelay/script.js"
             * css-content-url="demos/ersTooltip/tooltipDelay/styles.css" content-mode="html"></code-editor>
             *
             * #### Dynamic Content
             *
             * The `tt-title` attribute allows you to add dynamic content using standard Angular methods.
             *
             * <code-editor identifier="example1" data-title="Tooltip Delay"
             * html-content-url="demos/ersTooltip/dynamicContent/index.html"
             * js-content-url="demos/ersTooltip/dynamicContent/script.js"
             * css-content-url="demos/ersTooltip/dynamicContent/styles.css" content-mode="html"></code-editor>
             *
             * #### HTML Content
             *
             * You can also easily add HTML content by setting the `tt-html` attribute to `true`.
             *
             * <code-editor identifier="example1" data-title="HTML Content"
             * html-content-url="demos/ersTooltip/htmlContent/index.html"
             * js-content-url="demos/ersTooltip/htmlContent/script.js"
             * css-content-url="demos/ersTooltip/htmlContent/styles.css" content-mode="html"></code-editor>
             *
             * ### Design Guidelines
             *
             * Use tooltips on any icon or button that has no label or text, or where an action, or the results of an
             * action, may be unclear.
             *
             * #### Tooltip Length
             *
             * Create your tooltips with short and concise descriptions of the action, potential consequences, and, if needed,
             * a link to additional information. This makes the tooltips easy for the user to quickly digest and understand.
             * Ellipses display when the message is too long for the allotted text area.
             *
             * #### Tooltip Placement
             *
             * Use the following guidelines to position your tooltips. When in doubt, place the tooltips so that they cover only
             * whitespace or as little content as possible.
             *
             * - **Header**&#151;Place the tooltips below the icon or button in the header.
             * - **Toolbars**&#151;Place icons and buttons inside of a toolbar at the top of the content area and position
             *   those tooltips above the element so that it fills the whitespace above the toolbar and does
             *   not cover the content.
             * - **Grid Items**&#151;Never place tooltips below the element they describe. The user must always see the content
             * of the row they are manipulating.
             *
             *
             * ### Accessibility Guidelines
             *
             * No accessibility guidelines
             *
             *
             * @param {string} [tt-title] Sets the title to the content that appears when the tooltip is activated.
             *
             * ```xml
             *     <button ers-tooltip
             *             tt-title="This is a tooltip">
             *          A button
             *     </button>
             * ```
             *
             * @param {string} [tt-id] Specifies the ID attribute used for the generated DOM tooltip.
             *
             * @param {string} [ers-tooltip] Specifies the content appearing on tooltip activation. When `ers-tooltip` is set,
             * `tt-title` need not be set. When both ers-tooltip and tt-title are set, only the string set in ers-tooltip is
             * displayed as the tooltip.
             *
             * ```xml
             *     <button ers-tooltip="This is a tooltip">
             *          A button
             *     </button>
             * ```
             *
             * @param {string} [tt-trigger="hover"] Specifies the tooltip trigger. The available values are: 'click', 'focus',
             * and 'hover'. The default is 'hover'.
             *
             * ```xml
             *     <input type="text" ers-tooltip
             *            tt-title="Tooltip triggered by focus"
             *            tt-trigger="focus" />
             * ```
             *
             * @param {string} [tt-show-delay] Specifies, in milliseconds, the delay before the tooltip displays.
             * The default is 500ms.
             *
             * ```xml
             *     <button class="btn btn-default"
             *             ers-tooltip
             *             tt-show-delay="1000">
             *     </button>
             * ```
             *
             * @param {string}  [tt-hide-delay] Specifies the duration of the tool tip display in milliseconds.
             * The default is 1000 milliseconds.
             *
             *
             * ```xml
             *     <button class="btn btn-default"
             *             ers-tooltip
             *             tt-hide-delay="1000">
             *             A button
             *     </button>
             * ```
             *
             *
             * @param {string}  [tt-placement] Specifies the position of the  tooltip relative to the anchor.
             * The available options are 'left', 'right', 'top', and 'bottom'. The default is 'right'.
             *
             *
             * ```xml
             *    <button ers-tooltip
             *            tt-placement="top">
             *         A button
             *    </button>
             * ```
             *
             * @param {string} [tt-theme] Specifies  the tooltip theme. The available values are: 'info' and 'success'.
             *
             * ```xml
             *     <button class="btn btn-default"
             *             ers-tooltip
             *             tt-theme="info">
             *     </button>
             * ```
             * @param {string} [po-template] Specifies the tooltip template. The template can be the url of an HTML file or an
             * HTML string.
             *
             * ##### Example - URL
             *
             * ```xml
             *     <button class="btn btn-default"
             *             ers-tooltip
             *             po-template="components/tooltip/dynamicTemplate.html">
             *             Tooltip by url
             *     </button>
             * ```
             *
             * ##### Example - String
             *
             * ```xml
             *     <button class="btn btn-default"
             *             ers-tooltip
             *             po-content="<div class='tooltip'><h3 class='tooltip-title'>title</h3><div class='tooltip-content'>
             *             content Tooltip by HTML string</div></div>">
             *     </button>
             * ```
             *
             * @param {boolean} [tt-html="false"] Enables the title of the tooltip to render an HTML string.
             *
             * ```xml
             *     <button class="btn btn-default"
             *             ers-tooltip
             *             tt-title="Hello <b>World</b>"
             *             html="true">
             *             A button
             *     </button>
             * ```
             *
             * @param {string} [tt-container="#container"] Specifies the container node to which the tooltip instance is
             * appended on opening. If
             * not specified, the tooltip instance node is appended to the HTML body. The default is body.
             *
             * @param {string} [tt-clear-exists] Specifies if more than one tooltip instance can be displayed at a time.
             *
             * ```xml
             *     <button class="btn btn-default"
             *             ers-tooltip
             *             tt-title="Hello <b>World</b>"
             *             tt-clear-exists="false">
             *             ...
             *     </button>
             * ```
             *
             * @param {boolean} [tt-show-arrow="false"] Specifies if an arrow is displayed with a tooltip instance. This is
             * only effective when no template or target is specified.
             *
             * ```xml
             *     <button class="btn btn-default"
             *             ers-tooltip
             *             tt-title="Hello <b>World</b>"
             *             tt-show-arrow="false">
             *             ...
             *     </button>
             * ```
             *
             * @param {boolean} [tt-lazy-load="true"] Specifies whether the tooltip instance is initialized immediately
             * when a page is loaded, or if initialization is delayed until the tooltip is completely loaded.
             *
             * ```xml
             *     <button class="btn btn-default"
             *             ers-tooltip
             *             tt-title="Hello <b>World</b>"
             *             tt-lazy-load="false">
             *             ...
             *     </button>
             * ```
             *
             *
             *
             *
             *
             *
             */
            function TooltipDirectiveFactory(tooltipService) {
                return {
                    restrict: "A",
                    link: function (scope, element, attr) {
                        // Extract the "id" attribute, if exists, from the element on which is plugged the tooltip and prefix this ID
                        // with the "tt-" value in order to be used as the ID of the tooltip in the case when the user did not specified one.
                        var defaultConfig = {};
                        defaultConfig.id = attr["id"] ? "tt-" + attr["id"] : undefined; // May be overridden if a tt-id is found later.
                        var tooltip = tooltipService.createTooltip(element, attr, null, defaultConfig);
                        scope.$on("$destroy", function () {
                            tooltip.destroy();
                        });
                    }
                };
            }
            tooltip_1.TooltipDirectiveFactory = TooltipDirectiveFactory;
            TooltipDirectiveFactory.$inject = ["tooltipService"];
            tooltip_1._module.directive("ersTooltip", TooltipDirectiveFactory);
        })(tooltip = components.tooltip || (components.tooltip = {}));
    })(components = ers.components || (ers.components = {}));
})(ers || (ers = {}));/*
 * Created by zhangfa on 3/19/2015.
 */


var ers;
(function (ers) {
    var components;
    (function (components) {
        var tooltip;
        (function (tooltip_1) {
                        var popoverUtils = ers.components.popover.popoverUtils;
            /**
             * @Constant
             *
             * The default configuration for all tooltip instances.
             *
             */
            var DEFAULT_OPTIONS = {
                template: "tooltip/template/tooltip.tpl.html",
                trigger: "hover",
                showDelay: 500,
                showArrow: true,
                container: "body",
                instanceName: "tooltip",
                typeClass: "ers-tooltip",
                defaultTemplate: true
            };
            var BINDING_SCOPE_KEYS = ["title"];
            var sceService;
            var popManager;
            function resolveTarget(options) {
                return options.target ? angular.element(options.target) : null;
            }
            /**
             * @Factory To create a tooltip instance.
             *
             * @param element The anchor element.
             * @param attr The element attributes.
             * @param config The configuration which overrides attributes which override [[DEFAULT_OPTIONS]].
             * @returns {IPopInstance}
             */
            function tooltipFactory(element, attr, config, defaultConfig) {
                var options = popoverUtils.parseOptions(attr, "tt-");
                options = angular.extend({}, DEFAULT_OPTIONS, defaultConfig, options, config);
                options.targetElement = resolveTarget(options);
                var tooltip = popManager.pop(element, options);
                var scope = tooltip.scope();
                BINDING_SCOPE_KEYS.forEach(function (key) {
                    scope[key] = options[key];
                });
                popoverUtils.bindAttrToScope(attr, scope, BINDING_SCOPE_KEYS, "tt-", sceService.trustAsHtml);
                popoverUtils.bindAttrToScope(attr, scope, ["tooltip"], "ers-", sceService.trustAsHtml);
                return tooltip;
            }
            /**
             * @Factory To create a tooltip service.
             *
             * @param $sce The injected SCE service.
             * @param pm The injected PopManager.
             * @returns [[ITooltipService]]
             */
            function TooltipServiceFactory($sce, pm) {
                sceService = $sce;
                popManager = pm;
                return {
                    createTooltip: function (element, attr, config, defaultConfig) {
                        return tooltipFactory(element, attr, config, defaultConfig);
                    }
                };
            }
            tooltip_1.TooltipServiceFactory = TooltipServiceFactory;
            TooltipServiceFactory.$inject = ["$sce", "popManager"];
            tooltip_1._module.factory("tooltipService", TooltipServiceFactory);
        })(tooltip = components.tooltip || (components.tooltip = {}));
    })(components = ers.components || (ers.components = {}));
})(ers || (ers = {}));/*
 * Created by zhangfa on 5/27/2015.
 */


var ers;
(function (ers) {
    var components;
    (function (components) {
        var tooltip;
        (function (tooltip) {
            var TooltipValidationErrorRenderer = (function () {
                function TooltipValidationErrorRenderer(tooltipService) {
                    this.errorTips = [];
                    this.tooltipService = tooltipService;
                }
                TooltipValidationErrorRenderer.prototype.render = function (targetElement, targetID, errorMessageProvider) {
                    var errorMessages = errorMessageProvider();
                    var idError = targetID ? "tterror-" + targetID : undefined;
                    var errorTip = this.errorTipFor(targetElement) || this.createErrorTip(targetElement, idError);
                    errorTip.scope().title = errorMessages.join("\n");
                };
                TooltipValidationErrorRenderer.prototype.clear = function (targetElement) {
                    var errorTip = this.removeErrorTip(targetElement);
                    if (errorTip) {
                        errorTip.destroy();
                    }
                };
                TooltipValidationErrorRenderer.prototype.createErrorTip = function (element, tooltipID) {
                    var errorTip = this.tooltipService.createTooltip(element, null, {
                        trigger: "hover focus keyup",
                        placement: "auto bottom",
                        theme: "error",
                        id: tooltipID
                    });
                    this.errorTips.push(errorTip);
                    return errorTip;
                };
                TooltipValidationErrorRenderer.prototype.removeErrorTip = function (element) {
                    var errorTip = null;
                    for (var i = 0; i < this.errorTips.length; i++) {
                        if (this.errorTips[i].host().is(element)) {
                            errorTip = this.errorTips[i];
                            this.errorTips.splice(i, 1);
                            break;
                        }
                    }
                    return errorTip;
                };
                TooltipValidationErrorRenderer.prototype.errorTipFor = function (targetElement) {
                    for (var i = 0; i < this.errorTips.length; i++) {
                        if (this.errorTips[i].host().is(targetElement)) {
                            return this.errorTips[i];
                        }
                    }
                    return null;
                };
                TooltipValidationErrorRenderer.serviceName = "tooltipValidationErrorRenderer";
                TooltipValidationErrorRenderer.$inject = ["tooltipService"];
                return TooltipValidationErrorRenderer;
            })();
            tooltip._module.service(TooltipValidationErrorRenderer.serviceName, TooltipValidationErrorRenderer)
                .config(["validationManagerProvider", function (vmProvider) {
                    vmProvider.setErrorRendererName(TooltipValidationErrorRenderer.serviceName);
                }]);
        })(tooltip = components.tooltip || (components.tooltip = {}));
    })(components = ers.components || (ers.components = {}));
})(ers || (ers = {}));/*
 * Created by zhangfa on 7/20/2015.
 */

var ers;
(function (ers) {
    var components;
    (function (components) {
        var tree;
        (function (tree) {
            /**
             * @Private
             *
             * The abstract class for all drag and drop source in the tree component. Sub classes must override
             * two abstract methods, 'onDragStart',and 'onDragEnd'.
             *
             */
            var DnDSource = (function () {
                function DnDSource() {
                    this.onDragStart = function (e) {
                        throw "This method should be implemented!";
                    };
                    this.onDragEnd = function (e) {
                        throw "This method should be implemented!";
                    };
                }
                DnDSource.prototype.bind = function (element) {
                    this.unbind();
                    this.element = element.on("dragstart", this.onDragStart)
                        .on("dragend", this.onDragEnd);
                    return this;
                };
                DnDSource.prototype.unbind = function () {
                    if (this.element) {
                        this.element.off("dragstart", this.onDragStart)
                            .off("dragend", this.onDragEnd);
                        this.element = null;
                    }
                    return this;
                };
                DnDSource.prototype.setData = function (data) {
                    this.data = data;
                };
                return DnDSource;
            })();
            tree.DnDSource = DnDSource;
        })(tree = components.tree || (components.tree = {}));
    })(components = ers.components || (ers.components = {}));
})(ers || (ers = {}));/*
 * Created by zhangfa on 7/20/2015.
 */

var ers;
(function (ers) {
    var components;
    (function (components) {
        var tree;
        (function (tree) {
            /**
             * @Private
             *
             * The abstract class for all drag and drop targets in the tree component. Sub classes must override
             * three abstract methods, 'onDragOver', onDragLeave, and 'onDrop'.
             *
             */
            var DnDTarget = (function () {
                function DnDTarget() {
                    this.onDragOver = function (e) {
                        throw "This method should be implemented!";
                    };
                    this.onDragLeave = function (e) {
                        throw "This method should be implemented!";
                    };
                    this.onDrop = function (e) {
                        throw "This method should be implemented!";
                    };
                }
                DnDTarget.prototype.bind = function (element) {
                    this.unbind();
                    this.element = element.on("dragover", this.onDragOver)
                        .on("dragleave", this.onDragLeave)
                        .on("drop", this.onDrop);
                    return this;
                };
                DnDTarget.prototype.unbind = function () {
                    if (this.element) {
                        this.element.off("dragover")
                            .off("dragleave")
                            .off("drop");
                        this.element = null;
                    }
                    return this;
                };
                DnDTarget.prototype.setData = function (data) {
                    this.data = data;
                };
                DnDTarget.prototype.middleOfTarget = function (target) {
                    var targetHeight = target.outerHeight();
                    var targetTop = target.offset().top;
                    return targetTop + targetHeight / 2;
                };
                return DnDTarget;
            })();
            tree.DnDTarget = DnDTarget;
        })(tree = components.tree || (components.tree = {}));
    })(components = ers.components || (ers.components = {}));
})(ers || (ers = {}));/*
 * Created by zhangfa on 7/17/2015.
 */


var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var ers;
(function (ers) {
    var components;
    (function (components) {
        var tree;
        (function (tree) {
            /**
             * @Private
             *
             * The source for the drag and drop tree item, used to enable the drag and drop [[ersTreeItem]] directive.
             *
             */
            var DnDTreeItemSource = (function (_super) {
                __extends(DnDTreeItemSource, _super);
                function DnDTreeItemSource() {
                    var _this = this;
                    _super.apply(this, arguments);
                    this.onDragStart = function (e) {
                        var de = (e.originalEvent);
                        de.stopPropagation();
                        de.dataTransfer.effectAllowed = tree.CONSTANTS.DROP_EFFECT_ALLOWED;
                        de.dataTransfer.setData(tree.CONSTANTS.DATA_FORMAT, angular.toJson(_this.data.data));
                        setTimeout(function () {
                            _this.element.addClass(tree.CONSTANTS.DRAGGING_SOURCE_CLASS);
                        });
                    };
                    this.onDragEnd = function (e) {
                        var de = (e.originalEvent);
                        de.stopPropagation();
                        _this.element.removeClass(tree.CONSTANTS.DRAGGING_SOURCE_CLASS);
                        if (de.dataTransfer.dropEffect === tree.CONSTANTS.DROP_EFFECT_ALLOWED) {
                            _this.data.parent.removeChild(_this.data.data);
                        }
                    };
                }
                return DnDTreeItemSource;
            })(tree.DnDSource);
            tree.DnDTreeItemSource = DnDTreeItemSource;
        })(tree = components.tree || (components.tree = {}));
    })(components = ers.components || (ers.components = {}));
})(ers || (ers = {}));/**
 * Created by zhangfa on 7/20/2015.
 */

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var ers;
(function (ers) {
    var components;
    (function (components) {
        var tree;
        (function (tree) {
            /**
             * @Private
             *
             * The drag and drop target for the [[ersTreeItem]] directive, used to enable a user to drag and  drop
             * a [[DnDSource]] instance over a [[ersTreeItem]] directive.
             *
             */
            var DnDTreeItemTarget = (function (_super) {
                __extends(DnDTreeItemTarget, _super);
                function DnDTreeItemTarget() {
                    var _this = this;
                    _super.apply(this, arguments);
                    this.onDragOver = function (e) {
                        if (_this.isInTheMiddle(e.originalEvent, _this.element)) {
                            _this.element.addClass(tree.CONSTANTS.DRAG_OVER_CLASS);
                        }
                        return true;
                    };
                    this.onDragLeave = function (e) {
                        _this.element.removeClass(tree.CONSTANTS.DRAG_OVER_CLASS);
                        return true;
                    };
                    this.onDrop = function (e) {
                        if (!_this.element.hasClass(tree.CONSTANTS.DRAG_OVER_CLASS)) {
                            return true;
                        }
                        e.preventDefault();
                        e.stopPropagation();
                        _this.element.removeClass(tree.CONSTANTS.DRAG_OVER_CLASS);
                        _this.updateTargetData(e.originalEvent);
                        return false;
                    };
                }
                DnDTreeItemTarget.prototype.updateTargetData = function (de) {
                    var _this = this;
                    var jsonData = de.dataTransfer.getData(tree.CONSTANTS.DATA_FORMAT);
                    var data = angular.fromJson(jsonData);
                    setTimeout(function () {
                        var scope = _this.element.scope();
                        scope.$apply(function () {
                            _this.data.addChild(data);
                        });
                    });
                };
                DnDTreeItemTarget.prototype.isInTheMiddle = function (e, target) {
                    var mouseY = e.pageY;
                    var targetMiddle = this.middleOfTarget(target);
                    var range = tree.CONSTANTS.TREE_ITEM_MIDDLE_RANGE / 2;
                    return _.inRange(mouseY, targetMiddle - range, targetMiddle + range);
                };
                return DnDTreeItemTarget;
            })(tree.DnDTarget);
            tree.DnDTreeItemTarget = DnDTreeItemTarget;
        })(tree = components.tree || (components.tree = {}));
    })(components = ers.components || (ers.components = {}));
})(ers || (ers = {}));/*
 * Created by zhangfa on 7/20/2015.
 */

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var ers;
(function (ers) {
    var components;
    (function (components) {
        var tree;
        (function (tree) {
            /**
             * @Private
             *
             * The drag and drop target for [[ersTreeItems]] directive, used to allow user to drag and drop
             * a [[DnDSource]] instance over a [[ersTreeItems]] directive.
             */
            var DnDTreeItemsTarget = (function (_super) {
                __extends(DnDTreeItemsTarget, _super);
                function DnDTreeItemsTarget() {
                    var _this = this;
                    _super.apply(this, arguments);
                    this.onDragOver = function (e) {
                        e.preventDefault();
                        e.stopPropagation();
                        _this.element.addClass(tree.CONSTANTS.DRAG_OVER_CLASS);
                        var indicator = _this.getIndicator() || $(tree.CONSTANTS.DRAG_INDICATOR_TEMPLATE);
                        if (_this.element.children().length === 0) {
                            indicator.appendTo(_this.element);
                            return false;
                        }
                        var $target = _this.getTargetTreeItem(e);
                        if (!$target.parent().is(_this.element) || $target.is(indicator)) {
                            return false;
                        }
                        if (!_this.placeIndicator(indicator, $target, e.originalEvent)) {
                            _this.removeIndicator();
                        }
                        return false;
                    };
                    this.onDragLeave = function (e) {
                        var $target = $(e.target);
                        if (!$target.parent().is(_this.element)) {
                            return;
                        }
                        _this.element.removeClass(tree.CONSTANTS.DRAG_OVER_CLASS);
                        setTimeout(function () {
                            if (!_this.element.hasClass(tree.CONSTANTS.DRAG_OVER_CLASS)) {
                                _this.removeIndicator();
                            }
                        }, 100);
                    };
                    this.onDrop = function (e) {
                        e.preventDefault();
                        e.stopPropagation();
                        _this.element.removeClass(tree.CONSTANTS.DRAG_OVER_CLASS);
                        _this.updateTargetData(e.originalEvent);
                        _this.removeIndicator();
                        return false;
                    };
                }
                DnDTreeItemsTarget.prototype.getTargetTreeItem = function (e) {
                    var $target = $(e.target);
                    while ($target.parent().length && !$target.parent().is(this.element)) {
                        $target = $target.parent();
                    }
                    return $target;
                };
                DnDTreeItemsTarget.prototype.placeIndicator = function (indicator, target, e) {
                    if (this.isOverUpperHalf(e.pageY, target)) {
                        indicator.insertBefore(target);
                        return true;
                    }
                    if (this.isOverLowerHalf(e.pageY, target)) {
                        indicator.insertAfter(target);
                        return true;
                    }
                    return false;
                };
                DnDTreeItemsTarget.prototype.updateTargetData = function (de) {
                    var _this = this;
                    var dropIndex = this.getDropIndex();
                    if (dropIndex < 0) {
                        return;
                    }
                    var jsonData = de.dataTransfer.getData(tree.CONSTANTS.DATA_FORMAT);
                    var data = angular.fromJson(jsonData);
                    setTimeout(function () {
                        var scope = _this.element.scope();
                        scope.$apply(function () {
                            _this.data.addChildAt(data, dropIndex);
                        });
                    });
                };
                DnDTreeItemsTarget.prototype.getDropIndex = function () {
                    var indicator = this.getIndicator();
                    if (!indicator) {
                        return -1;
                    }
                    return this.element.children(":visible").index(indicator);
                };
                DnDTreeItemsTarget.prototype.getIndicator = function () {
                    var indicator = this.element.find("li.drag-indicator");
                    return indicator.length > 0 ? indicator : null;
                };
                DnDTreeItemsTarget.prototype.removeIndicator = function () {
                    var indicator = this.getIndicator();
                    if (indicator) {
                        indicator.remove();
                    }
                };
                DnDTreeItemsTarget.prototype.isOverUpperHalf = function (mouseY, target) {
                    var targetMiddle = this.middleOfTarget(target);
                    return mouseY < targetMiddle - tree.CONSTANTS.TREE_ITEM_MIDDLE_RANGE / 2;
                };
                DnDTreeItemsTarget.prototype.isOverLowerHalf = function (mouseY, target) {
                    var targetMiddle = this.middleOfTarget(target);
                    return mouseY > targetMiddle + tree.CONSTANTS.TREE_ITEM_MIDDLE_RANGE / 2;
                };
                return DnDTreeItemsTarget;
            })(tree.DnDTarget);
            tree.DnDTreeItemsTarget = DnDTreeItemsTarget;
        })(tree = components.tree || (components.tree = {}));
    })(components = ers.components || (ers.components = {}));
})(ers || (ers = {}));/*
 * Created by zhangfa on 7/7/2015.
 */


var ers;
(function (ers) {
    var components;
    (function (components) {
        var tree;
        (function (tree_1) {
            var KEY = ers.components.utility.KEY;
            /**
             * @Private
             *
             * A helper class to handle all tree component key board events.
             *
             */
            var KeyBoardHelper = (function () {
                function KeyBoardHelper(tree) {
                    var _this = this;
                    this.onKeyDown = function (e) {
                        switch (e.keyCode) {
                            /* Select the focused item when ENTER OR SPACE key pressed*/
                            case KEY.ENTER:
                            case KEY.SPACE_BAR:
                                e.preventDefault();
                                e.stopPropagation();
                                _this.selectFocused();
                                break;
                            /* Collapse the focused item when LEFT ARROW key pressed*/
                            case KEY.LEFT_ARROW:
                                e.preventDefault();
                                e.stopPropagation();
                                _this.collapseFocused();
                                break;
                            /* Expand the focused item when RIGHT ARROW key pressed*/
                            case KEY.RIGHT_ARROW:
                                e.preventDefault();
                                e.stopPropagation();
                                _this.expandFocused();
                                break;
                            /* Move focus to the next item when DOWN ARROW key pressed*/
                            case KEY.UP_ARROW:
                                e.preventDefault();
                                e.stopPropagation();
                                _this.moveFocus(-1);
                                break;
                            /* Move focus to the last item when UP ARROW key pressed*/
                            case KEY.DOWN_ARROW:
                                e.preventDefault();
                                e.stopPropagation();
                                _this.moveFocus(1);
                                break;
                            /* Move focus to the next item when TAB key pressed*/
                            /* Move focus to the last item when SHIFT+TAB key pressed*/
                            case KEY.TAB:
                                e.preventDefault();
                                e.stopPropagation();
                                _this.moveFocus(e.shiftKey ? -1 : 1);
                                break;
                        }
                    };
                    this.tree = tree;
                }
                KeyBoardHelper.prototype.moveFocus = function (step) {
                    var focused = this.getFocused();
                    var focusables = this.getFocusables();
                    if (focused.length === 0) {
                        return (step > 0 ? focusables.first() : focusables.last()).focus();
                    }
                    var index = (focusables.index(focused) + step + focusables.length) % focusables.length;
                    return focusables.eq(index).focus();
                };
                KeyBoardHelper.prototype.getFocusedItem = function () {
                    var focused = this.getFocused();
                    var itemScope = focused.scope();
                    return itemScope ? itemScope["item"] : null;
                };
                KeyBoardHelper.prototype.selectFocused = function () {
                    var focusedItem = this.getFocusedItem();
                    if (focusedItem) {
                        this.tree["onItemClick"](focusedItem);
                    }
                };
                KeyBoardHelper.prototype.expandFocused = function () {
                    var focusedItem = this.getFocusedItem();
                    if (focusedItem) {
                        this.tree.expandItem(focusedItem);
                    }
                };
                KeyBoardHelper.prototype.collapseFocused = function () {
                    var focusedItem = this.getFocusedItem();
                    if (focusedItem) {
                        this.tree.collapseItem(focusedItem);
                    }
                };
                KeyBoardHelper.prototype.getFocused = function () {
                    var element = this.tree.element();
                    return element.find("a:focus");
                };
                KeyBoardHelper.prototype.getFocusables = function () {
                    var element = this.tree.element();
                    return element.find("a:focusable").not("[tabindex='-1']");
                };
                return KeyBoardHelper;
            })();
            tree_1.KeyBoardHelper = KeyBoardHelper;
        })(tree = components.tree || (components.tree = {}));
    })(components = ers.components || (ers.components = {}));
})(ers || (ers = {}));/*
 * Created by zhangfa on 7/1/2015.
 */

var ers;
(function (ers) {
    var components;
    (function (components) {
        var tree;
        (function (tree) {
            /**
             * @Private
             * Please refer to [[ITreeItem]].
             */
            var TreeItem = (function () {
                /**
                 *
                 * The default constructor.
                 * @param data The data representing this tree item.
                 * @param descriptor The field description used to find relevant data.
                 * @param parent The parent tree entry.
                 *
                 */
                function TreeItem(data, descriptor, parent) {
                    var _this = this;
                    /** True if the tree is collapsed. */
                    this.collapsed = true;
                    /** True if the tree is selected. */
                    this.selected = false;
                    /** Children for this tree entry. */
                    this._loaded = false;
                    /** Children for this tree entry. */
                    this._loading = false;
                    /**
                     *
                     * Creates a promise that handles the loading of treechildren, and, on success, changes the state
                     * of the treeitem to expanded.
                     *
                     * @returns {any}
                     * @private
                     *
                     */
                    this._expand = function () {
                        return _this._loaderDeferred.promise.then(function (loader) {
                            if (_this._loaded) {
                                return;
                            }
                            _this._loading = true;
                            return loader.loadChildren(_this._data).then(function (data) {
                                _this.data = data;
                                _this._loaded = true;
                                _this._loading = false;
                            });
                        }).then(function () {
                            _this.collapsed = false;
                        });
                    };
                    this._data = data;
                    this._descriptor = descriptor;
                    this._parent = parent;
                    this._loaderDeferred = TreeItem.$q.defer();
                }
                /**
                 *
                 * Specifies the tree item loader.
                 * @param loader [[ITreeItemLoader]]
                 *
                 */
                TreeItem.prototype.setLoader = function (loader) {
                    this._loaderDeferred.resolve(loader);
                };
                Object.defineProperty(TreeItem.prototype, "loaded", {
                    /**
                     * Returns true if the treeitem is loaded.
                     */
                    get: function () {
                        return this._loaded;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(TreeItem.prototype, "loading", {
                    /**
                     * @returns {boolean} True if the tree is currently loading.
                     */
                    get: function () {
                        return this._loading;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(TreeItem.prototype, "data", {
                    /**
                     * @returns {T} TreeItem data.
                     */
                    get: function () {
                        return this._data;
                    },
                    /**
                     *
                     * Specifies the tree item data.
                     * @param value The object.
                     *
                     *
                     *
                     */
                    set: function (value) {
                        if (this._data !== value) {
                            this._data = value;
                            this._children = null;
                        }
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(TreeItem.prototype, "label", {
                    /**
                     * @returns {any} The label displayed on the tree item.
                     */
                    get: function () {
                        return this._data[this._descriptor.labelField];
                    },
                    /**
                     *
                     * Specifies the label displayed on the tree.
                     * @param value string.
                     *
                     */
                    set: function (value) {
                        this._data[this._descriptor.labelField] = value;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(TreeItem.prototype, "icon", {
                    /**
                     * @returns {any|string} The font-awesome icon to load. If not font-awesome is not specified, or doesn't exist,
                     * file-o is chosen to the child tree items.
                     */
                    get: function () {
                        return this._data[this._descriptor.iconField] || "file-o";
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(TreeItem.prototype, "parent", {
                    /**
                     * @returns {ITreeItem<T>} The parent treeitem of this child item.
                     */
                    get: function () {
                        return this._parent;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(TreeItem.prototype, "children", {
                    /**
                     *
                     * @returns {ITreeItem<T>[]} An array of parent tree children.
                     */
                    get: function () {
                        var _this = this;
                        if (!this._children) {
                            this._children = this.childrenData.map(function (c) {
                                return new TreeItem(c, _this._descriptor, _this);
                            });
                        }
                        return this._children;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(TreeItem.prototype, "isLeaf", {
                    /**
                     * @returns {boolean} True if treeitem has no children
                     */
                    get: function () {
                        return !this.children || this.children.length === 0;
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 *
                 * Expand the parent tree if it is not expanded.
                 *
                 * @param e
                 * @returns {any}
                 */
                TreeItem.prototype.expand = function (e) {
                    if (e) {
                        e.preventDefault();
                        e.stopPropagation();
                    }
                    return this.parent ? this.parent.expand().then(this._expand) : this._expand();
                };
                /**
                 * Changes the parent tree item to collapsed.
                 * @param e
                 * @returns {any}
                 */
                TreeItem.prototype.collapse = function (e) {
                    if (e) {
                        e.preventDefault();
                        e.stopPropagation();
                    }
                    this.collapsed = true;
                };
                /**
                 *
                 * Change the parent and all child tree items to unselected.
                 *
                 */
                TreeItem.prototype.unselectAll = function () {
                    this.selected = false;
                    this.children.forEach(function (c) {
                        c.unselectAll();
                    });
                };
                /**
                 * Change the tree item to an expanded 'state', and, if this is not leaf, expand all child leafs.
                 */
                TreeItem.prototype.expandAll = function () {
                    var _this = this;
                    return this.expand().then(function () {
                        var expandChildren = _this.children.map(function (c) {
                            return c.expandAll();
                        });
                        return TreeItem.$q.all(expandChildren);
                    });
                };
                /**
                 * Change the tree item to a collapsed 'state', and, if this is not a leaf, collapse all child leafs.
                 */
                TreeItem.prototype.collapseAll = function () {
                    this.collapse();
                    this.children.forEach(function (c) {
                        c.collapseAll();
                    });
                };
                /**
                 * Finds a treeitem accoding its underlying treedata, if current item is not the corresponding item,
                 * search through the item's children.
                 * @param data TreeData used to retrieve the treeitem.
                 * @returns {any} TreeItem
                 */
                TreeItem.prototype.find = function (data) {
                    if (this._data === data) {
                        return this;
                    }
                    for (var i = 0; i < this.children.length; i++) {
                        var matched = this.children[i].find(data);
                        if (matched) {
                            return matched;
                        }
                    }
                    return null;
                };
                /**
                 * Adds treedata to the current array of children data.
                 * @param data TreeData to add.
                 */
                TreeItem.prototype.addChild = function (data) {
                    this.childrenData.push(data);
                    this._children = null;
                };
                /**
                 *
                 * Adds treedata to the current array of children data at a desired index.
                 *
                 * @param data TreeData to add.
                 * @param index The index position at which to add treedata.
                 */
                TreeItem.prototype.addChildAt = function (data, index) {
                    this.childrenData.splice(index, 0, data);
                    this._children = null;
                };
                /**
                 *
                 * Removes the treedata of the current array of children data.
                 *
                 * @param data TreeData to remove.
                 *
                 */
                TreeItem.prototype.removeChild = function (data) {
                    var index = this.childrenData.indexOf(data);
                    return index > -1 ? this.removeChildAt(index) : null;
                };
                /**
                 *
                 * Removes the treedata of the current array of child data at a desired index.
                 * @param index The position from which to remove treedata.
                 *
                 */
                TreeItem.prototype.removeChildAt = function (index) {
                    if (index > -1 && index < this.childrenData.length) {
                        var removed = this.childrenData.splice(index, 1)[0];
                        this._children = null;
                        return removed;
                    }
                    return null;
                };
                /**
                 * Remove the current item from its parent child array.
                 */
                TreeItem.prototype.delete = function () {
                    this.parent.removeChild(this.data);
                };
                Object.defineProperty(TreeItem.prototype, "childrenData", {
                    /**
                     * Gets the children data.
                     * @returns {T[]}
                     */
                    get: function () {
                        var childrenData = this._data[this._descriptor.childrenField] || [];
                        if (!_.isArray(childrenData)) {
                            throw _.template("expect field ${_descriptor.childrenField} of data ${_data} to be an array, but is " +
                                childrenData)(this);
                        }
                        return childrenData;
                    },
                    enumerable: true,
                    configurable: true
                });
                return TreeItem;
            })();
            tree.TreeItem = TreeItem;
        })(tree = components.tree || (components.tree = {}));
    })(components = ers.components || (ers.components = {}));
})(ers || (ers = {}));/*
 * Created by zhangfa on 7/1/2015.
 */




var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var ers;
(function (ers) {
    var components;
    (function (components) {
        var tree;
        (function (tree) {
            var BaseController = ers.components.core.BaseController;
            /**
             * @Private
             *
             * The [[treeItemsDirective]] controller, and default implementation of [[ITree]].
             *
             */
            var TreeController = (function (_super) {
                __extends(TreeController, _super);
                function TreeController($scope, $element) {
                    var _this = this;
                    _super.call(this, $scope, $element);
                    /* Current selected array tree items. */
                    this._selectedItems = [];
                    /* Keybaord interaction helper. */
                    this.keyBoardHelper = new tree.KeyBoardHelper(this);
                    /**
                     *
                     * Uses the Keyboardhelper to manage keyboard events.
                     *
                     * @param e
                     *
                     */
                    this.onKeyDown = function (e) {
                        _this.keyBoardHelper.onKeyDown(e);
                    };
                    if (this.isRoot && this.treeId) {
                        $scope.$parent.$parent[this.treeId] = this;
                        $element.keydown(this.onKeyDown);
                    }
                    $scope.$on("$destroy", function () { _this.destroy(); });
                }
                /**
                 *
                 * @inheritDoc
                 *
                 */
                TreeController.prototype.destroy = function () {
                    void 0;
                    this.$element.off().remove();
                    this.parent = null;
                    this._selectedItem = null;
                    this._selectedItems = null;
                    this.parentItem = null;
                    this.$element.off().remove();
                };
                /**
                 * @returns {ng.IAugmentedJQuery} Tree root DOM element.
                 */
                TreeController.prototype.element = function () {
                    return this.$element;
                };
                /**
                 *
                 * Use the parameter item as the newly selected item. If selectedItems is not empty, all items are unselected.
                 *
                 *
                 * @param item The treeItem to select or the treedata relevant to the treeitem.
                 *
                 */
                TreeController.prototype.selectItem = function (item) {
                    if (!this.multipleSelection) {
                        this.unselectAll();
                    }
                    if (!item) {
                        return;
                    }
                    this._selectedItem = item instanceof tree.TreeItem ? item : this.find(item);
                    if (this._selectedItem) {
                        this._selectedItem.selected = true;
                        this._selectedItems.push(this._selectedItem);
                    }
                };
                /**
                 *
                 * Unselect a treeitem.
                 *
                 * @param item
                 */
                TreeController.prototype.unselectItem = function (item) {
                    var treeItem = item instanceof tree.TreeItem ? item : this.find(item);
                    var index = this._selectedItems.indexOf(treeItem);
                    if (index > -1) {
                        this._selectedItems.splice(index, 1);
                    }
                    if (this._selectedItem === treeItem) {
                        this._selectedItem = null;
                    }
                    treeItem.selected = false;
                };
                /**
                 *
                 * When multiselection is set to true, select the tree item and set the tree item state to selected. When
                 * multiselection is set to false, invert the current select item state and set the new item state to
                 * selected.
                 *
                 * @param item
                 * @returns {any}
                 */
                TreeController.prototype.onItemClick = function (item) {
                    if (this.parent) {
                        return this.parent.onItemClick(item);
                    }
                    return this.multipleSelection && item.selected ? this.unselectItem(item) : this.selectItem(item);
                };
                Object.defineProperty(TreeController.prototype, "selectedItem", {
                    /**
                     * @returns {T|Object} The selected item data.
                     */
                    get: function () {
                        return this._selectedItem ? this._selectedItem.data : null;
                    },
                    /**
                     * Specify the selected item state.
                     * @param value
                     */
                    set: function (value) {
                        this.selectItem(value);
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(TreeController.prototype, "selectedItems", {
                    /**
                     * @returns {T[]} The array of selected tree items.
                     */
                    get: function () {
                        return this._selectedItems.map(function (treeItem) {
                            return treeItem.data;
                        });
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * Expand a tree item.
                 * @param item
                 */
                TreeController.prototype.expandItem = function (item) {
                    var treeItem = item instanceof tree.TreeItem ? item : this.find(item);
                    if (treeItem) {
                        treeItem.expand();
                    }
                };
                /**
                 * Collapse an tree item.
                 * @param item
                 */
                TreeController.prototype.collapseItem = function (item) {
                    var treeItem = item instanceof tree.TreeItem ? item : this.find(item);
                    if (treeItem) {
                        treeItem.collapse();
                    }
                };
                /**
                 * Expand all items.
                 */
                TreeController.prototype.expandAll = function () {
                    this.forEachItem("expandAll");
                };
                /**
                 * Collapse all items.
                 */
                TreeController.prototype.collapseAll = function () {
                    this.forEachItem("collapseAll");
                };
                /**
                 * Unselect all items.
                 */
                TreeController.prototype.unselectAll = function () {
                    this._selectedItems = [];
                    this.forEachItem("unselectAll");
                };
                /**
                 *
                 * Gets the names of each tree element and executes a method name on each.
                 *
                 *
                 * @param methodName Method to execute.
                 */
                TreeController.prototype.forEachItem = function (methodName) {
                    if (!this.parentItem) {
                        return;
                    }
                    var treeItems = this.parentItem.children || [];
                    treeItems.forEach(function (item) {
                        item[methodName]();
                    });
                };
                Object.defineProperty(TreeController.prototype, "level", {
                    /**
                     *
                     * The current tree level for this controller.
                     *
                     * @returns {number}
                     */
                    get: function () {
                        return this.parent ? this.parent.level + 1 : 0;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(TreeController.prototype, "isRoot", {
                    /**
                     *
                     * True if the tree controller is on the root.
                     *
                     * @returns {boolean}
                     */
                    get: function () {
                        return this.level === 0;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(TreeController.prototype, "treeDraggable", {
                    /**
                     *
                     * Gets the value for drag property.
                     *
                     * @return boolean as value.
                     */
                    get: function () {
                        return this._treeDraggable;
                    },
                    /**
                     *
                     * Sets the value on drag property.
                     *
                     * @param pValue value to set as boolean.
                     *
                     */
                    set: function (pValue) {
                        this._treeDraggable = pValue;
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * Finds a treeitem according to its associated data.
                 * @param data
                 * @returns {any}
                 */
                TreeController.prototype.find = function (data) {
                    if (!this.parentItem) {
                        return null;
                    }
                    var treeItems = this.parentItem.children || [];
                    for (var i = 0; i < treeItems.length; i++) {
                        var matched = treeItems[i].find(data);
                        if (matched) {
                            return matched;
                        }
                    }
                    return null;
                };
                /* Injection declaration */
                TreeController.$inject = ["$scope", "$element"];
                return TreeController;
            })(BaseController);
            tree.TreeController = TreeController;
            tree._module.controller("treeController", TreeController);
        })(tree = components.tree || (components.tree = {}));
    })(components = ers.components || (ers.components = {}));
})(ers || (ers = {}));/*
 * Created by zhangfa on 7/1/2015.
 */



var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var ers;
(function (ers) {
    var components;
    (function (components) {
        var tree;
        (function (tree) {
            var BaseComponent = ers.components.core.BaseComponent;
            /**
             * @Constant Default constants in tree component
             */
            var DEFAULTS = {
                /* Default expand icon of tree component */
                EXPAND_ICON: "plus-square-o",
                /* Default collpase icon of tree component */
                COLLAPSE_ICON: "minus-square",
                /* Default label field of tree data */
                LABEL_FIELD: "label",
                /* Default icon field of tree data */
                ICON_FIELD: "icon",
                /* Default children field of tree data */
                CHILDREN_FIELD: "children",
                /* Default value for drag option */
                DRAGGABLE: false
            };
            /**
             * @ngdoc directive
             * @module ers.components.tree
             * @name ersTree
             *
             * @restrict E
             * @transclude
             * @scope
             *
             * @description
             *
             * The `ers-tree` component to display hierarchical data.
             *
             * ### Usage:
             *
             * The tree component supports:
             *
             * - Displaying an infinite hierarchy of data.
             * - Dynamic data binding. When the data set changes, the tree view changes accordingly.
             * - Data-bound labels and icons displaying the unique properties of their particular data node label and field icon.
             * - Lazy loading of each tree item by specifying a custom item loader. The custom loader loads the child items
             * asynchronously when a parent item is being expanded.
             * - Drag and drop to change the hierarchy of the selected tree nodes.
             * - Customized representation for each data node of the tree. Create an instance
             * of [ITreeItemRenderer](http://galileo/typedoc/interfaces/ers.components.tree.itreeitemrenderer.html)
             * and register it as a service in an Angular ID container. After registering the service, set the service
             * name as the value of the item-renderer attribute of the `ers-tree` element.
             *
             * `ers-tree` also supports the following keyboard shortcuts:
             *
             * - Up arrow or tab&#151;Moves the focus from the current tree item selection and selects the next tree item.
             * - Down arrow or shift+tab&#151;Moves the focus from the current tree item selection to last tree item selection.
             * - Left arrow&#151;Collapses the current selection.
             * - Right arrow&#151;Expands the current selection.
             * - Enter or space bar&#151;Selects the item currently in focus.
             *
             * ### Examples
             *
             * #### Basic Usage
             *
             * <code-editor identifier="example3" data-title="Basic Usage" html-content-url="demos/ersTree/basicUsage/index.html"
             * js-content-url="demos/ersTree/basicUsage/script.js" css-content-url="demos/ersTree/basicUsage/styles.css"
             * content-mode="html"></code-editor>
             *
             * #### Expand Collapse Usage
             *
             * <code-editor identifier="example3" data-title="Expand Collapse Usage"
             * html-content-url="demos/ersTree/expandCollapseUsage/index.html"
             * js-content-url="demos/ersTree/expandCollapseUsage/script.js"
             * css-content-url="demos/ersTree/expandCollapseUsage/styles.css" content-mode="html"></code-editor>
             *
             * #### Selection Usage
             *
             * <code-editor identifier="example3" data-title="Selection Usage"
             * html-content-url="demos/ersTree/selectionUsage/index.html"
             * js-content-url="demos/ersTree/selectionUsage/script.js"
             * css-content-url="demos/ersTree/selectionUsage/styles.css" content-mode="html"></code-editor>
             *
             * ### Design Guidelines
             *
             * No design guidelines.
             *
             * ### Accessibility Guidelines
             *
             * No accessibility guidelines.
             *
             * @param {string} [label-field='label']
             * Specifies the name of data node property displayed as the label of the tree item.
             *
             * @param {string} [icon-field=null]
             * Specifies the name of data node property used as a tree item icon class name. The class name must be
             * supported by fontawesome.
             *
             * @param {string} [children-field='children']
             * Specifies the name of data node property which is treated as the child node.
             *
             * @param {string} [collapse-icon='minus-square-o'] {@?}
             * Specifies the fontawsome class name of the collapse icon of the non-leaf tree item.
             *
             * @param {string} [expand-icon='plus-square-o'] {@?}
             * Specifies the fontawsome class name for the expanded icon of the non-leaf tree item.
             *
             * @param {expression} [tree-data] {=}
             * Sets the hierarchical data of the tree. It must be an array.
             *
             * @param {string} [tree-id] {@?}
             * Sets the ID of the tree component in its parent scope. For more information, see
             * [ITree](http://galileo/typedoc/interfaces/ers.components.tree.itree.html).
             *
             * ##### Example
             *
             * ```xml
             * <ers-tree tree-id="myTree"
             *           tree-data="ctrl.treeData">
             * </ers-tree>
             *
             * <button class="btn btn-primary"
             *         ng-click="myTree.collapseAll()">
             *   Collapse All
             * </button>
             * ```
             * @Optional
             * @param  {string} [item-renderer]
             * Sets a custom tree item renderer. The value must be the name of an existing angular service that implements the
             * [ITreeItemRenderer](http://galileo/typedoc/interfaces/ers.components.tree.itreeitemrenderer.html) interface.
             *
             * @param {expression} [tree-draggable=false] {=?}
             * The tree supports drag and drop when true. The default value is false.
             *
             * ##### Example
             *
             * ```xml
             * <ers-tree tree-id="myTree3"
             *           tree-data="ctrl.treeData"
             *           item-renderer="CheckboxTreeItemRenderer">
             * </ers-tree>
             * ```
             * And CheckboxTreeItemRenderer is registered as a service in an Angular ID container.
             *
             *
             * ```
             *  class CheckboxTreeItemRenderer implements
             *  [ITreeItemRenderer](http://galileo/typedoc/interfaces/ers.components.tree.itreeitemrenderer.html) {
             *    ...
             *    public render(item:ITreeItem):JQuery {
             *      ...
             *    }
             *    ...
             *  }
             *  angular.module("...").service("CheckboxTreeItemRenderer", CheckboxTreeItemRenderer);
             *
             * ```
             * @Optional
             * @param  {string} [item-loader]
             * Sets a custom tree item loader to implement lazyloading.
             * Make it the name of an existing angular service that implements
             * [ITreeItemRenderer](http://galileo/typedoc/interfaces/ers.components.tree.itreeitemrenderer.html) interface.
             *
             * ##### Example
             *
             * ```xml
             *  <ers-tree tree-id="myTree"
             *            tree-data="treeData"
             *            item-loader="SampleItemLoader">
             *  </ers-tree>
             * ```
             * And SampleItemLoader is registered as a service in an Angular ID container.
             *
             *
             * ```
             *  class SampleItemLoader implements ITreeItemLoader<ITreeNode> {
             *
             *    static $inject = ["backendService"];
             *
             *    constructor(private backendService:IBackendService) {}
             *
             *    public loadChildren(node:ITreeNode):ng.IPromise<ITreeNode> {
             *      return this.backendService.load(node.id);
             *    }
             *  }
             *
             *  angular.module("...").service("SampleItemLoader", SampleItemLoader);
             *
             * ```
             *
             * @param {expression} [multiple-selection='false'] {=?}
             * When set to true the tree component allows multiple tree node selections. The default is false.
             *
             *
             * ##### Example
             *
             * ```xml
             *  <ers-tree tree-id="myTree"
             *            tree-data="ctrl.treeData"
             *            multiple-selection="true"
             *  </ers-tree>
             * ```
             *
             * @param {expression} [selected-item] {=?}
             * Selected tree item.
             *
             */
            function treeDirective($injector, $q, $log) {
                tree.TreeItem.$q = tree.TreeItem.$q || $q;
                var dummyLoader = {
                    loadChildren: function (data) {
                        return $q.when(data);
                    }
                };
                return {
                    restrict: "E",
                    replace: true,
                    transclude: true,
                    templateUrl: "tree/template/tree.tpl.html",
                    controller: TreeComponent,
                    // bindToController: true,
                    scope: {
                        "treeData": "=",
                        "collapseIcon": "@?",
                        "expandIcon": "@?",
                        "treeId": "@?",
                        "multipleSelection": "=?",
                        "selectedItem": "=?",
                        "treeDraggable": "=?"
                    },
                    link: function ($scope, element, attr) {
                        $scope.$watch("treeData", function (rawData) {
                            if (!angular.isArray(rawData)) {
                                $log.error("Expect tree-data value of ers-tree directive be an array but is", rawData);
                                return;
                            }
                            var fieldDescriptor = {
                                labelField: attr.labelField || DEFAULTS.LABEL_FIELD,
                                iconField: attr.iconField || DEFAULTS.ICON_FIELD,
                                childrenField: attr.childrenField || DEFAULTS.CHILDREN_FIELD
                            };
                            var rootData = {};
                            rootData[fieldDescriptor.childrenField] = rawData;
                            var root = new tree.TreeItem(rootData, fieldDescriptor, null);
                            root.setLoader(dummyLoader);
                            $scope.root = root;
                        });
                        if (attr.itemRenderer) {
                            $scope.itemRenderer = $injector.get(attr.itemRenderer);
                        }
                        if (attr.itemLoader) {
                            $scope.itemLoader = $injector.get(attr.itemLoader);
                        }
                        $scope.collapseIcon = $scope.collapseIcon || DEFAULTS.EXPAND_ICON;
                        $scope.expandIcon = $scope.expandIcon || DEFAULTS.COLLAPSE_ICON;
                        $scope.treeDraggable = $scope.treeDraggable || DEFAULTS.DRAGGABLE;
                    }
                };
            }
            tree._module.directive("ersTree", ["$injector", "$q", "$log", treeDirective]);
            /**
             * TreeComponent class
             * @class
             *
             * ### Description
             *
             * The controller linked to the ers-tree directive.
             *
             */
            var TreeComponent = (function (_super) {
                __extends(TreeComponent, _super);
                /**
                 * Constructor
                 * @param $scope The controller scope.
                 * @param $element The root element directive element.
                 */
                function TreeComponent($scope, $element) {
                    _super.call(this, $scope, $element);
                }
                TreeComponent.$inject = ["$scope", "$element"];
                return TreeComponent;
            })(BaseComponent);
            tree.TreeComponent = TreeComponent;
        })(tree = components.tree || (components.tree = {}));
    })(components = ers.components || (ers.components = {}));
})(ers || (ers = {}));/*
 * Created by zhangfa on 7/14/2015.
 */




var ers;
(function (ers) {
    var components;
    (function (components) {
        var tree;
        (function (tree) {
            var SUB_TREE_TEMPLATE = "<ers-tree-items " +
                "parent-item='item' " +
                "parent='parent' " +
                "expand-icon='${expandIcon}' " +
                "collapse-icon='${collapseIcon}' " +
                "item-renderer='itemRenderer' " +
                "item-loader='itemLoader' " +
                "ng-if='item.children.length > 0' " +
                "tree-draggable='treeController.treeDraggable'" +
                "ng-hide='item.collapsed'>" +
                "</ers-tree-items>";
            /**
             * @Private
             * Enable drag and drop on the [[ersTreeItem]] directive.
             * @param $scope The scope of the [[ersTreeItem]] directive.
             * @param element The element of the [[ersTreeItem]] directive.
             */
            function enableDnD($scope, element) {
                var dndSource = new tree.DnDTreeItemSource().bind(element);
                var dndTarget = new tree.DnDTreeItemTarget().bind(element);
                $scope.$watch("item", function (item) {
                    dndSource.setData(item);
                    dndTarget.setData(item);
                });
                $scope.$on("$destroy", function () {
                    dndSource.unbind();
                    dndTarget.unbind();
                });
            }
            /**
             * @Private
             *
             * An internal decorator of item loader for lazy loading children items of a tree item.
             */
            var ItemLoaderWrapper = (function () {
                function ItemLoaderWrapper($compile, $q, itemScope, itemElem) {
                    this.$compile = $compile;
                    this.$q = $q;
                    this.itemScope = itemScope;
                    this.itemElem = itemElem;
                }
                /**
                 * @inheritDoc
                 */
                ItemLoaderWrapper.prototype.loadChildren = function (data) {
                    var _this = this;
                    var item = this.itemScope.item;
                    var itemLoader = this.itemScope.itemLoader;
                    //If no custom item loader specified, then append the sub ers-tree-items directive directly.
                    if (!itemLoader) {
                        this.appendSubTree();
                        return this.$q.when(item.data);
                    }
                    //Custom item loader specified, then append the sub ers-tree-items directive after chidren data loaded.
                    return itemLoader.loadChildren(item.data).then(function (data) {
                        item.data = data;
                        _this.appendSubTree();
                        return data;
                    });
                };
                /**
                 * Adds a subtree by compiling a an internal template.
                 */
                ItemLoaderWrapper.prototype.appendSubTree = function () {
                    var template = _.template(SUB_TREE_TEMPLATE)(this.itemScope);
                    this.$compile(template)(this.itemScope).appendTo(this.itemElem);
                };
                return ItemLoaderWrapper;
            })();
            /**
             * ngdoc directive
             * @module ers.components.tree
             * @name ersTreeItem
             * @restrict E
             * @scope
             *
             * @Private
             * Internal directive that is always a child directive of [[ersTreeItems]], used for rendering a tree item.
             *
             * @param {string} [collapse-icon='minus-square-o'] {=}
             * Refers to 'collapse-icon' attribute of [[treeDirective]].
             *
             * @param {string} [expand-icon='plus-square-o'] {=}
             * Refers to 'expand-icon' attribute of [[treeDirective]].
             *
             * @param {object} [item] {=?}
             * Current underlying [[ITreeItem]].
             *
             * @param {number} [level] {=?}
             * Current level of this treeitem in the tree structure, 0 is root.
             *
             * @param  {string} [item-renderer] {=?}
             * Refers to 'item-renderer' attribute of [[treeDirective]].
             *
             * @param  {string} [item-loader] {=?}
             * Refers to 'item-loader' attribute of [[treeDirective]].
             *
             */
            function treeItemDirective($compile, $q) {
                return {
                    restrict: "E",
                    replace: true,
                    require: "^^ersTreeItems",
                    templateUrl: "tree/template/treeitem.tpl.html",
                    scope: {
                        "item": "=",
                        "itemRenderer": "=?",
                        "itemLoader": "=?",
                        "expandIcon": "=",
                        "collapseIcon": "=",
                        "level": "="
                    },
                    link: function ($scope, element, attr, treeController) {
                        var item = $scope.item;
                        $scope.parent = treeController;
                        $scope.onItemClick = function () {
                            treeController.onItemClick(item);
                        };
                        item.setLoader(new ItemLoaderWrapper($compile, $q, $scope, element));
                        $scope.treeController = treeController;
                        if (treeController.treeDraggable) {
                            enableDnD($scope, element);
                        }
                    }
                };
            }
            tree._module.directive("ersTreeItem", ["$compile", "$q", treeItemDirective]);
        })(tree = components.tree || (components.tree = {}));
    })(components = ers.components || (ers.components = {}));
})(ers || (ers = {}));/*
 * Created by zhangfa on 7/6/2015.
 */

var ers;
(function (ers) {
    var components;
    (function (components) {
        var tree;
        (function (tree) {
            /**
             * @private
             * Wrapper to use transcluded content for tree item rendering.
             */
            var TranscludedItemRenderer = (function () {
                /**
                 * Default constructor
                 * @param parentScope The parent scope.
                 * @param transcludeFn The transclusion function.
                 */
                function TranscludedItemRenderer(parentScope, transcludeFn) {
                    this.parentScope = parentScope;
                    this.transcludeFn = transcludeFn;
                }
                /**
                 *
                 * @inheritDoc
                 *
                 */
                TranscludedItemRenderer.prototype.render = function (item) {
                    var itemScope = this.parentScope.$new();
                    itemScope["item"] = item;
                    return this.transcludeFn(itemScope, function (clone) {
                        // do nothing
                    });
                };
                return TranscludedItemRenderer;
            })();
            /**
             * ngdoc directive
             * @module ers.components.tree
             * @name ersTreeItemRenderer
             * @restrict EA
             * @transclude
             *
             * Directive used to declaratively specify a item renderer inside of an `ers-tree` directive where
             * ers-tree-item-renderer directly accesses the [[ITreeItem]] by name.
             *
             * #### Example
             *
             * ```xml
             *  <ers-tree tree-id="myTree" tree-data="treeData">
             *    <ers-tree-item-renderer>
             *      <span style="display: inline-block; width: 100%" ers-context-menu="menuItems">
             *        <span ng-show="editMode">
             *          <input ng-model="item.label" ng-blur="editMode = false"/>
             *        </span>
             *        <span ng-hide="editMode">
             *          <ers-label value="{{item.label}}"></ers-label>
             *        </span>
             *      </span>
             *    </ers-tree-item-renderer>
             *  </ers-tree>
             * ```
             *
             */
            function treeItemRendererDirective() {
                return {
                    restrict: "EA",
                    transclude: true,
                    link: function ($scope, element, attr, c, transcludeFn) {
                        $scope.$parent.itemRenderer = new TranscludedItemRenderer($scope, transcludeFn);
                    }
                };
            }
            tree._module.directive("ersTreeItemRenderer", treeItemRendererDirective);
        })(tree = components.tree || (components.tree = {}));
    })(components = ers.components || (ers.components = {}));
})(ers || (ers = {}));/*
 * Created by zhangfa on 7/6/2015.
 */

var ers;
(function (ers) {
    var components;
    (function (components) {
        var tree;
        (function (tree) {
            /**
             * ngdoc directive
             * @module ers.components.tree
             * @name treeItemRendererHolderDirective
             * @restrict A
             * @scope
             *
             * @Private
             * An internal component for rendering custom tree items.
             *
             */
            function treeItemRendererHolderDirective() {
                return {
                    restrict: "A",
                    scope: {
                        "itemRenderer": "=",
                        "item": "="
                    },
                    link: function ($scope, element, attr) {
                        var renderer = $scope.itemRenderer;
                        if (!renderer) {
                            return;
                        }
                        var treeItem = $scope.item;
                        var itemElement = renderer.render(treeItem);
                        element.empty().append(itemElement);
                    }
                };
            }
            tree._module.directive("ersTreeItemRendererHolder", treeItemRendererHolderDirective);
        })(tree = components.tree || (components.tree = {}));
    })(components = ers.components || (ers.components = {}));
})(ers || (ers = {}));/*
 * Created by zhangfa on 7/1/2015.
 */


var ers;
(function (ers) {
    var components;
    (function (components) {
        var tree;
        (function (tree) {
            /**
             * Enables drag and drop on [[ersTreeItems]] directive.
             * @param $scope The scope of [[ersTreeItems]] directive.
             * @param element The element of [[ersTreeItems]] directive.
             */
            function enableDnD($scope, element) {
                var dndTarget = new tree.DnDTreeItemsTarget().bind(element);
                $scope.$watch("ctrl.parentItem", function (parentItem) {
                    dndTarget.setData(parentItem);
                });
                $scope.$on("$destroy", function () {
                    dndTarget.unbind();
                });
            }
            /**
             * ngdoc directive
             * module ers.components.tree
             * @name ersTreeItems
             * @restrict A
             *
             * @Private
             * This component is for internal support only. It is used to recursively render the tree and tree items.
             *
             *
             * @param {string} [collapse-icon='minus-square-o'] {@?}
             * Specifies the fontawsome class name of the collapse icon for the non-leaf tree item.
             *
             *
             * @param {string} [expand-icon='plus-square-o'] {@?}
             * Specifies the fontawsome class name of the expand icon of the non-leaf tree item.
             *
             * @param {object} [parentItem] {=}
             * Specifies the parent controller of [[ersTreeItems]].
             *
             * @param {string} [tree-id] {@?}
             *
             * Specifies the ID of the tree component in its parent scope.
             *
             * @param  {string} [item-renderer] {=?}
             *
             * Sets a custom tree item renderer. The value must be the name of an existing angular service that implements
             * [ITreeItemRenderer](http://galileo/typedoc/interfaces/ers.components.tree.itreeitemrenderer.html) interface.
             *
             *
             * @param  {string} [item-loader] {=?}
             * Specifies the 'item-loader' attribute of the [[treeDirective]].
             *
             * @param  {boolean} [multiple-selection="false"] {=?}
             *
             *
             * Only restricted to the root tree item. Usage refers to 'multiple-selection' attribute of [[treeDirective]].
             *
             * @param  {boolean} [treeDraggable="false"] {=?}
             * Only restricted to the root tree item. Usage refers to 'multiple-selection' attribute of [[treeDirective]].
             *
             */
            function treeItemsDirective($compile) {
                return {
                    restrict: "E",
                    replace: true,
                    templateUrl: "tree/template/treeitems.tpl.html",
                    scope: {
                        "treeId": "@?",
                        "expandIcon": "@?",
                        "collapseIcon": "@?",
                        "parent": "=?",
                        "parentItem": "=",
                        "itemRenderer": "=?",
                        "itemLoader": "=?",
                        "multipleSelection": "=?",
                        "selectedItem": "=?",
                        "treeDraggable": "=?"
                    },
                    controller: "treeController",
                    bindToController: true,
                    controllerAs: "ctrl",
                    link: function ($scope, element, attr) {
                        var draggable = element.controller("ersTreeItems").treeDraggable;
                        if (draggable) {
                            enableDnD($scope, element);
                        }
                    }
                };
            }
            tree._module.directive("ersTreeItems", ["$compile", treeItemsDirective]);
        })(tree = components.tree || (components.tree = {}));
    })(components = ers.components || (ers.components = {}));
})(ers || (ers = {}));

var ers;
(function (ers) {
    var components;
    (function (components) {
        var core;
        (function (core) {
            var service;
            (function (service) {
                                /**
                 * Basic implementation of IContainerEventService.
                 */
                var ContainerEventService = (function () {
                    function ContainerEventService() {
                    }
                    /**
                     * Register a listener to be notified when an event was sent from a parent container
                     * @param eventType type of the event
                     * @param $scope scope of the component
                     * @param listener listener
                     */
                    ContainerEventService.prototype.on = function (eventType, $scope, listener) {
                        var s = $scope.$parent;
                        while (s != null) {
                            if (s.hasOwnProperty(ContainerEventService.SCOPE_KEY)) {
                                var listenersStore = s[ContainerEventService.SCOPE_KEY];
                                if (listenersStore) {
                                    var listeners = listenersStore[eventType];
                                    if (listeners) {
                                        listeners.push(listener);
                                        break;
                                    }
                                }
                            }
                            s = s.$parent;
                        }
                    };
                    /**
                     * Register an event dispatcher.
                     * @param eventTypes types of the event
                     * @param $scope scope of the container.
                     */
                    ContainerEventService.prototype.registerDispatcher = function (eventTypes, $scope) {
                        var listenersStore = $scope[ContainerEventService.SCOPE_KEY];
                        if (!listenersStore) {
                            // initialize the listeners store
                            listenersStore = {};
                            $scope[ContainerEventService.SCOPE_KEY] = listenersStore;
                        }
                        var events = null;
                        if (typeof eventTypes === "string") {
                            events = [eventTypes];
                        }
                        else {
                            events = eventTypes;
                        }
                        for (var i = 0; i < events.length; i++) {
                            var eventType = events[i];
                            // specific listeners for the given event type
                            var listeners = listenersStore[eventType];
                            if (!listeners) {
                                listeners = [];
                                listenersStore[eventType] = listeners;
                            }
                        }
                    };
                    /**
                     * Dispatches an event to children => executes all listeners
                     * @param eventType type of the event
                     * @param $scope scope of the container
                     */
                    ContainerEventService.prototype.dispatch = function (eventType, $scope) {
                        var listenersStore = $scope[ContainerEventService.SCOPE_KEY];
                        if (!listenersStore) {
                            return;
                        }
                        // TODO: allow event object?
                        // add currentTarget?
                        // dispatch event to all children
                        var listeners = listenersStore[eventType];
                        if (listeners) {
                            for (var i = 0; i < listeners.length; i++) {
                                var listener = listeners[i];
                                listener();
                            }
                        }
                    };
                    /** Key used to store the event listener store in the scope of the container.*/
                    ContainerEventService.SCOPE_KEY = "###event-dispatcher###";
                    return ContainerEventService;
                })();
                /**
                 * Service that allows a container to dispatch an event to registered children.
                 */
                service._module.service("containerEventService", ContainerEventService);
            })(service = core.service || (core.service = {}));
        })(core = components.core || (components.core = {}));
    })(components = ers.components || (ers.components = {}));
})(ers || (ers = {}));/*
 * Created by ZhangFa on 6/16/2015.
 */

var ers;
(function (ers) {
    var components;
    (function (components) {
        var core;
        (function (core) {
            var service;
            (function (service) {
                var AUTO_TOKEN = /\s?auto?\s?/i;
                /**
                 * A dictionary of offset calculators for all possible placements
                 *
                 * @type {{top: (function(IPosition, ISize): JQueryCoordinates),
                 * top-left: (function(IPosition, ISize): JQueryCoordinates),
                 * top-right: (function(IPosition, ISize): JQueryCoordinates),
                 * right: (function(IPosition, ISize): JQueryCoordinates), r
                 * right-top: (function(IPosition, ISize): JQueryCoordinates),
                 * right-bottom: (function(IPosition, ISize): JQueryCoordinates),
                 * bottom: (function(IPosition, ISize): JQueryCoordinates),
                 * bottom-left: (function(IPosition, ISize): JQueryCoordinates),
                 * bottom-right: (function(IPosition, ISize): JQueryCoordinates),
                 * left: (function(IPosition, ISize): JQueryCoordinates),
                 * left-top: (function(IPosition, ISize): JQueryCoordinates),
                 * left-bottom: (function(IPosition, ISize): JQueryCoordinates)}}
                 */
                var OFFSET_CALCULATORS = {
                    "top": function (hPos, tSize) {
                        return {
                            top: hPos.top - tSize.height,
                            left: hPos.left + (hPos.width / 2) - (tSize.width / 2)
                        };
                    },
                    "top-left": function (hPos, tSize) {
                        return {
                            top: hPos.top - tSize.height,
                            left: hPos.left
                        };
                    },
                    "top-right": function (hPos, tSize) {
                        return {
                            top: hPos.top - tSize.height,
                            left: hPos.left + hPos.width - tSize.width
                        };
                    },
                    "right": function (hPos, tSize) {
                        return {
                            top: hPos.top + (hPos.height / 2) - (tSize.height / 2),
                            left: hPos.left + hPos.width
                        };
                    },
                    "right-top": function (hPos, tSize) {
                        return {
                            top: hPos.top,
                            left: hPos.left + hPos.width
                        };
                    },
                    "right-bottom": function (hPos, tSize) {
                        return {
                            top: hPos.top - tSize.height + hPos.height,
                            left: hPos.left + hPos.width
                        };
                    },
                    "bottom": function (hPos, tSize) {
                        return {
                            top: hPos.top + hPos.height,
                            left: hPos.left + (hPos.width / 2) - (tSize.width / 2)
                        };
                    },
                    "bottom-left": function (hPos, tSize) {
                        return {
                            top: hPos.top + hPos.height,
                            left: hPos.left
                        };
                    },
                    "bottom-right": function (hPos, tSize) {
                        return {
                            top: hPos.top + hPos.height,
                            left: hPos.left + hPos.width - tSize.width
                        };
                    },
                    "left": function (hPos, tSize) {
                        return {
                            top: hPos.top + (hPos.height / 2) - (tSize.height / 2),
                            left: hPos.left - tSize.width
                        };
                    },
                    "left-top": function (hPos, tSize) {
                        return {
                            top: hPos.top,
                            left: hPos.left - tSize.width
                        };
                    },
                    "left-bottom": function (hPos, tSize) {
                        return {
                            top: hPos.top - tSize.height + hPos.height,
                            left: hPos.left - tSize.width
                        };
                    }
                };
                /**
                 * See [[IPlacementService]]
                 */
                var PlacementService = (function () {
                    function PlacementService() {
                    }
                    PlacementService.prototype.isValid = function (placement) {
                        if (this.isAutoPlace(placement)) {
                            placement = placement.replace(AUTO_TOKEN, "");
                        }
                        return angular.isDefined(OFFSET_CALCULATORS[placement]);
                    };
                    PlacementService.prototype.toPlacementObject = function (placement) {
                        if (!this.isValid(placement)) {
                            return null;
                        }
                        var isAuto = this.isAutoPlace(placement);
                        if (isAuto) {
                            placement = placement.replace(AUTO_TOKEN, "");
                        }
                        var split = placement.split("-");
                        return {
                            side: split[0],
                            alignment: split[1],
                            auto: isAuto,
                            toString: function () {
                                var str = this.alignment ? this.side + "-" + this.alignment : this.side;
                                return this.auto ? "auto " + str : str;
                            }
                        };
                    };
                    PlacementService.prototype.applyPlacement = function (target, reference, placement, container) {
                        if (!reference || !target) {
                            return target;
                        }
                        container = container || "body";
                        if (angular.isString(placement)) {
                            placement = this.toPlacementObject(placement);
                        }
                        if (!placement) {
                            return target;
                        }
                        return angular.isElement(reference) ?
                            this.placeOverElement(target, reference, placement, container) :
                            this.placeOverCoordinate(target, reference, placement, container);
                    };
                    PlacementService.prototype.placeOverCoordinate = function (target, coord, placement, container) {
                        var hPos = {
                            left: coord.left,
                            right: coord.left,
                            top: coord.top,
                            bottom: coord.top,
                            width: 0,
                            height: 0
                        };
                        void 0;
                        if (placement.auto) {
                            placement = this.getAutoPlacement(target, hPos, placement, container);
                        }
                        void 0;
                        this.setPosition(target, placement.toString(), hPos);
                        return target;
                    };
                    PlacementService.prototype.placeOverElement = function (target, host, placement, container) {
                        var hPos = this.getPosition(host);
                        void 0;
                        if (placement.auto) {
                            placement = this.getAutoPlacement(target, hPos, placement, container);
                        }
                        void 0;
                        this.resetClass(target, placement.toString());
                        this.setPosition(target, placement.toString(), hPos);
                        this.ensurePosition(target, host);
                        return target;
                    };
                    PlacementService.prototype.resetClass = function (target, placement) {
                        angular.forEach(OFFSET_CALCULATORS, function (value, placement) {
                            target.removeClass(placement);
                        });
                        target.addClass(placement);
                    };
                    PlacementService.prototype.setPosition = function (target, placement, hPos) {
                        // target's width & height may change when positioned near the edge of the screen,
                        // so need continually calculating the best position
                        var adjustTimes = 3;
                        do {
                            var tWidth = target.outerWidth(true), tHeight = target.outerHeight(true);
                            var offset = this.calculateOffset(placement, hPos, { width: tWidth, height: tHeight });
                            var marginTop = parseInt(target.css("margin-top"), 10) || 0;
                            var marginLeft = parseInt(target.css("margin-left"), 10) || 0;
                            offset.top += marginTop;
                            offset.left += marginLeft;
                            target.offset(offset);
                        } while (--adjustTimes > 0 && (target.outerWidth(true) !== tWidth || target.outerHeight(true) !== tHeight));
                    };
                    PlacementService.prototype.isAutoPlace = function (placement) {
                        return AUTO_TOKEN.test(placement);
                    };
                    PlacementService.prototype.ensurePosition = function ($target, element) {
                        var offset = $target.offset(), ww = window.screen.width, dh = this.screenHeight, tw = $target.width(), th = $target.height(), eo = element.offset(), classList = $target.attr("class");
                        if (offset.left < 0) {
                            $target.css("left", 0);
                            $target.attr("class", classList.replace("right", "left"));
                        }
                        else if (offset.left > (ww - tw)) {
                            $target.css("left", (ww - tw));
                            $target.attr("class", classList.replace("left", "right"));
                        }
                        if (offset.top < 0) {
                            $target.css("top", eo.top);
                            $target.attr("class", classList.replace("bottom", "top"));
                        }
                        else if (offset.top > (dh - th)) {
                            $target.css("left", (eo.top - th));
                            $target.attr("class", classList.replace("top", "bottom"));
                        }
                    };
                    PlacementService.prototype.getPosition = function (element) {
                        var el = element[0];
                        var clipRect = (typeof el.getBoundingClientRect === "function") ? el.getBoundingClientRect() : {
                            width: el.offsetWidth,
                            height: el.offsetHeight,
                            top: 0,
                            left: 0
                        };
                        //Note: clipRect is not enumerable
                        var rectObj = {
                            width: clipRect.width,
                            height: clipRect.height,
                            left: clipRect.left,
                            right: clipRect.right,
                            top: clipRect.top,
                            bottom: clipRect.bottom
                        };
                        var offset = element.offset();
                        return angular.extend({}, rectObj, offset);
                    };
                    PlacementService.prototype.calculateOffset = function (placement, hPos, tSize) {
                        var offsetCalculator = OFFSET_CALCULATORS[placement];
                        var offset = offsetCalculator(hPos, tSize);
                        return this.ensureNonNegative(offset);
                    };
                    PlacementService.prototype.ensureNonNegative = function (o) {
                        angular.forEach(o, function (value, key) {
                            o[key] = value < 0 ? 0 : value;
                        });
                        return o;
                    };
                    PlacementService.prototype.getAutoPlacement = function (target, hPos, placement, container) {
                        var tWidth = target.outerWidth(true);
                        var tHeight = target.outerHeight(true);
                        var $container = this.resolveContainer(container);
                        var scrollTop = document.documentElement.scrollTop || document.body.scrollTop;
                        var parentTop = $.isWindow($container[0]) ? scrollTop : $container.offset().top;
                        var parentLeft = $.isWindow($container[0]) ? 0 : $container.offset().left;
                        var parentWidth = $container.innerWidth();
                        var parentHeight = $container.innerHeight();
                        placement = this.adjustVertically(placement, hPos, tHeight, parentHeight, parentTop);
                        placement = this.adjustHorizontally(placement, hPos, tWidth, parentWidth, parentLeft);
                        placement.auto = false;
                        return placement;
                    };
                    PlacementService.prototype.resolveContainer = function (container) {
                        if (container === "body") {
                            return $(window);
                        }
                        var $container = $(container);
                        return $container.css("overflow") === "visible" ? $(window) : $container;
                    };
                    PlacementService.prototype.adjustVertically = function (placement, hPos, tHeight, parentHeight, parentTop) {
                        //exceed the bottom of the screen or container, then turn to the top side
                        if (hPos.top + hPos.height + tHeight > parentTop + parentHeight) {
                            placement.side = (placement.side === "bottom" ? "top" : placement.side);
                            placement.alignment = (placement.alignment === "top" ? "bottom" : placement.alignment);
                            return placement;
                        }
                        //excede the top of the screen or container, then turn to the bottom side
                        if (hPos.top < parentTop - tHeight) {
                            placement.side = (placement.side === "top" ? "bottom" : placement.side);
                            placement.alignment = (placement.alignment === "bottom" ? "top" : placement.alignment);
                            return placement;
                        }
                        return placement;
                    };
                    PlacementService.prototype.adjustHorizontally = function (placement, hPos, tWidth, parentWidth, parentLeft) {
                        //exceed the right border of the screen, then turn to the left side
                        if (hPos.right + tWidth > parentLeft + parentWidth) {
                            placement.side = (placement.side === "right" ? "left" : placement.side);
                            placement.alignment = (placement.alignment === "left" ? "right" : placement.alignment);
                            return placement;
                        }
                        //exceed the left border of the screen, then turn to the right side
                        if (hPos.left - tWidth < parentLeft) {
                            placement.side = (placement.side === "left" ? "right" : placement.side);
                            placement.alignment = (placement.alignment === "right" ? "left" : placement.alignment);
                            return placement;
                        }
                        return placement;
                    };
                    Object.defineProperty(PlacementService.prototype, "screenHeight", {
                        get: function () {
                            return Math.max(document.body.scrollHeight, document.documentElement.scrollHeight, document.body.offsetHeight, document.documentElement.offsetHeight, document.body.clientHeight, document.documentElement.clientHeight);
                        },
                        enumerable: true,
                        configurable: true
                    });
                    return PlacementService;
                })();
                service._module.service("placementService", PlacementService);
            })(service = core.service || (core.service = {}));
        })(core = components.core || (components.core = {}));
    })(components = ers.components || (ers.components = {}));
})(ers || (ers = {}));/*
 * Created by FangioT on 3/30/2015.
 */

/**
 * @ngdoc service
 * @name ResizeService
 * @module ers.components.core.service
 *
 * @description
 *
 * Defines a service that allows components to resize.  `ers.services.resize` is callable by all components.
 *
 * <!--
 * <h4 class="doc-title with-line slim-top-margin">Methods</h4>
 *
 *     resize(): void
 *
 * Notifies all registered listeners of a resize event. This is called either automatically, when a window resize event
 * occurs, or manually, when called from your code.
 *
 *     registerListener(<i>listener</i> : <font color="red">IResizeListener</font>):void
 *
 * Registers a listener that is called when a resize event request occurs.
 * //-->
 *
 */
var ers;
(function (ers) {
    var components;
    (function (components) {
        var core;
        (function (core) {
            var service;
            (function (service) {
                                var ResizeService = (function () {
                    function ResizeService() {
                        this.listeners = [];
                        ResizeService.serviceInstances.push(this);
                        // On a window resize, call our resize function, but throttle it so as not to overwhelm the UI
                        $(window).on("resize", _.debounce(this.resize, ResizeService.THROTTLE_LIMIT));
                    }
                    /**
                     * @ngdoc method
                     * @name ResizeService#resize
                     *
                     *
                     * @description
                     *
                     *
                     *
                     * Notifies all registered listeners of a resize event. This is called either automatically,
                     * when a window resize event
                     * occurs, or manually, when called from your code.
                     */
                    ResizeService.prototype.resize = function () {
                        var w = $(window);
                        var dimensions = {
                            width: w.width(), height: w.height()
                        };
                        _.each(ResizeService.serviceInstances, function (serviceInstance) {
                            _.each(serviceInstance.listeners, function (listener) {
                                if (listener) {
                                    listener.resizeDidOccur(dimensions);
                                }
                            });
                        });
                    };
                    /**
                     * @ngdoc method
                     * @name ResizeService#registerListener
                     *
                     * @description
                     *
                     * Registers a listener that is called when a resize event request occurs.
                     *
                     *
                     * @param {IResizeListener} listener The listener to be registered.
                     *
                     * Must conform to the IResizeListener interface.
                     */
                    ResizeService.prototype.registerListener = function (listener) {
                        this.listeners.push(listener);
                    };
                    ResizeService.THROTTLE_LIMIT = 250;
                    // Store a reference to the created service so we can use it in the
                    // resize() function whose "this" property is `window`.
                    ResizeService.serviceInstances = [];
                    return ResizeService;
                })();
                service._module.service("ResizeService", ResizeService);
            })(service = core.service || (core.service = {}));
        })(core = components.core || (components.core = {}));
    })(components = ers.components || (ers.components = {}));
})(ers || (ers = {}));/*
 * Created by zhangfa on 3/13/2015.
 */

var ers;
(function (ers) {
    var components;
    (function (components) {
        var core;
        (function (core) {
            var service;
            (function (service) {
                var TemplateHelper = (function () {
                    function TemplateHelper($http, $templateCache) {
                        this.httpService = $http;
                        this.templateCache = $templateCache;
                    }
                    TemplateHelper.prototype.fetchTemplate = function (url) {
                        var _this = this;
                        var cachedTemplate = this.templateCache.get(url);
                        if (cachedTemplate) {
                            return cachedTemplate;
                        }
                        return this.httpService.get(url).then(function (res) {
                            var template = angular.isObject(res) ? res["data"] : res;
                            _this.templateCache.put(url, template);
                            return template;
                        });
                    };
                    TemplateHelper.$inject = ["$http", "$templateCache"];
                    return TemplateHelper;
                })();
                service._module.service("templateHelper", TemplateHelper);
            })(service = core.service || (core.service = {}));
        })(core = components.core || (components.core = {}));
    })(components = ers.components || (ers.components = {}));
})(ers || (ers = {}));/*
 * Created by zhangfa on 5/26/2015.
 */

var ers;
(function (ers) {
    var components;
    (function (components) {
        var core;
        (function (core) {
            var service;
            (function (service) {
                /**
                 * An mediator to encapsulate interaction between IValidationTarget instance and error renderer
                 */
                var ValidationMediator = (function () {
                    function ValidationMediator(target, errorRenderer) {
                        this.target = target;
                        this.registerValidators();
                        this.registerInvalidChangeListener();
                        this.errorRenderer = errorRenderer;
                    }
                    ValidationMediator.prototype.registerValidators = function () {
                        var ngModelCtrl = this.target.ngModelController;
                        this.target.validationRules().forEach(function (rule) {
                            ngModelCtrl.$setValidity(rule.key, true);
                            if (rule.validator) {
                                ngModelCtrl.$validators[rule.key] = rule.validator;
                            }
                        });
                    };
                    ValidationMediator.prototype.registerInvalidChangeListener = function () {
                        var _this = this;
                        var ngModelCtrl = this.target.ngModelController;
                        var targetScope = this.target.focusedElement().scope();
                        if (!targetScope) {
                            return;
                        }
                        // Deeply watch $error object as we want to display the error tooltip, even if the controller is already invalid
                        // Example : on a numberbox with max = 5 => user types 6 => tooltip error appears with invalid range message =>
                        // user enter s character => tooltip error must contains the 2 messages invalid range + invalid number...
                        targetScope.$watch(function () {
                            return new ValidationErrorObject(ngModelCtrl.$dirty, ngModelCtrl.$error);
                        }, function (newErrorObj, oldErrorObj) {
                            void 0;
                            var newErrors = newErrorObj.errors;
                            var oldErrors = oldErrorObj.errors;
                            if (newErrors === oldErrors) {
                                // new and old are equal => first time the watcher is triggered
                                // but if an error already exists, message should be displayed
                                var found = false;
                                for (var p in newErrors) {
                                    if (newErrors.hasOwnProperty(p)) {
                                        found = true;
                                        break;
                                    }
                                }
                                if (!found) {
                                    return;
                                }
                            }
                            _this.manageMessage();
                        }, true);
                    };
                    ValidationMediator.prototype.getErrorMessages = function () {
                        var $error = this.target.ngModelController.$error;
                        return this.target.validationRules()
                            .filter(function (rule) {
                            return $error[rule.key];
                        })
                            .map(function (rule) {
                            return rule.errorMessage;
                        });
                    };
                    ValidationMediator.prototype.manageMessage = function () {
                        if (!this.errorRenderer) {
                            return;
                        }
                        var targetElement = this.target.focusedElement();
                        // tooltip is created only if the model is invalid and if the component allows to show it.
                        if (this.target.ngModelController.$invalid && ((this.target.showError && this.target.showError()) || !this.target.showError)) {
                            this.errorRenderer.render(targetElement, this.target.id(), angular.bind(this, this.getErrorMessages));
                        }
                        else {
                            this.errorRenderer.clear(targetElement);
                        }
                    };
                    ValidationMediator.prototype.reloadMessage = function () {
                        if (!this.errorRenderer) {
                            return;
                        }
                        var targetElement = this.target.focusedElement();
                        this.errorRenderer.clear(targetElement);
                        this.errorRenderer.render(targetElement, this.target.id(), angular.bind(this, this.getErrorMessages));
                    };
                    ValidationMediator.prototype.contains = function (target) {
                        return this.target === target;
                    };
                    ValidationMediator.prototype.destroy = function () {
                        if (this.errorRenderer) {
                            this.errorRenderer.clear(this.target.focusedElement());
                        }
                        this.target = null;
                    };
                    return ValidationMediator;
                })();
                /**
                 * This class is used to create very useful error object in order to watch the $dirty state of the component in addition
                 * to the errors list.
                 * This need came since we chose to hide the tooltip error at the first load of the component when it failed.
                 *
                 * Take the following example step by step:
                 * 1. We have an non-empty ers-texbox component (with a initial value which no respect the minlength constraint)
                 * 2. When loaded at the first time, the component has the following $error ($pristine=true and $dirty=false): { minlength: true }
                 * 3. The user completes the value with a new character but the minlength constraint is still not respected.
                 *      $error still equals to { minlength: true }.
                 * 4. Without an instance of this class, if we watch only the $error property, no change is detected by AngularJS and thus the
                 * errorRenderer cannot be applied.
                 * 5. Thus we have to mix the watching of the $error property with the watching of the component state ($dirty/$pristine).
                 *    => This is the aim of this ValidationErrorObject class.
                 */
                var ValidationErrorObject = (function () {
                    /**
                     * Build a ValidationErrorObject.
                     * @param pIsDirty true/false. The $dirty state of the ngModelController.
                     * @param pErrors The errors which occurred on the ngModel.
                     */
                    function ValidationErrorObject(pIsDirty, pErrors) {
                        this._isDirty = pIsDirty;
                        this._errors = pErrors;
                    }
                    Object.defineProperty(ValidationErrorObject.prototype, "isDirty", {
                        /**
                         * @return {boolean} Returns the errors which occurred on the ngModel.
                         */
                        get: function () {
                            return this._isDirty;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(ValidationErrorObject.prototype, "errors", {
                        /**
                         * @returns {string[]} Returns true/false. The $dirty state of the ngModelController.
                         */
                        get: function () {
                            return this._errors;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    return ValidationErrorObject;
                })();
                /**
                 * Impelementation of [[IValidationManager]]
                 */
                var ValidationManager = (function () {
                    function ValidationManager(errorRenderer) {
                        this.mediators = [];
                        this.errorRenderer = errorRenderer;
                    }
                    /**
                     * Refer to @[[IValidationManager]]
                     *
                     * @param target
                     */
                    ValidationManager.prototype.registerTarget = function (target) {
                        this.mediators.push(new ValidationMediator(target, this.errorRenderer));
                    };
                    /**
                     * Refer to @[[IValidationManager]]
                     *
                     * @param target
                     */
                    ValidationManager.prototype.unregisterTarget = function (target) {
                        var matchedMediators = this.mediators.filter(function (w) {
                            return w.contains(target);
                        });
                        if (matchedMediators.length === 0) {
                            return;
                        }
                        var index = this.mediators.indexOf(matchedMediators[0]);
                        this.mediators.splice(index, 1);
                        matchedMediators[0].destroy();
                    };
                    ValidationManager.prototype.manageMessage = function (target) {
                        for (var i = 0; i < this.mediators.length; i++) {
                            var m = this.mediators[i];
                            if (m.contains(target)) {
                                m.manageMessage();
                            }
                        }
                    };
                    ValidationManager.prototype.reloadMessage = function (target) {
                        for (var i = 0; i < this.mediators.length; i++) {
                            var m = this.mediators[i];
                            if (m.contains(target)) {
                                m.reloadMessage();
                            }
                        }
                    };
                    return ValidationManager;
                })();
                /**
                 * Impelementation of [[IValidationManagerProvider]]
                 */
                var ValidationManagerProvider = (function () {
                    function ValidationManagerProvider() {
                        var _this = this;
                        /**
                         * function to get an instance of [[IValidationManager]]
                         * @type {any[]}
                         */
                        this.$get = ["$injector", function ($injector) {
                                var errorRenderer;
                                if (_this.errorRendererName) {
                                    void 0;
                                    errorRenderer = $injector.get(_this.errorRendererName);
                                }
                                void 0;
                                return new ValidationManager(errorRenderer);
                            }];
                    }
                    /**
                     * Refer to [[IValidationManagerProvider]]
                     * @param name
                     */
                    ValidationManagerProvider.prototype.setErrorRendererName = function (name) {
                        this.errorRendererName = name;
                    };
                    return ValidationManagerProvider;
                })();
                service._module.provider("validationManager", ValidationManagerProvider);
            })(service = core.service || (core.service = {}));
        })(core = components.core || (components.core = {}));
    })(components = ers.components || (ers.components = {}));
})(ers || (ers = {}));

//# sourceMappingURL=ers-ui-components.js.map
(function(module) {
try {
  module = angular.module('ers.components.templates');
} catch (e) {
  module = angular.module('ers.components.templates', []);
}
module.run(['$templateCache', function($templateCache) {
  $templateCache.put('accordion/template/accordion-group-template.html',
    '<div class="panel panel-default"><a href=javascript:void(0) tabindex=0 class=accordion-toggle ng-click=vm.toggleOpen() ng-class="{ \'is-open\': vm.isOpen }"><div class=panel-heading><div class=panel-title><span ng-class="{\'text-muted\': vm.ngDisabled || vm.parent.ngDisabled}"><i class="pull-left fa fa-caret-right"></i> {{vm.heading}} <span ers-accordion-heading-transclude></span> <span class=result-count>{{vm.subheading}} <span ers-accordion-subheading-transclude></span></span></span></div></div></a><div class=panel-collapse uib-collapse=!vm.isOpen><div class=panel-body ng-transclude></div></div></div>');
}]);
})();

(function(module) {
try {
  module = angular.module('ers.components.templates');
} catch (e) {
  module = angular.module('ers.components.templates', []);
}
module.run(['$templateCache', function($templateCache) {
  $templateCache.put('accordion/template/accordion-template.html',
    '<div class="panel-group ers-accordion" ng-transclude></div>');
}]);
})();

(function(module) {
try {
  module = angular.module('ers.components.templates');
} catch (e) {
  module = angular.module('ers.components.templates', []);
}
module.run(['$templateCache', function($templateCache) {
  $templateCache.put('button/template/button-template.html',
    '<div ng-click=ctrl.onClick($event)><button ng-disabled=ctrl.ngDisabled name={{ctrl.name}} class=btn value={{ctrl.label}} type={{ctrl.type}}><ng-transclude></ng-transclude>{{ctrl.label}}</button></div>');
}]);
})();

(function(module) {
try {
  module = angular.module('ers.components.templates');
} catch (e) {
  module = angular.module('ers.components.templates', []);
}
module.run(['$templateCache', function($templateCache) {
  $templateCache.put('calendar/template/calendar-template.html',
    '<div class=input-group><input type=text class=form-control datepicker-append-to-body=calendarCtrl.appendToBody uib-datepicker-popup={{calendarCtrl.dateFormat}} datepicker-options=calendarCtrl.dateOptions ng-model=calendarCtrl.ngModel ng-model-options="{allowInvalid: true}" is-open=calendarCtrl.isOpen show-button-bar=calendarCtrl.showButtonBar close-text={{calendarCtrl.closeText}} clear-text={{calendarCtrl.clearText}} current-text={{calendarCtrl.currentText}} ng-disabled=calendarCtrl.ngDisabled ng-readonly=calendarCtrl.ngReadonly ng-change=calendarCtrl.dateChanged() ng-click=calendarCtrl.open()> <span class=input-group-btn><button class="btn btn-default" type=button ng-click=calendarCtrl.open()><i class="fa fa-calendar"></i></button></span></div>');
}]);
})();

(function(module) {
try {
  module = angular.module('ers.components.templates');
} catch (e) {
  module = angular.module('ers.components.templates', []);
}
module.run(['$templateCache', function($templateCache) {
  $templateCache.put('chart/template/chart-template.html',
    '<div ng-attr-id={{ctrl.containerId}} class=chart-container ng-class="{ready: ctrl.ready}"></div>');
}]);
})();

(function(module) {
try {
  module = angular.module('ers.components.templates');
} catch (e) {
  module = angular.module('ers.components.templates', []);
}
module.run(['$templateCache', function($templateCache) {
  $templateCache.put('checkbox/template/checkbox-template.html',
    '<div ng-form=subForm><div class=checkbox-btn-div><div class=ers-checkbox-button><div class=checkbox-btn-div><div class=erscheckbox></div></div><div class=checkbox-display-div ng-transclude></div></div></div></div>');
}]);
})();

(function(module) {
try {
  module = angular.module('ers.components.templates');
} catch (e) {
  module = angular.module('ers.components.templates', []);
}
module.run(['$templateCache', function($templateCache) {
  $templateCache.put('combobox/template/combobox-item-template.html',
    '<li role=presentation><a class=menuitem><ng-transclude></ng-transclude></a></li>');
}]);
})();

(function(module) {
try {
  module = angular.module('ers.components.templates');
} catch (e) {
  module = angular.module('ers.components.templates', []);
}
module.run(['$templateCache', function($templateCache) {
  $templateCache.put('combobox/template/combobox-template.html',
    '<div class="btn-group dropdown-select" ng-form=subForm><button type=button class="dropdown-toggle form-control btn btn-sm btn-fixed-size" ers-popover po-placement="bottom auto" po-show-arrow={{comboboxController.withArrow}} po-target=#{{comboboxController.targetId}} po-keyboard=true po-container=body po-lazy-load=true><span class=button-text></span> <span class=select-caret><span class="fa-stack fa-lg"><i class="fa fa-stack-1x"></i></span></span></button><div ng-show=!comboboxController._ngDisabled class="ers-combobox ers-combobox-list" style=display:none;width:100%><ul class=popover-content style=max-height:150px;overflow-y:auto><ng-transclude></ng-transclude></ul></div></div>');
}]);
})();

(function(module) {
try {
  module = angular.module('ers.components.templates');
} catch (e) {
  module = angular.module('ers.components.templates', []);
}
module.run(['$templateCache', function($templateCache) {
  $templateCache.put('contextmenu/template/contextmenu.tpl.html',
    '<div id={{id}} class="ers-context-menu clearfix" ng-keydown=onKeyDown($event) tabindex=0><ul class=context-menu-dropdown role=menu><li ng-repeat="item in menuItems" ng-hide=!item.visible ng-class="{\'separatorBefore\': item.separatorBefore, \'disabled\': !item.enabled, \'submenu\': item.children.length > 0}"><a tabindex="{{item.enabled ? 1 : -1}}" ng-if="!item.children || item.children.length == 0" ng-click=item.onClick($event)><ers-icon class=menu-item-icon name={{item.icon}} ng-if=item.icon></ers-icon><span ng-bind-html=item.label></span></a><ers-link-menu label={{item.label}} icon={{item.icon}} menu-items=item.children placement="auto right-top" trigger=hover exclusively=false container=self ng-if="item.children.length > 0"></ers-link-menu></li></ul></div>');
}]);
})();

(function(module) {
try {
  module = angular.module('ers.components.templates');
} catch (e) {
  module = angular.module('ers.components.templates', []);
}
module.run(['$templateCache', function($templateCache) {
  $templateCache.put('contextmenu/template/linkmenu.tpl.html',
    '<a class=ers-link-menu><ers-icon class=menu-item-icon name={{icon}} ng-if=icon></ers-icon><span ng-bind-html=label></span> <span class=direction-arrow><i class="fa fa-chevron-{{direction}}"></i></span></a>');
}]);
})();

(function(module) {
try {
  module = angular.module('ers.components.templates');
} catch (e) {
  module = angular.module('ers.components.templates', []);
}
module.run(['$templateCache', function($templateCache) {
  $templateCache.put('drawer/template/drawer-header-template.html',
    '<div class=ers-drawer-header-part-{{drawerHeaderComponent.drawerController.slideFrom}}><ers-icon name="{{drawerHeaderComponent.drawerController.pinned?\'unpin\':\'pin\'}}" ng-click=drawerHeaderComponent.togglePinned()></ers-icon><ng-transclude></ng-transclude></div>');
}]);
})();

(function(module) {
try {
  module = angular.module('ers.components.templates');
} catch (e) {
  module = angular.module('ers.components.templates', []);
}
module.run(['$templateCache', function($templateCache) {
  $templateCache.put('drawer/template/drawer-splitter-bar-template.html',
    '<i class="before-icon fa {{ ::drawerController.getSplitterExpandArrow() }}"></i> <i class="ellipsis-icon fa {{ ::drawerController.getSplitterEllipsisIcon() }}"></i> <i class="after-icon fa {{ ::drawerController.getSplitterCollapseArrow() }}"></i>');
}]);
})();

(function(module) {
try {
  module = angular.module('ers.components.templates');
} catch (e) {
  module = angular.module('ers.components.templates', []);
}
module.run(['$templateCache', function($templateCache) {
  $templateCache.put('drawer/template/drawer-tab-template.html',
    '<div class=ers-drawer-tab-icon-{{drawerController.slideFrom}}><i class="fa fa-play"></i></div><div class=ers-drawer-tab-label-{{drawerController.slideFrom}}><p>{{ drawerController.label }}</p></div>');
}]);
})();

(function(module) {
try {
  module = angular.module('ers.components.templates');
} catch (e) {
  module = angular.module('ers.components.templates', []);
}
module.run(['$templateCache', function($templateCache) {
  $templateCache.put('drawer/template/drawer-template.html',
    '<div class="ers-drawer-container ers-drawer-container-{{drawerController.slideFrom}}"><div class=ers-drawer-tab-container-{{drawerController.slideFrom}} ng-if="drawerController.slideFrom === \'right\'"><div class=ers-drawer-tab-icon-{{drawerController.slideFrom}}><i class="fa fa-play"></i></div><div class=ers-drawer-tab-label-{{drawerController.slideFrom}}><p>{{ drawerController.label }}</p></div></div><div class=ers-drawer-tab-container-{{drawerController.slideFrom}} ng-if="drawerController.slideFrom === \'bottom\'"><div class=ers-drawer-tab-icon-{{drawerController.slideFrom}}><i class="fa fa-play"></i></div><div class=ers-drawer-tab-label-{{drawerController.slideFrom}}><p>{{ drawerController.label }}</p></div></div><div class=ers-drawer-block-container-{{drawerController.slideFrom}}><ng-include src="\'drawer/template/drawer-splitter-bar-template.html\'" ng-if="drawerController.slideFrom === \'right\'" class=ers-splitter-bar-{{drawerController.slideFrom}}></ng-include><ng-include src="\'drawer/template/drawer-splitter-bar-template.html\'" ng-if="drawerController.slideFrom === \'bottom\'" class=ers-splitter-bar-{{drawerController.slideFrom}}></ng-include><div class=ers-drawer-content-{{drawerController.slideFrom}} ng-transclude></div><ng-include src="\'drawer/template/drawer-splitter-bar-template.html\'" ng-if="drawerController.slideFrom === \'left\'" class=ers-splitter-bar-{{drawerController.slideFrom}}></ng-include><ng-include src="\'drawer/template/drawer-splitter-bar-template.html\'" ng-if="drawerController.slideFrom === \'top\'" class=ers-splitter-bar-{{drawerController.slideFrom}}></ng-include></div><div class=ers-drawer-tab-container-{{drawerController.slideFrom}} ng-if="drawerController.slideFrom === \'left\'"><div class=ers-drawer-tab-icon-{{drawerController.slideFrom}}><i class="fa fa-play"></i></div><div class=ers-drawer-tab-label-{{drawerController.slideFrom}}><p>{{ drawerController.label }}</p></div></div><div class=ers-drawer-tab-container-{{drawerController.slideFrom}} ng-if="drawerController.slideFrom === \'top\'"><div class=ers-drawer-tab-icon-{{drawerController.slideFrom}}><i class="fa fa-play"></i></div><div class=ers-drawer-tab-label-{{drawerController.slideFrom}}><p>{{ drawerController.label }}</p></div></div></div>');
}]);
})();

(function(module) {
try {
  module = angular.module('ers.components.templates');
} catch (e) {
  module = angular.module('ers.components.templates', []);
}
module.run(['$templateCache', function($templateCache) {
  $templateCache.put('dropdown-select/template/dropdown-select-grid.html',
    '<div class=select-container ng-class="{\'open\' : ctrl.open}"><div ng-if="::ctrl.filterMode !== \'off\'" ng-mouseenter="icon=true" ng-mouseleave="icon=false"><span class=set-icon ng-if=::ctrl.useSearchIcon><span ng-if="ctrl.ngModel !== null && !ctrl.ngDisabled"><i class=remove-selection-icon ng-class="{\'fa fa-close\' : icon}" ng-mousedown=::ctrl.clearSelection($event)></i></span> <i class="fa fa-search input-icon search-icon" ng-class="{disableIcon: ctrl.ngDisabled}" ng-mousedown=::ctrl.openDropdown($event)></i></span> <span class=set-icon ng-if=::!ctrl.useSearchIcon><span ng-if="ctrl.ngModel !== null && !ctrl.ngDisabled"><i class=remove-selection-icon ng-class="{\'fa fa-close\' : icon}" ng-mousedown=::ctrl.clearSelection($event)></i></span> <i class=input-icon ng-class="{\'fa fa-chevron-up\': ctrl.open, \'fa fa-chevron-down\': !ctrl.open, disableIcon: ctrl.ngDisabled}" ng-mousedown=::ctrl.toggleDropdown($event)></i></span> <input ng-if=::!ctrl.multiSelect type=text class=form-control name=inputField placeholder={{::ctrl.placeholder}} ng-change=::ctrl.filterTextChangeLocal($event) ng-model=ctrl.ngModelValue ng-click=::ctrl.openDropdown($event) ng-disabled=::ctrl.ngDisabled ng-blur=::ctrl.resetInput() ng-keydown=::ctrl.onKeyboardPressed($event) ng-required=::ctrl.ngRequired> <input ng-if=::ctrl.multiSelect id=inputElement type=text class="form-control no-select" name=inputField placeholder={{::ctrl.placeholder}} ng-change=::ctrl.filterTextChangeLocal($event) ng-model=ctrl.ngModelValue ng-click=::ctrl.openDropdown($event) ng-disabled=::ctrl.ngDisabled ng-blur=::ctrl.resetInput() ng-keydown=::ctrl.onKeyboardPressed($event) ng-required=::ctrl.ngRequired></div><div ng-if="::ctrl.filterMode === \'off\'"><div class="btn btn-default form-control" tabindex=1 type=button ng-click=::ctrl.toggleDropdown($event) ng-disabled=::ctrl.ngDisabled ng-keydown=::ctrl.onKeyboardPressed($event) ng-required=::ctrl.ngRequired ng-mouseenter="icon=true" ng-mouseleave="icon=false"><span ng-if="ctrl.ngModel !== null && ctrl.ngDisabled">{{ctrl.ngModelValue ? ctrl.ngModelValue : ctrl.placeholder}}</span> <span ng-if="ctrl.ngModel !== null && !ctrl.ngDisabled">{{ctrl.ngModelValue ? ctrl.ngModelValue : ctrl.placeholder}} <i class=remove-selection-icon ng-class="{\'fa fa-close\' : icon}" ng-mousedown=::ctrl.clearSelection($event)></i></span> <span ng-if="ctrl.ngModel === null">{{::ctrl.placeholder}}</span> <i ng-class="{\'fa fa-chevron-up\': ctrl.open, \'fa fa-chevron-down\': !ctrl.open, disableIcon: ctrl.ngDisabled}"></i></div></div><div class=dropdown-menu ng-if=::!ctrl.ngDisabled><table class=table><thead><tr><th ng-repeat="heading in ::ctrl.gridColumnHeaders" class=text-center>{{heading}}</th></tr></thead><tbody><tr ng-repeat="row in ctrl.filteredItems" ng-class="{\'active\': ctrl.checkEquality(row, ctrl.ngModel), \'focus\': row === ctrl.focusedRow}" ng-mousedown="::ctrl.onSelectedLocal(row, $event)" ng-mouseover=::ctrl.setFocusedRow(-1)><td ng-repeat="value in ::ctrl.sort(row) track by $index" class=text-center>{{::value}}</td></tr><tr ng-show="ctrl.filteredItems.length <= 0"><td class=text-center colspan={{::ctrl.gridColumnHeaders.length}}>{{::ctrl.noResultsMessage}}</td></tr></tbody></table></div></div>');
}]);
})();

(function(module) {
try {
  module = angular.module('ers.components.templates');
} catch (e) {
  module = angular.module('ers.components.templates', []);
}
module.run(['$templateCache', function($templateCache) {
  $templateCache.put('dropdown-select/template/dropdown-select-standard.html',
    '<div class=select-container ng-class="{\'open\' : ctrl.open}"><div ng-if="::ctrl.filterMode !== \'off\'" ng-mouseenter="icon=true" ng-mouseleave="icon=false"><span class=set-icon ng-if=::ctrl.useSearchIcon><span ng-if="ctrl.ngModel !== null && !ctrl.ngDisabled"><i class=remove-selection-icon ng-class="{\'fa fa-close\' : icon}" ng-mousedown=::ctrl.clearSelection($event)></i></span> <i class="fa fa-search input-icon" ng-class="{disableIcon: ctrl.ngDisabled}"></i></span> <span class=set-icon ng-if=::!ctrl.useSearchIcon><span ng-if="ctrl.ngModel !== null"><i class=remove-selection-icon ng-class="{\'fa fa-close\' : icon}" ng-mousedown=::ctrl.clearSelection($event)></i></span> <i class=input-icon ng-class="{\'fa fa-chevron-up\': ctrl.open, \'fa fa-chevron-down\': !ctrl.open, disabledIcon: ctrl.ngDisabled}" ng-mousedown=::ctrl.toggleDropdown($event)></i></span> <input ng-if=::!ctrl.multiSelect type=text class=form-control name=inputField placeholder={{::ctrl.placeholder}} ng-change=::ctrl.filterTextChangeLocal($event) ng-model=ctrl.ngModelValue ng-click=::ctrl.openDropdown($event) ng-disabled=::ctrl.ngDisabled ng-blur=::ctrl.resetInput() ng-keydown=::ctrl.onKeyboardPressed($event)> <input ng-if=::ctrl.multiSelect id=inputElement type=text class="form-control no-select" name=inputField placeholder={{::ctrl.placeholder}} ng-change=::ctrl.filterTextChangeLocal($event) ng-model=ctrl.ngModelValue ng-click=::ctrl.openDropdown($event) ng-disabled=::ctrl.ngDisabled ng-blur=::ctrl.resetInput() ng-keydown=::ctrl.onKeyboardPressed($event)></div><div ng-if="::ctrl.filterMode === \'off\'"><div class="btn btn-default form-control" tabindex=1 type=button ng-click=::ctrl.toggleDropdown($event) ng-disabled=::ctrl.ngDisabled ng-keydown=::ctrl.onKeyboardPressed($event) ng-mouseenter="icon=true" ng-mouseleave="icon=false"><span ng-if="ctrl.ngModel !== null && ctrl.ngDisabled">{{ctrl.ngModelValue ? ctrl.ngModelValue : ctrl.placeholder}}</span> <span ng-if="ctrl.ngModel !== null && !ctrl.ngDisabled">{{ctrl.ngModelValue ? ctrl.ngModelValue : ctrl.placeholder}} <i class=remove-selection-icon ng-class="{\'fa fa-close\' : icon}" ng-mousedown=::ctrl.clearSelection($event)></i></span> <span ng-if="ctrl.ngModel === null">{{::ctrl.placeholder}}</span> <i ng-class="{\'fa fa-chevron-up\': ctrl.open, \'fa fa-chevron-down\': !ctrl.open, disableIcon: ctrl.ngDisabled}"></i></div></div><ul class="dropdown-menu list-group" ng-if=::!ctrl.ngDisabled><li class=list-group-item ng-repeat="row in ctrl.filteredItems" ng-class="{\'active\': ctrl.checkEquality(row, ctrl.ngModel), \'focus\': row === ctrl.focusedRow }" ng-mousedown="::ctrl.onSelectedLocal(row, $event)" ng-mouseover=::ctrl.setFocusedRow(-1)>{{::row[ctrl.itemDisplayProperty]}}</li><li class="list-group-item text-center" ng-show="ctrl.filteredItems.length <= 0">{{::ctrl.noResultsMessage}}</li></ul></div>');
}]);
})();

(function(module) {
try {
  module = angular.module('ers.components.templates');
} catch (e) {
  module = angular.module('ers.components.templates', []);
}
module.run(['$templateCache', function($templateCache) {
  $templateCache.put('file/template/file-template.html',
    '<div class=ers-file-selector filters="queueLimit, customFilter"><div class=fileuploader-wrapper><div class=fileuploader><div class=dropzone><div class=uploader-area><p>{{ctrl.instructionText}}</p><div class=field-specs><div class=browse-textbox><ers-textbox ng-model=uploadedFileName placeholder={{ctrl.selectionInputPlaceHolderText}} ng-disabled=true></ers-textbox></div><ers-button type=button class=secondary onclick=$(this).next().click() ers-tooltip=Browse label=Browse ng-disabled=ctrl.selecting></ers-button><input id=selectFiles_{{ctrl.id}} class="btn btn-danger btn-xs" type=file multiple style="display: none;"><div><ers-icon name=information ers-popover po-content={{ctrl.informationTooltipTxt}} po-trigger=hover po-html=true po-hide-delay=1000 class=information-icon></ers-icon><span ng-if="ctrl.maxSize>=0" class=size-limit>Maximum file size is {{ctrl.maxSize}}MB</span></div></div><div class=text-center ng-if=ctrl.actionButtonVisible><ers-button ng-click=ctrl.actionButtonAction() label={{ctrl.actionButtonText}} ng-disabled="(ctrl.uploaderOptions.uploadStatus.uploading && ctrl.uploaderOptions.uploadStatus.uploading !==0) || !ctrl.selection || ctrl.selection.length<1|| ctrl.uploaderOptions.uploadStatus.toBeUploaded ===0"></ers-button></div></div><div class=clearfix></div><div class=bgimg-upload></div><div class=dragdrop-txt>Drag &amp; Drop Files<br>{{ctrl.dropZoneAdditionalText}}</div></div><div class=fileuploaderResults ng-show="ctrl.selection && ctrl.selection.length!=0"><div class=fileuploaderResultHeader><div class=progress-msg><p>{{ctrl.getSelectorUploaderText()}}</p></div><div class=progress style="width: 65%;float: left;margin-left: 10px; margin-right: 10px;" ng-if=ctrl.uploaderOptions.displayTotalProgress><div class=progress-bar role=progressbar ng-style="{ \'width\': ctrl.uploaderOptions.uploadStatus.progress + \'%\' }" style="width: 0%;"></div></div><div class=clear-queue><button type=button class="btn btn-link btn-xs" ng-click=ctrl.removeAllFiles()>Clear All</button></div><div class=clearfix></div></div><div class=progress-grid><div ng-repeat="item in ctrl.selection track by $index"><div class=filename-wrapper><a href=javascript:;><div ers-context-menu=ctrl.selectedItemContextMenu title="{{ item.file.name }}" ng-class="item.isUploadError?\'file-name-error\':\'file-name\'">{{ item.file.name }}</div></a></div><div ng-if=item.uploadHasBegun() class=progress-percent>{{item.uploadProgress}}%</div><div ng-if=item.uploadHasBegun() class=clearfix></div><div ng-if=item.uploadHasBegun() class=progress-wrapper><div class=progress><div class="progress-bar progress-bar-info progress-bar-striped" ng-class="item.isUploadError?\'progress-bar-danger\':item.isUploading?\'progress-bar-info\':\'progress-bar-success\'" role=progressbar aria-valuenow={{item.uploadProgress}} aria-valuemin=0 aria-valuemax=100 ng-style="{ \'width\': item.uploadProgress + \'%\' }"></div></div></div><div class=delete-file><ers-icon name=delete ng-click=ctrl.removeFile($index); title=delete class=fa-danger-action></ers-icon></div><div class=clearfix></div></div></div></div></div></div></div>');
}]);
})();

(function(module) {
try {
  module = angular.module('ers.components.templates');
} catch (e) {
  module = angular.module('ers.components.templates', []);
}
module.run(['$templateCache', function($templateCache) {
  $templateCache.put('grid/template/grid-template.html',
    '<div ng-hide=gridController.initialized class=loading-panel style=text-align:center;>{{gridController.loadingMessage}}</div><div class=ag-grid ng-if=gridController.initialized ag-grid=gridController.options></div>');
}]);
})();

(function(module) {
try {
  module = angular.module('ers.components.templates');
} catch (e) {
  module = angular.module('ers.components.templates', []);
}
module.run(['$templateCache', function($templateCache) {
  $templateCache.put('label/template/label-template.html',
    '<label class=ers-label title={{c.value}}><span class=ers-label-content ng-style=::c.contentStyle>{{c.value}}</span> <span ng-if=c.required class=ers-label-required>*</span></label>');
}]);
})();

(function(module) {
try {
  module = angular.module('ers.components.templates');
} catch (e) {
  module = angular.module('ers.components.templates', []);
}
module.run(['$templateCache', function($templateCache) {
  $templateCache.put('layout/template/layout-template.html',
    '<div class=ers-layout-container ng-transclude></div>');
}]);
})();

(function(module) {
try {
  module = angular.module('ers.components.templates');
} catch (e) {
  module = angular.module('ers.components.templates', []);
}
module.run(['$templateCache', function($templateCache) {
  $templateCache.put('layout/template/splitter-template.html',
    '<div class=ers-splitter-area><div class=ers-draggable-area><div class=ers-drag-img></div></div><div class=ers-prev-button-area><div class=ers-prev-img></div></div><div class=ers-next-button-area><div class=ers-next-img></div></div></div>');
}]);
})();

(function(module) {
try {
  module = angular.module('ers.components.templates');
} catch (e) {
  module = angular.module('ers.components.templates', []);
}
module.run(['$templateCache', function($templateCache) {
  $templateCache.put('login/template/login-template.html',
    '<script type=text/javascript ng-if=true>\n' +
    '    // do not remove the ng-if from the script tag, it\'s a trick to\n' +
    '    // set the focus on IE/Firefox browsers.\n' +
    '    $(function () {\n' +
    '        $(\'[autofocus]:not(:focus)\').eq(0).focus();\n' +
    '    });\n' +
    '</script><div class=ers-login ng-cloak><div class=main-frame><div class=login-header><h1 class=product-title>{{::ctrl.productName}}</h1><h1 ng-show=::ctrl.productName class=separator></h1><div class=login-title ng-style>Account Login</div></div><div class=login-box ng-cloak><div class=form-error ng-if=ctrl.getErrorMessage()>Unable to login: {{ctrl.getErrorMessage()}}</div><form name=loginForm role=form autocomplete=off novalidate id=loginForm><fieldset><input type=text style="display: none;"> <input type=password style="display: none;"><div class=form-input><input type=text name=username ng-model=ctrl.username placeholder=Username autofocus autocomplete=off ng-change="ctrl.loginError=undefined" ng-disabled=ctrl.computing class="{{ctrl.loginError ? (ctrl.loginError.credentialsError? \'invalid\' : \'valid\') : \'\'}}" required></div><div class=form-input><input type=password name=password ng-model=ctrl.password ng-change="ctrl.loginError=undefined" placeholder=Password ng-disabled=ctrl.computing autocomplete=off class="{{ctrl.loginError ? (ctrl.loginError.credentialsError? \'invalid\' : \'valid\') : \'\'}}" required></div><div class="form-input ers-dropdown" ng-disabled=ctrl.computing ng-if=ctrl.isDatabaseDdwVisible()><button class="btn btn-default dropdown-toggle" type=button id=dropdownMenu1 data-toggle=dropdown aria-expanded=true ng-disabled=ctrl.computing ng-if=ctrl.isDatabaseDdwVisible()>{{ctrl.getSelectedDb()}}<div class=down-arrow><span class="fa-stack fa-lg"><i class="fa fa-angle-down fa-stack-1x"></i></span></div></button><ul class=dropdown-menu role=menu aria-labelledby=dropdownMenu1 ng-if=ctrl.isDatabaseDdwVisible()><li ng-repeat="db in ctrl.databases" ng-click=ctrl.selectDb($index) ng-class="{active: $index == ctrl.selectedDbIndex}"><a>{{db}}</a></li></ul></div><div class=login-support ng-cloak=true><div class=pull-left><div ng-show=ctrl.resetPasswordOptions>Forgot your&nbsp;<a href=javascript:; ng-class="ctrl.computing?\'disabledLink\':\'\'" ng-click=ctrl.openResetPassword()>Username</a> or <a href=javascript:; ng-class="ctrl.computing?\'disabledLink\':\'\'" ng-click=ctrl.openResetPassword()>Password</a>?</div><div ng-show=ctrl.changePasswordOptions><a href=javascript:; ng-class="ctrl.computing?\'disabledLink\':\'\'" ng-click=ctrl.openChangePassword()>Change password</a></div><br>Need <a href=javascript:; ng-class="ctrl.computing?\'disabledLink\':\'\'">Support</a>?</div></div><div class=pull-left ng-hide=ctrl.isRetrieveCredentials></div><div class=pull-right><ers-button name=btnLogin ng-disabled="loginForm.$invalid || ctrl.computing" type=submit ng-click=ctrl.login() label=Login form=loginForm></ers-button></div></fieldset></form></div></div></div>');
}]);
})();

(function(module) {
try {
  module = angular.module('ers.components.templates');
} catch (e) {
  module = angular.module('ers.components.templates', []);
}
module.run(['$templateCache', function($templateCache) {
  $templateCache.put('modal/template/information-modal-template.html',
    '<ers-icon ng-if=ctrl.icon name={{ctrl.icon}} size=40></ers-icon><p style=padding-top:10px id=ersModalMessageContent>{{ctrl.message}}</p>');
}]);
})();

(function(module) {
try {
  module = angular.module('ers.components.templates');
} catch (e) {
  module = angular.module('ers.components.templates', []);
}
module.run(['$templateCache', function($templateCache) {
  $templateCache.put('modal/template/modal-template.html',
    '<div class=ers-modal id={{ctrl.id}}><div class=modal-header><strong>{{ctrl.title}}</strong><div class=pull-right ng-if="ctrl.dismissCrossButtonVisible && !ctrl.disableAllButtons()"><a ng-disabled=ctrl.disableAllButtons() class=close ng-click=ctrl.onDismissModal($event)><span class="glyphicon glyphicon-remove"></span></a></div></div><div class=modal-body><form name=modalForm role=form autocomplete=off novalidate id=modalForm_{{ctrl.id}}><div class=modal-form><ng-include src=ctrl.instanceTemplate></ng-include></div><div class=form-input><div class=pull-right id=ersModalButtonBar><input id=fake style=display:none;width:0;height:0;border:0;><ers-button ng-repeat="button in ctrl.buttons" type="{{button.commitChoice?\'submit\':\'button\'}}" form="{{button.commitChoice?\'modalForm_\'+ctrl.id:\'button\'+$index+\'\'}}" id={{button.id}} name="{{button.commitChoice?\'commit\':\'button\'+$index+\'\'}}" class="{{button.escapeChoice?\'secondary\':\'primary\'}}" label={{button.label}} ers-enter=ctrl.buttonEnter ng-click=button.escapeChoice?ctrl.onDismissModal($event):ctrl.onCloseModal($event) ng-disabled=button.commitChoice?!ctrl.formIsValid():ctrl.disableAllButtons()><ers-icon name={{button.icon}} ng-if=button.icon></ers-icon></ers-button></div></div></form></div></div><ers-modal-script modal-id={{ctrl.id}} draggable=ctrl.draggable resizable=ctrl.resizable modal=ctrl.modal focus-path=ctrl.focusPath></ers-modal-script>');
}]);
})();

(function(module) {
try {
  module = angular.module('ers.components.templates');
} catch (e) {
  module = angular.module('ers.components.templates', []);
}
module.run(['$templateCache', function($templateCache) {
  $templateCache.put('navigation/template/navigation-item-template.html',
    '<div class=ers-nav-heading>{{vm.heading}}</div><div class=ers-nav-content ng-transclude></div>');
}]);
})();

(function(module) {
try {
  module = angular.module('ers.components.templates');
} catch (e) {
  module = angular.module('ers.components.templates', []);
}
module.run(['$templateCache', function($templateCache) {
  $templateCache.put('navigation/template/navigation-template.html',
    '<div class=menu data-scope-id={{$id}} data-show-active={{vm.showActive}} ng-transclude></div><div class=footer>&copy; 2016 Moody\'s Analytics, Inc. and/or its licensors and affiliates. All rights reserved.</div>');
}]);
})();

(function(module) {
try {
  module = angular.module('ers.components.templates');
} catch (e) {
  module = angular.module('ers.components.templates', []);
}
module.run(['$templateCache', function($templateCache) {
  $templateCache.put('numberbox/template/numberbox-template.html',
    '<div ng-form=subFormTextbox><input type=text name={{::c.name}} ng-required=c.required ng-pattern=c.textPattern ng-readonly=c.readOnly ng-disabled=c.ngDisabled ng-trim=false></div>');
}]);
})();

(function(module) {
try {
  module = angular.module('ers.components.templates');
} catch (e) {
  module = angular.module('ers.components.templates', []);
}
module.run(['$templateCache', function($templateCache) {
  $templateCache.put('panel/template/panel-body.html',
    '<div class=panel-collapse ng-class="{isClosed: bodyCtrl.closed()}" uib-collapse=bodyCtrl.closed()><div class=panel-body ng-transclude></div></div>');
}]);
})();

(function(module) {
try {
  module = angular.module('ers.components.templates');
} catch (e) {
  module = angular.module('ers.components.templates', []);
}
module.run(['$templateCache', function($templateCache) {
  $templateCache.put('panel/template/panel-custom-template.html',
    '<div class=panel ng-class="ctrl.panelClass || \'panel-default\'" ng-transclude></div>');
}]);
})();

(function(module) {
try {
  module = angular.module('ers.components.templates');
} catch (e) {
  module = angular.module('ers.components.templates', []);
}
module.run(['$templateCache', function($templateCache) {
  $templateCache.put('panel/template/panel-header.html',
    '<div class=panel-heading><div class="btn-group pull-left" ng-show=headerCtrl.collapsible><button class="btn btn-icon" ng-click=headerCtrl.toggle() tt-placement=top><i class=icon ng-class="{\'fa fa-chevron-up\': !headerCtrl.closed, \'fa fa-chevron-down\': headerCtrl.closed}"></i></button></div><div ng-transclude></div></div>');
}]);
})();

(function(module) {
try {
  module = angular.module('ers.components.templates');
} catch (e) {
  module = angular.module('ers.components.templates', []);
}
module.run(['$templateCache', function($templateCache) {
  $templateCache.put('panel/template/panel-template.html',
    '<div class=panel ng-class="ctrl.panelClass || \'panel-default\'"><ers-panel-header>{{ctrl.header}}</ers-panel-header><ers-panel-body><ng-transclude></ng-transclude></ers-panel-body></div>');
}]);
})();

(function(module) {
try {
  module = angular.module('ers.components.templates');
} catch (e) {
  module = angular.module('ers.components.templates', []);
}
module.run(['$templateCache', function($templateCache) {
  $templateCache.put('password-management/template/change-password-template.html',
    '<div class=ers-change-password><div class=change-password-box ng-cloak><div class=form-error ng-show=ctrl.changePasswordError>{{ctrl.changePasswordError.message}}</div><div class=form-input><input type=text name=username ng-model=ctrl.username placeholder="User ID" ng-disabled="ctrl.usernameInitialized || ctrl.computing" ng-change="ctrl.changePasswordError=undefined" class="{{ctrl.changePasswordError? (ctrl.changePasswordError.credentialsError? \'invalid\' : \'valid\' ): \'\'}}" autocomplete=off required><br></div><div class=txt-database ng-if=ctrl.database>Database: {{ctrl.database}}</div><div class=form-input><input type=password name=oldpassword ng-model=ctrl.oldPassword ng-change="ctrl.changePasswordError=undefined" class="{{ctrl.changePasswordError? (ctrl.changePasswordError.credentialsError? \'invalid\' : \'valid\' ): \'\'}}" placeholder="Old Password" ng-disabled=ctrl.computing autocomplete=off required></div><div class=form-input><input type=password name=newPassword ng-model=ctrl.newPassword ng-change="ctrl.changePasswordError=undefined" class="{{ctrl.changePasswordError? (ctrl.changePasswordError.newPasswordError? \'invalid\' : \'valid\' ): \'\'}}" placeholder="New Password" ng-disabled=ctrl.computing autocomplete=off required></div><div class=form-input><input type=password name=confirmPassword ng-change="ctrl.changePasswordError=undefined" class="{{ctrl.changePasswordError? (ctrl.changePasswordError.newPasswordError? \'invalid\' : \'valid\' ): \'\'}}" ng-model=ctrl.confirmNewPassword ng-disabled=ctrl.computing placeholder="Confirm New Password" autocomplete=off required></div></div></div>');
}]);
})();

(function(module) {
try {
  module = angular.module('ers.components.templates');
} catch (e) {
  module = angular.module('ers.components.templates', []);
}
module.run(['$templateCache', function($templateCache) {
  $templateCache.put('password-management/template/reset-password-template.html',
    '<div style="width:300px; margin:0 auto;"><div class=ers-reset-password><div class=rp-box><div class=rp-message>Enter your email address and we will send you an email with instructions to reset your password.</div><form name=rpForm role=form autocomplete=off novalidate id=rpForm><fieldset><input type=text style="display: none;"><div class=form-input><input type=text name=email placeholder=Email autofocus autocomplete=off ng-model=ctrl.email></div></fieldset></form></div></div></div>');
}]);
})();

(function(module) {
try {
  module = angular.module('ers.components.templates');
} catch (e) {
  module = angular.module('ers.components.templates', []);
}
module.run(['$templateCache', function($templateCache) {
  $templateCache.put('popover/template/popover.tpl.html',
    '<div class=ers-popover><h3 class=popover-title ng-bind=title ng-show=title></h3><div class=popover-content ng-bind=content></div></div>');
}]);
})();

(function(module) {
try {
  module = angular.module('ers.components.templates');
} catch (e) {
  module = angular.module('ers.components.templates', []);
}
module.run(['$templateCache', function($templateCache) {
  $templateCache.put('radio-buttons/template/radio-button-template.html',
    '<div class=ers-radio-button><div class=radio-btn-div><div></div></div><div class=radio-display-div ng-transclude></div></div>');
}]);
})();

(function(module) {
try {
  module = angular.module('ers.components.templates');
} catch (e) {
  module = angular.module('ers.components.templates', []);
}
module.run(['$templateCache', function($templateCache) {
  $templateCache.put('radio-buttons/template/radio-group-template.html',
    '<div ng-form=subForm name={{::c.name}}><ng-transclude></ng-transclude></div>');
}]);
})();

(function(module) {
try {
  module = angular.module('ers.components.templates');
} catch (e) {
  module = angular.module('ers.components.templates', []);
}
module.run(['$templateCache', function($templateCache) {
  $templateCache.put('shell/template/settings-template.html',
    '<div><div class=modal-header><strong>Change Password</strong><div class=pull-right><a class=close ers-modal-cancel><span class="glyphicon glyphicon-remove-circle"></span></a></div></div><div class=modal-body><div class=loginBox ng-cloak><div class=formError ng-show=ChangePasswordController.changePasswordError>{{ChangePasswordController.changePasswordError.message}}</div><form name=loginForm role=form autocomplete=off novalidate><fieldset><div class=formInput><input type=text name=username ng-model=ChangePasswordController.username placeholder="User ID" required ng-disabled=ChangePasswordController.usernameInitialized class="{{ChangePasswordController.changePasswordError && ChangePasswordController.changePasswordError.credentialsError? \'invalid\' : (loginForm.username.$dirty ? \'valid\' : \'\')}}" autocomplete=off><br></div><div class=txtDatabase>Database: {{ChangePasswordController.database}}<div class=formInput></div><input type=password name=oldPassword ng-model=ChangePasswordController.oldPassword class="{{ChangePasswordController.changePasswordError && ChangePasswordController.changePasswordError.credentialsError? \'invalid\' : (loginForm.oldPassword.$dirty ? \'valid\' : \'\')}}" placeholder="Old Password" required autocomplete=off></div><div class=formInput><input type=password name=newPassword ng-model=ChangePasswordController.newPassword class="{{ChangePasswordController.changePasswordError && ChangePasswordController.changePasswordError.newPasswordError? \'invalid\' : (loginForm.newPassword.$dirty ? \'valid\' : \'\')}}" placeholder="New Password" required autocomplete=off></div><div class=formInput><input type=password name=confirmPassword class="{{ChangePasswordController.changePasswordError && ChangePasswordController.changePasswordError.newPasswordError? \'invalid\' : (loginForm.newPassword.$dirty ? \'valid\' : \'\')}}" ng-model=ChangePasswordController.confirmNewPassword placeholder="Confirm New Password" required autocomplete=off></div><div class=formInput><div class=pull-right><button class="btn btn-secondary btn-sm" type=button ers-modal-cancel>Cancel</button> <button class="btn btn-primary btn-sm" ng-disabled=loginForm.$invalid ers-modal-close on-modal-close=closeModal()>Update</button></div></div></fieldset></form></div></div></div>');
}]);
})();

(function(module) {
try {
  module = angular.module('ers.components.templates');
} catch (e) {
  module = angular.module('ers.components.templates', []);
}
module.run(['$templateCache', function($templateCache) {
  $templateCache.put('shell/template/shell-template.html',
    '<div class=ers-shell-top><div class=header><span><ers-top-shell on-settings=ctrl.onSettings() on-info=ctrl.onInfo() on-help=ctrl.onHelp() on-edit-profile=ctrl.onEditProfile() on-logout=ctrl.onLogout() products=ctrl.products current-product=ctrl.currentProduct on-product-change=ctrl._onProductChange(newProduct,oldProduct) on-after-product-change=ctrl.onAfterProductChange(newProduct,oldProduct) user-info=ctrl.userInfo on-context-selector=ctrl.onContextSelector() current-context=ctrl.currentContext help-is-visible=ctrl.helpIsVisible info-is-visible=ctrl.infoIsVisible settings-is-visible=ctrl.settingsIsVisible title={{ctrl.title}}></ers-top-shell></span></div><div class=product-view></div></div>');
}]);
})();

(function(module) {
try {
  module = angular.module('ers.components.templates');
} catch (e) {
  module = angular.module('ers.components.templates', []);
}
module.run(['$templateCache', function($templateCache) {
  $templateCache.put('shell/template/top-shell-template.html',
    '<div class=header-bar><div uib-dropdown class=ers-top-shell-product-selector><button class="btn btn-default" uib-dropdown-toggle><span ng-if=ctrl.currentProduct.label>{{ctrl.currentProduct.label}}</span></button><ul uib-dropdown-menu role=menu><li tabindex=-1 href=# ng-repeat="product in ctrl.products" title=Product_{{::product.label}} ng-click="ctrl.currentProduct = ctrl.products[$index]" ng-class="{active: $index == ctrl.selectedProductIndex}"><a href=javascript:;>{{::product.label}}</a></li></ul></div><div class=right-nav><span class=dropdown style="cursor: pointer" title="Context selector" ng-click=ctrl.onContextSelector()>{{ctrl.currentContext}}<span><i class="fa fa-angle-down fa-inverse"></i></span></span><span uib-dropdown class=ers-top-shell-user-info><span uib-dropdown-toggle><a href=javascript:;><span class="glyphicon glyphicon-user"></span></a> <span class="hidden-sm hidden-xs" title="User name">{{::ctrl.userInfo.name}}</span> <span><i class="fa fa-angle-down fa-inverse"></i></span></span><ul uib-dropdown-menu class="dropdown-menu-arrow dropdown-menu-right"><li><a href=javascript:; title="Last login">{{::ctrl.userInfo.lastLogin}}</a></li><li><a href=javascript:; ng-click=ctrl.onEditProfile() title="Edit profile">Edit Profile</a></li><li><a href=javascript:; ng-click=ctrl.onLogout() title=Logout>Logout</a></li></ul></span><a href=javascript:; title=Info ng-click=ctrl.onInfo() ng-if=ctrl.isInfoVisible()><i class="fa fa-info-circle fa-inverse"></i></a> <a href=javascript:; title=Help ng-click=ctrl.onHelp() ng-if=ctrl.isHelpVisible()><i class="fa fa-question-circle fa-inverse"></i></a> <a href=javascript:; title=Settings ng-click=ctrl.onSettings() ng-if=ctrl.isSettingsVisible()><i class="fa fa-gear fa-inverse"></i></a></div><h1 class=title>{{ctrl.title}}</h1></div>');
}]);
})();

(function(module) {
try {
  module = angular.module('ers.components.templates');
} catch (e) {
  module = angular.module('ers.components.templates', []);
}
module.run(['$templateCache', function($templateCache) {
  $templateCache.put('tabs/template/tab-template.html',
    '<li role=presentation ng-click=vm.onSelect() ng-class="{ active: vm.active, error: vm.errors.length }"><a ng-if=!vm.errors role=menuitem class=tab-heading title={{vm.heading}} ers-tab-heading-transclude>{{vm.heading}}</a> <a ng-if=vm.errors role=menuitem class=tab-heading tt-placement=top tt-theme=error ers-tooltip tt-title="{{vm.errors.join(\', \')}}" title={{vm.heading}} ers-tab-heading-transclude>{{vm.heading}}</a> <i class="tab-icon tab-icon-error fa fa-circle" ng-if=vm.errors.length></i> <i class="tab-icon tab-icon-close fa fa-times" ng-click=vm.onClose() ng-if="vm.tabset.canClose && (vm.tabset.tabs.length > 1 || vm.tabset.canCloseSingle)"></i></li>');
}]);
})();

(function(module) {
try {
  module = angular.module('ers.components.templates');
} catch (e) {
  module = angular.module('ers.components.templates', []);
}
module.run(['$templateCache', function($templateCache) {
  $templateCache.put('tabs/template/tabset-template.html',
    '<div class=fade-left ng-show="vm.leftHiddenTabs.length > 0"></div><div class=fade-right ng-show="vm.rightHiddenTabs.length > 0"></div><div class=dropdown ng-show="vm.menuItemsOfHiddenTabs.length > 0"><ers-link-menu class=dropdown-toggle ng-attr-id={{::vm.dropdownMenuId()}} placement=bottom-right menu-items=vm.menuItemsOfHiddenTabs></ers-link-menu></div><div class=nav-tabs-wrapper><ul class="nav nav-tabs" ng-transclude></ul></div><div class=tab-content><div class=tab-pane ng-repeat="tab in vm.tabs" ng-class="{ active: tab.active }"><div ers-tab-content-transclude=tab></div></div></div>');
}]);
})();

(function(module) {
try {
  module = angular.module('ers.components.templates');
} catch (e) {
  module = angular.module('ers.components.templates', []);
}
module.run(['$templateCache', function($templateCache) {
  $templateCache.put('textbox/template/textbox-template.html',
    '<div ng-form=subFormTextbox><input type="{{c.password ? \'password\' : \'text\'}}" name={{::c.name}} placeholder={{c.placeholder}} ng-required=c.required ng-readonly=c.readOnly ng-disabled=c.ngDisabled ng-trim=false></div>');
}]);
})();

(function(module) {
try {
  module = angular.module('ers.components.templates');
} catch (e) {
  module = angular.module('ers.components.templates', []);
}
module.run(['$templateCache', function($templateCache) {
  $templateCache.put('toolbar/template/toolbar-template.html',
    '<div class=ers-toolbar><div class="toolbar-container toolbar-hz" ng-transclude></div></div>');
}]);
})();

(function(module) {
try {
  module = angular.module('ers.components.templates');
} catch (e) {
  module = angular.module('ers.components.templates', []);
}
module.run(['$templateCache', function($templateCache) {
  $templateCache.put('tooltip/template/tooltip.tpl.html',
    '<div class=ers-tooltip ng-show="tooltip || title"><div class=tooltip-title ng-bind="tooltip || title"></div></div>');
}]);
})();

(function(module) {
try {
  module = angular.module('ers.components.templates');
} catch (e) {
  module = angular.module('ers.components.templates', []);
}
module.run(['$templateCache', function($templateCache) {
  $templateCache.put('tree/template/tree.tpl.html',
    '<div class=ers-tree><ers-tree-items parent-item=root tabindex=0 tree-id={{treeId}} expand-icon={{expandIcon}} collapse-icon={{collapseIcon}} multiple-selection=multipleSelection selected-item=selectedItem item-renderer=itemRenderer item-loader=itemLoader tree-draggable=treeDraggable></ers-tree-items><div ng-transclude style="display: none"></div></div>');
}]);
})();

(function(module) {
try {
  module = angular.module('ers.components.templates');
} catch (e) {
  module = angular.module('ers.components.templates', []);
}
module.run(['$templateCache', function($templateCache) {
  $templateCache.put('tree/template/treeitem.tpl.html',
    '<li draggable={{treeController.treeDraggable}}><a href=javascript:void(0) tabindex=0 draggable=false ng-class="{\'selected\': item.selected}" ng-click=onItemClick()><span class="indented expand-collapse-icon" ng-style="{\'left\': 25 * level}" ng-show="item.children.length > 0 || item.loading"><i class="fa fa-{{::collapseIcon}}" ng-show="item.collapsed && item.children.length > 0 && !item.loading" ng-click=item.expand($event)></i> <i class="fa fa-{{::expandIcon}}" ng-show="!item.collapsed && item.children.length > 0 && !item.loading" ng-click=item.collapse($event)></i> <span ng-show=item.loading><i class="fa fa-spinner fa-spin"></i></span></span> <span class="indented tree-item" ng-style="{\'left\': 25 * level, \'padding-right\': 25 * level + 5}" ers-tree-item-renderer-holder item-renderer=itemRenderer item=item><i class="tree-item-icon fa fa-{{::item.icon}}" ng-show="item.isLeaf && item.icon"></i><ers-label value={{item.label}}></ers-label></span></a></li>');
}]);
})();

(function(module) {
try {
  module = angular.module('ers.components.templates');
} catch (e) {
  module = angular.module('ers.components.templates', []);
}
module.run(['$templateCache', function($templateCache) {
  $templateCache.put('tree/template/treeitems.tpl.html',
    '<ul><ers-tree-item ng-if=ctrl.parentItem ng-repeat="item in ctrl.parentItem.children" item=item parent=ctrl level=ctrl.level collapse-icon=ctrl.collapseIcon expand-icon=ctrl.expandIcon item-renderer=ctrl.itemRenderer item-loader=ctrl.itemLoader></ers-tree-item></ul>');
}]);
})();
